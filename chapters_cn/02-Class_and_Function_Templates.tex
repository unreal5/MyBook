% EN: ﻿\chapter{Class and Function Templates}
\Trans{﻿\chapter{Class and Function Templates}}{}

% EN: The template programming features of C++ form a large and complex subject, with many books dedicated exclusively to teaching these features. In this book, we will use many of the advanced C++ generic programming features. How, then, should we prepare ourselves to understand these language constructs as they make their appearance throughout this book? This chapter takes an informal approach---instead of precise definitions, we demonstrate the use of templates through examples and explain what the different language features do. If you find your knowledge lacking at this point, you're encouraged to seek a deeper understanding and read one or more of the books dedicated entirely to the C++ language that are focused on explaining its syntax and semantics. Of course, if you wish for a more precise, formal description, you can refer to the C++ standard or a reference book.
\Trans{The template programming features of C++ form a large and complex subject, with many books dedicated exclusively to teaching these features. In this book, we will use many of the advanced C++ generic programming features. How, then, should we prepare ourselves to understand these language constructs as they make their appearance throughout this book? This chapter takes an informal approach---instead of precise definitions, we demonstrate the use of templates through examples and explain what the different language features do. If you find your knowledge lacking at this point, you're encouraged to seek a deeper understanding and read one or more of the books dedicated entirely to the C++ language that are focused on explaining its syntax and semantics. Of course, if you wish for a more precise, formal description, you can refer to the C++ standard or a reference book.}{}

% EN: The following topics will be covered in this chapter:
\Trans{The following topics will be covered in this chapter:}{}

\begin{itemize}
\item
% EN:   Templates in C++
\Trans{Templates in C++}{}
\item
% EN:   Class and function templates
\Trans{Class and function templates}{}
\item
% EN:   Template instantiations
\Trans{Template instantiations}{}
\item
% EN:   Template specializations
\Trans{Template specializations}{}
\item
% EN:   Overloading of template functions
\Trans{Overloading of template functions}{}
\item
% EN:   Variadic templates
\Trans{Variadic templates}{}
\item
% EN:   Lambda expressions
\Trans{Lambda expressions}{}
\item
% EN:   Concepts
\Trans{Concepts}{}
\end{itemize}

\section{Templates in C++}

% EN: One of the greatest strengths of C++ is its support for generic programming. In generic programming, the algorithms and data structures are written in terms of generic types that will be specified later. This allows the programmer to implement a function or a class once, and later, instantiate it for many different types. Templates are a C++ feature that allows classes and functions to be defined on generic types. C++ supports three kinds of templates---function, class, and variable templates.
\Trans{One of the greatest strengths of C++ is its support for generic programming. In generic programming, the algorithms and data structures are written in terms of generic types that will be specified later. This allows the programmer to implement a function or a class once, and later, instantiate it for many different types. Templates are a C++ feature that allows classes and functions to be defined on generic types. C++ supports three kinds of templates---function, class, and variable templates.}{}

\subsection{Function templates}

% EN: Function templates are generic functions---unlike regular functions, a template function does not declare its argument types. Instead, the types are template parameters:
\Trans{Function templates are generic functions---unlike regular functions, a template function does not declare its argument types. Instead, the types are template parameters:}{}

\begin{code}
% EN: // Example 01
template <typename T>
T increment(T x) { return x + 1;  }
\Trans{// Example 01 template <typename T> T increment(T x) { return x + 1; }}{}

\end{code}

% EN: This template function can be used to increment a value of any type by one, for which adding one is a valid operation:
\Trans{This template function can be used to increment a value of any type by one, for which adding one is a valid operation:}{}

\begin{code}
% EN: increment(5);    // T is int, returns 6
increment(4.2);    // T is double, return 5.2 char c[10];
increment(c);    // T is char*, returns &c[1]
\Trans{increment(5); // T is int, returns 6 increment(4.2); // T is double, return 5.2 char c[10]; increment(c); // T is char*, returns &c[1]}{}

\end{code}

% EN: Most template functions have some limitations on the types that are used as their template parameters. For example, our \texttt{increment()} function requires that the expression \texttt{x\ +\ 1} is valid for the type of \texttt{x}. Otherwise, the attempt to instantiate the template will fail, with a somewhat verbose compilation error.
\Trans{Most template functions have some limitations on the types that are used as their template parameters. For example, our \texttt{increment()} function requires that the expression \texttt{x\ +\ 1} is valid for the type of \texttt{x}. Otherwise, the attempt to instantiate the template will fail, with a somewhat verbose compilation error.}{}

% EN: Both non-member and class member functions can be function templates; however, virtual functions cannot be templates. The generic types can be used not only to declare function parameters but to declare any variables inside the body of the function:
\Trans{Both non-member and class member functions can be function templates; however, virtual functions cannot be templates. The generic types can be used not only to declare function parameters but to declare any variables inside the body of the function:}{}

\begin{code}
% EN: template <typename T> T sum(T from, T to, T step) {
  T res = from;
  while ((from += step) < to) { res += from;  }
  return res;
\Trans{template <typename T> T sum(T from, T to, T step) { T res = from; while ((from += step) < to) { res += from; } return res;}{}

}
\end{code}

% EN: In C++20, simple template declarations can be abbreviated: instead of writing
\Trans{In C++20, simple template declarations can be abbreviated: instead of writing}{}

\begin{code}
% EN: template <typename T> void f(T t);
\Trans{template <typename T> void f(T t);}{}
\end{code}

% EN: we can write
\Trans{we can write}{}

\begin{code}
% EN: // Example 01a
void f(auto t);
\Trans{// Example 01a void f(auto t);}{}

\end{code}

% EN: Other than more terse declarations, there is no particular advantage to this abbreviation, and the feature is quite limited. First of all, \texttt{auto} can be used only as the ``top-level'' parameter type; for example, this is invalid (but allowed by some compilers):
\Trans{Other than more terse declarations, there is no particular advantage to this abbreviation, and the feature is quite limited. First of all, \texttt{auto} can be used only as the ``top-level'' parameter type; for example, this is invalid (but allowed by some compilers):}{}

\begin{code}
% EN: void f(std::vector<auto>& v);
\Trans{void f(std::vector<auto>& v);}{}
\end{code}

% EN: and must still be written as
\Trans{and must still be written as}{}

\begin{code}
% EN: template <typename T> void f(std::vector<T>& v);
\Trans{template <typename T> void f(std::vector<T>& v);}{}
\end{code}

% EN: Also, if you need to use template type parameters elsewhere in the function declaration, you can't abbreviate them:
\Trans{Also, if you need to use template type parameters elsewhere in the function declaration, you can't abbreviate them:}{}

\begin{code}
% EN: template <typename T> T f(T t);
\Trans{template <typename T> T f(T t);}{}
\end{code}

% EN: Of course, you could declare the return type as \texttt{auto} and use the trailing return type:
\Trans{Of course, you could declare the return type as \texttt{auto} and use the trailing return type:}{}

\begin{code}
% EN: auto f(auto t) -> decltype(t);
\Trans{auto f(auto t) -> decltype(t);}{}
\end{code}

% EN: but at this point, the template is not really ``abbreviated.''
\Trans{but at this point, the template is not really ``abbreviated.''}{}

% EN: We will see more of function templates later, but let's introduce class templates next.
\Trans{We will see more of function templates later, but let's introduce class templates next.}{}

\subsection{Class templates}

% EN: Class templates are classes that use generic types, usually to declare their data members, but also to declare methods and local variables inside them:
\Trans{Class templates are classes that use generic types, usually to declare their data members, but also to declare methods and local variables inside them:}{}

\begin{code}
% EN: // Example 02
template <typename T> class ArrayOf2 {
  public:
  T& operator[](size_t i) { return a_[i];  }
  const T& operator[](size_t i) const { return a_[i];  }
  T sum() const { return a_[0] + a_[1];  }
  private:
  T a_[2];
 };
\Trans{// Example 02 template <typename T> class ArrayOf2 { public: T& operator[](size_t i) { return a_[i]; } const T& operator[](size_t i) const { return a_[i]; } T sum() const { return a_[0] + a_[1]; } private: T a_[2]; };}{}

\end{code}

% EN: This class is implemented once, and can then be used to define an array of two elements of any type:
\Trans{This class is implemented once, and can then be used to define an array of two elements of any type:}{}

\begin{code}
% EN: ArrayOf2<int> i; i[0] = 1; i[1] = 5;
std::cout << i.sum();                       // 6
ArrayOf2<double> x; x[0] = -3.5; x[1] = 4;
std::cout << x.sum();                       // 0.5
ArrayOf2<char*> c; char s[] = "Hello";
c[0] = s; c[1] = s + 2;
\Trans{ArrayOf2<int> i; i[0] = 1; i[1] = 5; std::cout << i.sum(); // 6 ArrayOf2<double> x; x[0] = -3.5; x[1] = 4; std::cout << x.sum(); // 0.5 ArrayOf2<char*> c; char s[] = "Hello"; c[0] = s; c[1] = s + 2;}{}

\end{code}

% EN: Pay particular attention to the last example---you might expect the \texttt{ArrayOf2} template not to be valid with a type such as \texttt{char*}---after all, it has a method, \texttt{sum()}, that does not compile if the type of \texttt{a\_{[}0{]}} and \texttt{a\_{[}1{]}} is a pointer. However, our example compiles as written---a method of a class template does not have to be valid until we try to use it. If we never call \texttt{c.sum()}, then the fact that it would not compile never comes up, and the program remains valid. If we do call a member function that does not compile for the chosen template arguments, we get a syntax error in the body of the template (in our example, something about not being able to add two pointers). These error messages are rarely straightforward. Even if they were, it is unclear if the problem is in the body of the function, or if the function was not supposed to be called in the first place. Later in this chapter, we will see how to improve this situation.
\Trans{Pay particular attention to the last example---you might expect the \texttt{ArrayOf2} template not to be valid with a type such as \texttt{char*}---after all, it has a method, \texttt{sum()}, that does not compile if the type of \texttt{a\_{[}0{]}} and \texttt{a\_{[}1{]}} is a pointer. However, our example compiles as written---a method of a class template does not have to be valid until we try to use it. If we never call \texttt{c.sum()}, then the fact that it would not compile never comes up, and the program remains valid. If we do call a member function that does not compile for the chosen template arguments, we get a syntax error in the body of the template (in our example, something about not being able to add two pointers). These error messages are rarely straightforward. Even if they were, it is unclear if the problem is in the body of the function, or if the function was not supposed to be called in the first place. Later in this chapter, we will see how to improve this situation.}{}

\subsection{Variable templates}

% EN: The last kind of template in C++ is a variable template, which was introduced in C++14. This template allows us to define a variable with a generic type:
\Trans{The last kind of template in C++ is a variable template, which was introduced in C++14. This template allows us to define a variable with a generic type:}{}

\begin{code}
% EN: // Example 03
template <typename T> constexpr T pi =
T(3.14159265358979323846264338327950288419716939937510582097494459230781L);
pi<float>;      // 3.141592
pi<double>;     // 3.141592653589793
\Trans{// Example 03 template <typename T> constexpr T pi = T(3.14159265358979323846264338327950288419716939937510582097494459230781L); pi<float>; // 3.141592 pi<double>; // 3.141592653589793}{}

\end{code}

% EN: Variable templates are, for the most part, very straightforward to use, mostly for defining your own constants, but there are some interesting patterns that take advantage of them; we will see one in the next section.
\Trans{Variable templates are, for the most part, very straightforward to use, mostly for defining your own constants, but there are some interesting patterns that take advantage of them; we will see one in the next section.}{}

\subsection{Non-type template parameters}

% EN: Usually, template parameters are types, but C++ also allows for several kinds of non-type parameters. First of all, template parameters can be values of integer or enumeration types:
\Trans{Usually, template parameters are types, but C++ also allows for several kinds of non-type parameters. First of all, template parameters can be values of integer or enumeration types:}{}

\begin{code}
% EN: // Example 04
template <typename T, size_t N> class Array {
  public:
  T& operator[](size_t i) {
    if (i >= N) throw std::out_of_range("Bad index");
     return data_[i];
   }
  private:
  T data_[N];
 };
Array<int, 5> a;      // OK
cin >> a[0];
Array<int, a[0]> b;   // Error
\Trans{// Example 04 template <typename T, size_t N> class Array { public: T& operator[](size_t i) { if (i >= N) throw std::out_of_range("Bad index"); return data_[i]; } private: T data_[N]; }; Array<int, 5> a; // OK cin >> a[0]; Array<int, a[0]> b; // Error}{}

\end{code}

% EN: This is a template with two parameters---the first is a type, but the second is not. It is a value of type \texttt{size\_t} that determines the size of the array; the advantage of such a template over a built-in C-style array is that it can do range checking. The C++ standard library has a \texttt{std::array} class template that should be used instead of implementing your own array in any real program, but it does make for an easy-to-follow example.
\Trans{This is a template with two parameters---the first is a type, but the second is not. It is a value of type \texttt{size\_t} that determines the size of the array; the advantage of such a template over a built-in C-style array is that it can do range checking. The C++ standard library has a \texttt{std::array} class template that should be used instead of implementing your own array in any real program, but it does make for an easy-to-follow example.}{}

% EN: The values of non-type parameters that are used to instantiate a template must be compile-time constants or \texttt{constexpr} values---the last line in the preceding example is invalid because the value of \texttt{a{[}0{]}} is not known until the program reads it in at runtime. C++20 allows floating-point and user-defined types for non-type template parameters; until then, the parameters were limited to integral types, pointers (including function and member pointers), references, and enumerations. Of course, the value of a non-type parameter has to be a compile-time constant so, for example, pointers to local variables are not allowed.
\Trans{The values of non-type parameters that are used to instantiate a template must be compile-time constants or \texttt{constexpr} values---the last line in the preceding example is invalid because the value of \texttt{a{[}0{]}} is not known until the program reads it in at runtime. C++20 allows floating-point and user-defined types for non-type template parameters; until then, the parameters were limited to integral types, pointers (including function and member pointers), references, and enumerations. Of course, the value of a non-type parameter has to be a compile-time constant so, for example, pointers to local variables are not allowed.}{}

% EN: The numeric template parameters used to be very popular in C++ because they allow complex compile-time calculations to be implemented, but in the recent versions of the standard, \texttt{constexpr} functions can be used to the same effect and are much easier to read. Of course, the standard takes with one hand and gives with the other, and so an interesting new use case emerged for non-template parameters combined with \texttt{constexpr} functions: these functions, first introduced in C++11, are used to define ``immediate functions,'' or functions that are evaluated at compile time. The problem with \texttt{constexpr} functions is that they \emph{may} evaluate at compile time but it's not required; they could also be evaluated at run time:
\Trans{The numeric template parameters used to be very popular in C++ because they allow complex compile-time calculations to be implemented, but in the recent versions of the standard, \texttt{constexpr} functions can be used to the same effect and are much easier to read. Of course, the standard takes with one hand and gives with the other, and so an interesting new use case emerged for non-template parameters combined with \texttt{constexpr} functions: these functions, first introduced in C++11, are used to define ``immediate functions,'' or functions that are evaluated at compile time. The problem with \texttt{constexpr} functions is that they \emph{may} evaluate at compile time but it's not required; they could also be evaluated at run time:}{}

\begin{code}
% EN: constexpr size_t length(const char* s) {
  size_t res = 0;
  while (*(s++)) ++res;
  return res;
\Trans{constexpr size_t length(const char* s) { size_t res = 0; while (*(s++)) ++res; return res;}{}

}
% EN: std::cout << length("abc") << std::endl;
char s[] = "runtime";
std::cout << length(s) << std::endl;
\Trans{std::cout << length("abc") << std::endl; char s[] = "runtime"; std::cout << length(s) << std::endl;}{}

\end{code}

% EN: Here we have a \texttt{constexpr} function \texttt{length()}. Does the length computation actually happen at compile time? There is no way to know short of examining the generated assembly code (which can differ from one compiler to another). The only way to be sure is to invoke the function in a compile-time context, for example:
\Trans{Here we have a \texttt{constexpr} function \texttt{length()}. Does the length computation actually happen at compile time? There is no way to know short of examining the generated assembly code (which can differ from one compiler to another). The only way to be sure is to invoke the function in a compile-time context, for example:}{}

\begin{code}
% EN: static_assert(length("abc") == 3, ""); // OK
char s[] = "runtime";
static_assert(length(s) == 7, ""); // Fails
\Trans{static_assert(length("abc") == 3, ""); // OK char s[] = "runtime"; static_assert(length(s) == 7, ""); // Fails}{}

\end{code}

% EN: The first assert compiles, and the second does not even though the value 7 is correct: the argument is not a compile-time value, so the evaluation must happen at run time.
\Trans{The first assert compiles, and the second does not even though the value 7 is correct: the argument is not a compile-time value, so the evaluation must happen at run time.}{}

% EN: In C++20, the function may be declared \texttt{consteval} instead of \texttt{constexpr}: this guarantees that the evaluation happens at compile time or not at all (thus, the second \texttt{cout} statement in the preceding example will not compile). Prior to C++20, we have to get creative. Here is one way to enforce compile-time execution:
\Trans{In C++20, the function may be declared \texttt{consteval} instead of \texttt{constexpr}: this guarantees that the evaluation happens at compile time or not at all (thus, the second \texttt{cout} statement in the preceding example will not compile). Prior to C++20, we have to get creative. Here is one way to enforce compile-time execution:}{}

\begin{code}
% EN: // Example 05c
template <auto V>
static constexpr auto force_consteval = V;
\Trans{// Example 05c template <auto V> static constexpr auto force_consteval = V;}{}

\end{code}

% EN: The \texttt{force\_consteval} variable template can be used to enforce compile-time evaluation as follows:
\Trans{The \texttt{force\_consteval} variable template can be used to enforce compile-time evaluation as follows:}{}

\begin{code}
% EN: std::cout << force_consteval<length("abc")> << std::endl;
char s[] = "runtime";
std::cout << force_consteval<length(s)> << std::endl;
\Trans{std::cout << force_consteval<length("abc")> << std::endl; char s[] = "runtime"; std::cout << force_consteval<length(s)> << std::endl;}{}

\end{code}

% EN: The second \texttt{cout} statement does not compile because the function \texttt{length()} cannot be evaluated as an immediate function. The variable template \texttt{force\_consteval} uses a non-type template parameter whose type is not specified but deduced from the template argument (an \texttt{auto} template parameter). This is a C++17 feature; in C++14 we have to use a rather unelegant macro to achieve the same result:
\Trans{The second \texttt{cout} statement does not compile because the function \texttt{length()} cannot be evaluated as an immediate function. The variable template \texttt{force\_consteval} uses a non-type template parameter whose type is not specified but deduced from the template argument (an \texttt{auto} template parameter). This is a C++17 feature; in C++14 we have to use a rather unelegant macro to achieve the same result:}{}

\begin{code}
% EN: // Example 05d
template <typename T, T V>
static constexpr auto force_consteval_helper = V;
#define force_consteval(V)
force_consteval_helper<decltype(V), (V)>
std::cout << force_consteval(length("abc")) << std::endl;
\Trans{// Example 05d template <typename T, T V> static constexpr auto force_consteval_helper = V; #define force_consteval(V) force_consteval_helper<decltype(V), (V)> std::cout << force_consteval(length("abc")) << std::endl;}{}

\end{code}

% EN: If a non-type template parameter seems ``less than a type,'' you will like the next option, a parameter that is definitely more than a simple type.
\Trans{If a non-type template parameter seems ``less than a type,'' you will like the next option, a parameter that is definitely more than a simple type.}{}

\subsection{Template template parameters}

% EN: The second kind of non-type template parameter worth mentioning is a \emph{template template} parameter---a template parameter that is itself a template. We will need them in the later chapters of this book. This template parameter is substituted---not with a name of a class, but a name of an entire template.
\Trans{The second kind of non-type template parameter worth mentioning is a \emph{template template} parameter---a template parameter that is itself a template. We will need them in the later chapters of this book. This template parameter is substituted---not with a name of a class, but a name of an entire template.}{}

% EN: Here is a class template with a template template parameter:
\Trans{Here is a class template with a template template parameter:}{}

\begin{code}
% EN: // Example 06a
template <typename T,
         template <typename> typename Container>
class Builder {
  Container<T> data_;
  public:
  void add(const T& t) { data_.push_back(t);  }
  void print() const {
    for (const auto& x : data_) std::cout << x << " ";
    std::cout << std::endl;
   }
 };
\Trans{// Example 06a template <typename T, template <typename> typename Container> class Builder { Container<T> data_; public: void add(const T& t) { data_.push_back(t); } void print() const { for (const auto& x : data_) std::cout << x << " "; std::cout << std::endl; } };}{}

\end{code}

% EN: The \texttt{Builder} template declares a class that is used to construct (build) a container of an arbitrary type \texttt{T}. The container itself does not have a specific type, it's a template itself.
\Trans{The \texttt{Builder} template declares a class that is used to construct (build) a container of an arbitrary type \texttt{T}. The container itself does not have a specific type, it's a template itself.}{}

% EN: It can be instantiated with any container template that takes one type argument:
\Trans{It can be instantiated with any container template that takes one type argument:}{}

\begin{code}
% EN: template <typename T> class my_vector { 鈥? };
Builder<int, my_vector> b;
b.add(1);
b.add(2);
b.print();
\Trans{template <typename T> class my_vector { 鈥?}; Builder<int, my_vector> b; b.add(1); b.add(2); b.print();}{}

\end{code}

% EN: Of course, there are additional requirements on the \texttt{Container} template: it must have a single type parameter \texttt{T} (the rest may be defaulted), it should be default-constructible, it must have a \texttt{push\_back()} method, and so on. C++20 gives us a concise way to state these requirements and make them a part of the template interface; we will learn about it later in this chapter, in the \emph{Concepts} section.
\Trans{Of course, there are additional requirements on the \texttt{Container} template: it must have a single type parameter \texttt{T} (the rest may be defaulted), it should be default-constructible, it must have a \texttt{push\_back()} method, and so on. C++20 gives us a concise way to state these requirements and make them a part of the template interface; we will learn about it later in this chapter, in the \emph{Concepts} section.}{}

% EN: Here is a function template that has two template template parameters:
\Trans{Here is a function template that has two template template parameters:}{}

\begin{code}
% EN: // Example 06b
template <template <typename> class Out_container,
          template <typename> class In_container,
          typename T> Out_container<T>
resequence(const In_container<T>& in_container) {
  Out_container<T> out_container;
  for (auto x : in_container) {
    out_container.push_back(x);
   }
  return out_container;
\Trans{// Example 06b template <template <typename> class Out_container, template <typename> class In_container, typename T> Out_container<T> resequence(const In_container<T>& in_container) { Out_container<T> out_container; for (auto x : in_container) { out_container.push_back(x); } return out_container;}{}

}
\end{code}

% EN: This function takes an arbitrary container as an argument and returns another container, a different template, but instantiated on the same type, with the values copied from the input container:
\Trans{This function takes an arbitrary container as an argument and returns another container, a different template, but instantiated on the same type, with the values copied from the input container:}{}

\begin{code}
% EN: my_vector<int> v { 1, 2, 3, 4, 5  };
template <typename T> class my_deque { 鈥? };
auto d = resequence<my_deque>(v);// my_deque with 1 鈥?5
\Trans{my_vector<int> v { 1, 2, 3, 4, 5 }; template <typename T> class my_deque { 鈥?}; auto d = resequence<my_deque>(v);// my_deque with 1 鈥?5}{}

\end{code}

% EN: Note that the compiler deduces both the type of the template argument (\texttt{In\_container} as \texttt{my\_vector}) and the type of its template parameter (\texttt{T} as \texttt{int}). Of course, the remaining template parameter \texttt{Out\_container} cannot be deduced (it is not used in any parameters of the template function) and must be explicitly specified, which fits our intended use.
\Trans{Note that the compiler deduces both the type of the template argument (\texttt{In\_container} as \texttt{my\_vector}) and the type of its template parameter (\texttt{T} as \texttt{int}). Of course, the remaining template parameter \texttt{Out\_container} cannot be deduced (it is not used in any parameters of the template function) and must be explicitly specified, which fits our intended use.}{}

% EN: There is a major limitation on template template parameters that is made more complex by the fact that different compilers enforce it unevenly (i.e., some compilers let through the code that should not compile but you would really like it to). The limitation is that the number of template parameters specified for the template template must match the number of the template parameters of the argument. Consider this template function:
\Trans{There is a major limitation on template template parameters that is made more complex by the fact that different compilers enforce it unevenly (i.e., some compilers let through the code that should not compile but you would really like it to). The limitation is that the number of template parameters specified for the template template must match the number of the template parameters of the argument. Consider this template function:}{}

\begin{code}
% EN: template <template <typename> class Container, typename T>
void print(const Container<T>& container) {
  for (auto x : container) { std::cout << x << " ";  }
  std::cout << std::endl;
\Trans{template <template <typename> class Container, typename T> void print(const Container<T>& container) { for (auto x : container) { std::cout << x << " "; } std::cout << std::endl;}{}

}
% EN: std::vector<int> v { 1, 2, 3, 4, 5  };
print(v);
\Trans{std::vector<int> v { 1, 2, 3, 4, 5 }; print(v);}{}

\end{code}

% EN: This code may compile, but it depends on the version of the standard and the compiler's strict adherence to the standard: the \texttt{std::vector} template has two template parameters, not one. The second parameter is the allocator; it has a default value, which is why we do not have to specify the allocator type when declaring a vector object. GCC, Clang, and MSVC all relax this requirement to some degree (but not to the same degree). Variadic templates, which we will see later in this chapter, offer another, more robust solution (at least in C++17 and later).
\Trans{This code may compile, but it depends on the version of the standard and the compiler's strict adherence to the standard: the \texttt{std::vector} template has two template parameters, not one. The second parameter is the allocator; it has a default value, which is why we do not have to specify the allocator type when declaring a vector object. GCC, Clang, and MSVC all relax this requirement to some degree (but not to the same degree). Variadic templates, which we will see later in this chapter, offer another, more robust solution (at least in C++17 and later).}{}

% EN: Templates are a kind of recipe for generating code. Next, we will see how we can convert these recipes into actual code we can run.
\Trans{Templates are a kind of recipe for generating code. Next, we will see how we can convert these recipes into actual code we can run.}{}

\section{Template instantiations}

% EN: The template name is not a type and cannot be used to declare a variable or call a function. To create a type or a function, the template must be instantiated. Most of the time, templates are instantiated implicitly when they are used. We will again start with function templates.
\Trans{The template name is not a type and cannot be used to declare a variable or call a function. To create a type or a function, the template must be instantiated. Most of the time, templates are instantiated implicitly when they are used. We will again start with function templates.}{}

\subsection{Function templates}

% EN: To use a function template to generate a function, we have to specify which types should be used for all template type parameters. We can just specify the types directly:
\Trans{To use a function template to generate a function, we have to specify which types should be used for all template type parameters. We can just specify the types directly:}{}

\begin{code}
% EN: template <typename T> T half(T x) { return x/2;  }
int i = half<int>(5);
\Trans{template <typename T> T half(T x) { return x/2; } int i = half<int>(5);}{}

\end{code}

% EN: This instantiates the \texttt{half} function template with the \texttt{int} type. The type is explicitly specified; we could call the function with an argument of another type, as long as it is convertible to the type we requested:
\Trans{This instantiates the \texttt{half} function template with the \texttt{int} type. The type is explicitly specified; we could call the function with an argument of another type, as long as it is convertible to the type we requested:}{}

\begin{code}
% EN: double x = half<double>(5);
\Trans{double x = half<double>(5);}{}
\end{code}

% EN: Even though the argument is an \texttt{int}, the instantiation is that of \texttt{half\textless{}double\textgreater{}}, and the return type is \texttt{double}. The integer value \texttt{5} is implicitly converted to \texttt{double}.
\Trans{Even though the argument is an \texttt{int}, the instantiation is that of \texttt{half\textless{}double\textgreater{}}, and the return type is \texttt{double}. The integer value \texttt{5} is implicitly converted to \texttt{double}.}{}

% EN: Even though every function template can be instantiated by specifying all its type parameters, this is rarely done. Most of the uses of function templates involve the automatic deduction of types. Consider the following:
\Trans{Even though every function template can be instantiated by specifying all its type parameters, this is rarely done. Most of the uses of function templates involve the automatic deduction of types. Consider the following:}{}

\begin{code}
% EN: auto x = half(8);    // int
auto y = half(1.5);    // double
\Trans{auto x = half(8); // int auto y = half(1.5); // double}{}

\end{code}

% EN: The template type can be deduced only from the template function arguments---the compiler will attempt to select the type for the \texttt{T} parameter to match the type of the function argument that is declared with the same type. In our case, the function template has the argument \texttt{x} of the \texttt{T} type. Any call to this function has to provide some value for this argument, and this value must have a type. The compiler will deduce that \texttt{T} must be that type. In the first call in the preceding code block, the argument is \texttt{5}, and its type is \texttt{int}. There is nothing better to do than to assume that \texttt{T} should be \texttt{int} in this particular template instantiation. Similarly, in the second call, we can deduce that \texttt{T} must be \texttt{double}.
\Trans{The template type can be deduced only from the template function arguments---the compiler will attempt to select the type for the \texttt{T} parameter to match the type of the function argument that is declared with the same type. In our case, the function template has the argument \texttt{x} of the \texttt{T} type. Any call to this function has to provide some value for this argument, and this value must have a type. The compiler will deduce that \texttt{T} must be that type. In the first call in the preceding code block, the argument is \texttt{5}, and its type is \texttt{int}. There is nothing better to do than to assume that \texttt{T} should be \texttt{int} in this particular template instantiation. Similarly, in the second call, we can deduce that \texttt{T} must be \texttt{double}.}{}

% EN: After this deduction, the compiler performs type substitution: all other mentions of the \texttt{T} type are replaced by the type that was deduced; in our case, there is only one other use of \texttt{T}, which is the return type.
\Trans{After this deduction, the compiler performs type substitution: all other mentions of the \texttt{T} type are replaced by the type that was deduced; in our case, there is only one other use of \texttt{T}, which is the return type.}{}

% EN: Template argument deduction is widely used to capture types that we cannot easily determine:
\Trans{Template argument deduction is widely used to capture types that we cannot easily determine:}{}

\begin{code}
% EN: long x = ...;
unsigned int y = ...;
auto x = half(y + z);
\Trans{long x = ...; unsigned int y = ...; auto x = half(y + z);}{}

\end{code}

% EN: Here, we deduce the \texttt{T} type to be whatever the type of the expression \texttt{y\ +\ z} is (it's \texttt{long}, but with template deduction, we don't need to specify that explicitly, and the deduced type will \emph{follow} the argument type if we ever change the types of \texttt{y} and \texttt{z}). Consider the following example:
\Trans{Here, we deduce the \texttt{T} type to be whatever the type of the expression \texttt{y\ +\ z} is (it's \texttt{long}, but with template deduction, we don't need to specify that explicitly, and the deduced type will \emph{follow} the argument type if we ever change the types of \texttt{y} and \texttt{z}). Consider the following example:}{}

\begin{code}
% EN: template <typename U> auto f(U);
half(f(5));
\Trans{template <typename U> auto f(U); half(f(5));}{}

\end{code}

% EN: We deduce \texttt{T} to match whatever type the \texttt{f()} template function returns for an \texttt{int} argument (of course, the definition of the \texttt{f()} template function has to be provided before it can be called, but we do not need to dig into the header files where \texttt{f()} is defined, as the compiler will deduce the right type for us).
\Trans{We deduce \texttt{T} to match whatever type the \texttt{f()} template function returns for an \texttt{int} argument (of course, the definition of the \texttt{f()} template function has to be provided before it can be called, but we do not need to dig into the header files where \texttt{f()} is defined, as the compiler will deduce the right type for us).}{}

% EN: Only the types that are used to declare function arguments can be deduced. There is no rule that all template type parameters must be somehow present in the argument list, but any parameters that cannot be deduced must be explicitly specified:
\Trans{Only the types that are used to declare function arguments can be deduced. There is no rule that all template type parameters must be somehow present in the argument list, but any parameters that cannot be deduced must be explicitly specified:}{}

\begin{code}
% EN: template <typename U, typename V> U half(V x) {
  return x/2;
\Trans{template <typename U, typename V> U half(V x) { return x/2;}{}

}
% EN: auto y = half<double>(8);
\Trans{auto y = half<double>(8);}{}
\end{code}

% EN: Here, the first template type parameter is explicitly specified, so \texttt{U} is double, and \texttt{V} is deduced to be \texttt{int}.
\Trans{Here, the first template type parameter is explicitly specified, so \texttt{U} is double, and \texttt{V} is deduced to be \texttt{int}.}{}

% EN: Sometimes, the compiler cannot deduce template type parameters, even if they are used to declare arguments:
\Trans{Sometimes, the compiler cannot deduce template type parameters, even if they are used to declare arguments:}{}

\begin{code}
% EN: template <typename T> T Max(T x, T y) {
  return (x > y) ? x : y;
\Trans{template <typename T> T Max(T x, T y) { return (x > y) ? x : y;}{}

}
% EN: auto x = Max(7L, 11); // Error
\Trans{auto x = Max(7L, 11); // Error}{}
\end{code}

% EN: Here, we can deduce from the first argument that \texttt{T} must be \texttt{long}, but from the second argument, we deduce that \texttt{T} must be \texttt{int}. It is often surprising to programmers who learn their way around templates that the \texttt{long} type is not deduced in this case---after all, if we substitute \texttt{long} for \texttt{T} everywhere, the second argument will be implicitly converted, and the function will compile fine. So why isn't the \emph{larger} type deduced? Because the compiler does not attempt to find a type for which all argument conversions are possible: after all, there is usually more than one such type. In our example, \texttt{T} could be \texttt{double} or \texttt{unsigned\ long}, and the function would still be valid. If a type can be deduced from more than one argument, the result of all these deductions must be the same.
\Trans{Here, we can deduce from the first argument that \texttt{T} must be \texttt{long}, but from the second argument, we deduce that \texttt{T} must be \texttt{int}. It is often surprising to programmers who learn their way around templates that the \texttt{long} type is not deduced in this case---after all, if we substitute \texttt{long} for \texttt{T} everywhere, the second argument will be implicitly converted, and the function will compile fine. So why isn't the \emph{larger} type deduced? Because the compiler does not attempt to find a type for which all argument conversions are possible: after all, there is usually more than one such type. In our example, \texttt{T} could be \texttt{double} or \texttt{unsigned\ long}, and the function would still be valid. If a type can be deduced from more than one argument, the result of all these deductions must be the same.}{}

% EN: Otherwise, the template instantiation is considered ambiguous.
\Trans{Otherwise, the template instantiation is considered ambiguous.}{}

% EN: The type deduction is not always as straightforward as using the type of the argument for a type parameter. The argument may be declared with a type that's more complex than a type parameter itself:
\Trans{The type deduction is not always as straightforward as using the type of the argument for a type parameter. The argument may be declared with a type that's more complex than a type parameter itself:}{}

\begin{code}
% EN: template <typename T> T decrement(T* p) {
  return --(*p);
\Trans{template <typename T> T decrement(T* p) { return --(*p);}{}

}
% EN: int i = 7;
decrement(&i);    // i == 6
\Trans{int i = 7; decrement(&i); // i == 6}{}

\end{code}

% EN: Here, the type of the argument is a \emph{pointer to} \texttt{int}, but the type that is deduced for \texttt{T} is \texttt{int}. The deduction of types can be arbitrarily complex, as long as it's unambiguous:
\Trans{Here, the type of the argument is a \emph{pointer to} \texttt{int}, but the type that is deduced for \texttt{T} is \texttt{int}. The deduction of types can be arbitrarily complex, as long as it's unambiguous:}{}

\begin{code}
% EN: template <typename T> T first(const std::vector<T>& v) {
  return v[0];
\Trans{template <typename T> T first(const std::vector<T>& v) { return v[0];}{}

}
% EN: std::vector<int> v{11, 25, 67 };
first(v);    // T is int, returns 11
\Trans{std::vector<int> v{11, 25, 67}; first(v); // T is int, returns 11}{}

\end{code}

% EN: Here, the argument is an instantiation of another template, \texttt{std::vector}, and we have to deduce the template parameter type from the type that was used to create this vector instantiation.
\Trans{Here, the argument is an instantiation of another template, \texttt{std::vector}, and we have to deduce the template parameter type from the type that was used to create this vector instantiation.}{}

% EN: As we have seen, if a type can be deduced from more than one function argument, the result of these deductions must be the same. On the other hand, one argument can be used to deduce more than one type:
\Trans{As we have seen, if a type can be deduced from more than one function argument, the result of these deductions must be the same. On the other hand, one argument can be used to deduce more than one type:}{}

\begin{code}
% EN: template <typename U, typename V>
std::pair<V, U> swap12(const std::pair<U, V>& x) {
  return std::pair<V, U>(x.second, x.first);
\Trans{template <typename U, typename V> std::pair<V, U> swap12(const std::pair<U, V>& x) { return std::pair<V, U>(x.second, x.first);}{}

}
% EN: swap12(std::make_pair(7, 4.2)); // pair of 4.2, 7
\Trans{swap12(std::make_pair(7, 4.2)); // pair of 4.2, 7}{}
\end{code}

% EN: Here, we deduce two types, \texttt{U} and \texttt{V}, from one argument, then use these two types to form a new type, \texttt{std::pair\textless{}V,\ U\textgreater{}}. This example is unnecessarily verbose, and we can take advantage of a few more C++ features to make it both more compact and easier to maintain. First of all, the standard already has a function that deduces the argument types and uses them to declare a pair, and we have even used this function---\texttt{std::make\_pair()}.
\Trans{Here, we deduce two types, \texttt{U} and \texttt{V}, from one argument, then use these two types to form a new type, \texttt{std::pair\textless{}V,\ U\textgreater{}}. This example is unnecessarily verbose, and we can take advantage of a few more C++ features to make it both more compact and easier to maintain. First of all, the standard already has a function that deduces the argument types and uses them to declare a pair, and we have even used this function---\texttt{std::make\_pair()}.}{}

% EN: Secondly, the return type of the function can be deduced from the expression in the \texttt{return} statement (a C++14 feature). The rules of this deduction are similar to the rules of the template argument type deduction. With these simplifications, our example becomes the following:
\Trans{Secondly, the return type of the function can be deduced from the expression in the \texttt{return} statement (a C++14 feature). The rules of this deduction are similar to the rules of the template argument type deduction. With these simplifications, our example becomes the following:}{}

\begin{code}
% EN: template <typename U, typename V>
auto swap12(const std::pair<U, V>& x) {
  return std::make_pair(x.second, x.first);
\Trans{template <typename U, typename V> auto swap12(const std::pair<U, V>& x) { return std::make_pair(x.second, x.first);}{}

}
\end{code}

% EN: Note that we don't explicitly use the types \texttt{U} and \texttt{V} anymore. We still need this function to be a template, since it operates on a generic type, that is, a pair of two types that we don't know until we instantiate the function. We could, however, use only one template parameter that would stand for the type of the argument:
\Trans{Note that we don't explicitly use the types \texttt{U} and \texttt{V} anymore. We still need this function to be a template, since it operates on a generic type, that is, a pair of two types that we don't know until we instantiate the function. We could, however, use only one template parameter that would stand for the type of the argument:}{}

\begin{code}
% EN: template <typename T> auto swap12(const T& x) {
  return std::make_pair(x.second, x.first);
\Trans{template <typename T> auto swap12(const T& x) { return std::make_pair(x.second, x.first);}{}

}
\end{code}

% EN: There is a significant difference between these two variants---the last function template will have its type deduced successfully from any call with one argument, no matter the type of that argument. If that argument is not \texttt{std::pair}, or, more generally, if the argument is not a class or a struct or it does not have the \texttt{first} and \texttt{second} data members, the deduction will still succeed, but the type substitution will fail. On the other hand, the previous version will not even be considered for arguments that are not a pair of some types. For any \texttt{std::pair} argument, the pair types are deduced, and the substitution should proceed without a problem. Can we use the last declaration and still restrict the type \texttt{T} to be a pair or another class with a similar interface? Yes, and we will see several ways to do so later in this book.
\Trans{There is a significant difference between these two variants---the last function template will have its type deduced successfully from any call with one argument, no matter the type of that argument. If that argument is not \texttt{std::pair}, or, more generally, if the argument is not a class or a struct or it does not have the \texttt{first} and \texttt{second} data members, the deduction will still succeed, but the type substitution will fail. On the other hand, the previous version will not even be considered for arguments that are not a pair of some types. For any \texttt{std::pair} argument, the pair types are deduced, and the substitution should proceed without a problem. Can we use the last declaration and still restrict the type \texttt{T} to be a pair or another class with a similar interface? Yes, and we will see several ways to do so later in this book.}{}

% EN: Member function templates are very similar to non-member function templates, and their arguments are similarly deduced. Member function templates can be used in classes or class templates, which we will review next.
\Trans{Member function templates are very similar to non-member function templates, and their arguments are similarly deduced. Member function templates can be used in classes or class templates, which we will review next.}{}

\subsection{Class templates}

% EN: Instantiation of class templates is similar to that of function templates---the use of a template to create a type implicitly instantiates the template. To use a class template, we need to specify the type arguments for the template parameters:
\Trans{Instantiation of class templates is similar to that of function templates---the use of a template to create a type implicitly instantiates the template. To use a class template, we need to specify the type arguments for the template parameters:}{}

\begin{code}
% EN: template <typename N, typename D> class Ratio {
  public:
  Ratio() : num_(), denom_() { }
  Ratio(const N& num, const D& denom) :
    num_(num), denom_(denom) { }
  explicit operator double() const {
    return double(num_)/double(denom_);
   }
  private:
  N num_;
  D denom_;
 };
Ratio<int, double> r;
\Trans{template <typename N, typename D> class Ratio { public: Ratio() : num_(), denom_() {} Ratio(const N& num, const D& denom) : num_(num), denom_(denom) {} explicit operator double() const { return double(num_)/double(denom_); } private: N num_; D denom_; }; Ratio<int, double> r;}{}

\end{code}

% EN: The definition of the \texttt{r} variable implicitly instantiates the \texttt{Ratio} class template for the \texttt{int} and \texttt{double} types. It also instantiates the default constructor of this class. The second constructor is not used in this code and is not instantiated. It is this feature of class templates---instantiating a template instantiates all data members, but does not instantiate the methods until they are used---that allows us to write class templates where only some of the methods compile for certain types. If we use the second constructor to initialize the values of \texttt{Ratio}, then that constructor is instantiated, and must be valid for the given types:
\Trans{The definition of the \texttt{r} variable implicitly instantiates the \texttt{Ratio} class template for the \texttt{int} and \texttt{double} types. It also instantiates the default constructor of this class. The second constructor is not used in this code and is not instantiated. It is this feature of class templates---instantiating a template instantiates all data members, but does not instantiate the methods until they are used---that allows us to write class templates where only some of the methods compile for certain types. If we use the second constructor to initialize the values of \texttt{Ratio}, then that constructor is instantiated, and must be valid for the given types:}{}

\begin{code}
% EN: Ratio<int, double> r(5, 0.1);
\Trans{Ratio<int, double> r(5, 0.1);}{}
\end{code}

% EN: In C++17, these constructors can be used to deduce the types of the class template from the constructor arguments:
\Trans{In C++17, these constructors can be used to deduce the types of the class template from the constructor arguments:}{}

\begin{code}
% EN: Ratio r(5, 0.1);
\Trans{Ratio r(5, 0.1);}{}
\end{code}

% EN: Of course, this works only if there are enough constructor arguments to deduce the types. For example, the default-constructed \texttt{Ratio} object has to be instantiated with explicitly specified types; there is simply no other way to deduce them. Prior to C++17, a helper function template was often used to construct an object whose type can be deduced from the arguments. Similarly to \texttt{std::make\_pair()}, which we looked at previously, we can implement a \texttt{make\_ratio} function that will do the same thing as the C++17 constructor argument deduction:
\Trans{Of course, this works only if there are enough constructor arguments to deduce the types. For example, the default-constructed \texttt{Ratio} object has to be instantiated with explicitly specified types; there is simply no other way to deduce them. Prior to C++17, a helper function template was often used to construct an object whose type can be deduced from the arguments. Similarly to \texttt{std::make\_pair()}, which we looked at previously, we can implement a \texttt{make\_ratio} function that will do the same thing as the C++17 constructor argument deduction:}{}

\begin{code}
% EN: template <typename N, typename D>
Ratio<N, D> make_ratio(const N& num, const D& denom) {
  return { num, denom  };
\Trans{template <typename N, typename D> Ratio<N, D> make_ratio(const N& num, const D& denom) { return { num, denom };}{}

}
% EN: auto r(make_ratio(5, 0.1));
\Trans{auto r(make_ratio(5, 0.1));}{}
\end{code}

% EN: The C++17 way of deducing template arguments should be preferred, if it is available: it does not require writing another function that essentially duplicates the class constructor, and does not make an additional call to the copy or move constructor to initialize the object (although in practice most compilers will perform return value optimization and optimize away the call to the copy or move constructor).
\Trans{The C++17 way of deducing template arguments should be preferred, if it is available: it does not require writing another function that essentially duplicates the class constructor, and does not make an additional call to the copy or move constructor to initialize the object (although in practice most compilers will perform return value optimization and optimize away the call to the copy or move constructor).}{}

% EN: When a template is used to generate a type, it is instantiated implicitly. Both class and function templates can be explicitly instantiated as well. Doing so instantiates a template without using it:
\Trans{When a template is used to generate a type, it is instantiated implicitly. Both class and function templates can be explicitly instantiated as well. Doing so instantiates a template without using it:}{}

\begin{code}
% EN: template class Ratio<long, long>;
template Ratio<long, long> make_ratio(const long&,
                                      const long&);
\Trans{template class Ratio<long, long>; template Ratio<long, long> make_ratio(const long&, const long&);}{}

\end{code}

% EN: Explicit instantiations are rarely needed, and will not be used elsewhere in this book.
\Trans{Explicit instantiations are rarely needed, and will not be used elsewhere in this book.}{}

% EN: While instantiations of class templates with specific template parameters behave (mostly) like regular classes, static data members of class templates deserve special mention. First, let us recall the common challenge of static class data members: they must be defined somewhere, and only once:
\Trans{While instantiations of class templates with specific template parameters behave (mostly) like regular classes, static data members of class templates deserve special mention. First, let us recall the common challenge of static class data members: they must be defined somewhere, and only once:}{}

\begin{code}
% EN: // In the header:
class A {
  static int n;
 };
// In a C file:
int A::n = 0;
std::cout << A::n;
\Trans{// In the header: class A { static int n; }; // In a C file: int A::n = 0; std::cout << A::n;}{}

\end{code}

% EN: Without such a definition, the program will not link: the name \texttt{A::n} is not defined. But if the definition is moved into the header and the header is included in several compilation units, the program also will not link, this time the name \texttt{A::n} is multiply defined.
\Trans{Without such a definition, the program will not link: the name \texttt{A::n} is not defined. But if the definition is moved into the header and the header is included in several compilation units, the program also will not link, this time the name \texttt{A::n} is multiply defined.}{}

% EN: The requirement to define static data members exactly once is not feasible for class templates: we need them defined for every set of template parameters the template is instantiated with, and we can't do that in any one compilation unit (other compilation units may instantiate the same template with different types). Fortunately, this is not necessary. Static members of class templates can (and should) be defined together with the template itself:
\Trans{The requirement to define static data members exactly once is not feasible for class templates: we need them defined for every set of template parameters the template is instantiated with, and we can't do that in any one compilation unit (other compilation units may instantiate the same template with different types). Fortunately, this is not necessary. Static members of class templates can (and should) be defined together with the template itself:}{}

\begin{code}
% EN: // In the header:
template <typename T> class A {
  static T n;
 };
template <typename T> T A<T>::n { };
\Trans{// In the header: template <typename T> class A { static T n; }; template <typename T> T A<T>::n {};}{}

\end{code}

% EN: While this technically results in multiple definitions, it is the job of the linker to consolidate them so we are left with a single definition (there is only one value of a static member variable for all objects of the same type).
\Trans{While this technically results in multiple definitions, it is the job of the linker to consolidate them so we are left with a single definition (there is only one value of a static member variable for all objects of the same type).}{}

% EN: In C++17, inline variables offer a simpler solution:
\Trans{In C++17, inline variables offer a simpler solution:}{}

\begin{code}
% EN: // In the header:
template <typename T> class A {
  static inline T n { };
 };
\Trans{// In the header: template <typename T> class A { static inline T n {}; };}{}

\end{code}

% EN: This also works for non-template classes:
\Trans{This also works for non-template classes:}{}

\begin{code}
% EN: // In the header:
class A {
  static inline int n = 0;
 };
\Trans{// In the header: class A { static inline int n = 0; };}{}

\end{code}

% EN: If the static data member of a class template has a non-trivial constructor, this constructor is invoked once for every instantiation of this template (not for every object -- there is only one instance of a static member variable for all objects of the same type).
\Trans{If the static data member of a class template has a non-trivial constructor, this constructor is invoked once for every instantiation of this template (not for every object -- there is only one instance of a static member variable for all objects of the same type).}{}

% EN: Class templates, as we have used them so far, allow us to declare generic classes, that is, classes that can be instantiated with many different types. So far, all of these classes look exactly the same, except for the types, and generate the same code. This is not always desirable---different types may need to be handled somewhat differently.
\Trans{Class templates, as we have used them so far, allow us to declare generic classes, that is, classes that can be instantiated with many different types. So far, all of these classes look exactly the same, except for the types, and generate the same code. This is not always desirable---different types may need to be handled somewhat differently.}{}

% EN: For example, let's say that we want to be able to represent not only a ratio of two numbers stored in the \texttt{Ratio} object but also a ratio of two numbers stored elsewhere, with the \texttt{Ratio} object containing pointers to these numbers. Clearly, some of the methods of the \texttt{Ratio} object, such as the conversion operator to \texttt{double}, need to be implemented differently if the object stores pointers to the numerator and denominator. In C++, this is accomplished by specializing the template, which we will do next.
\Trans{For example, let's say that we want to be able to represent not only a ratio of two numbers stored in the \texttt{Ratio} object but also a ratio of two numbers stored elsewhere, with the \texttt{Ratio} object containing pointers to these numbers. Clearly, some of the methods of the \texttt{Ratio} object, such as the conversion operator to \texttt{double}, need to be implemented differently if the object stores pointers to the numerator and denominator. In C++, this is accomplished by specializing the template, which we will do next.}{}

\section{Template specializations}

% EN: Template specializations allow us to make the generated template code differently for some types---not just the same code with different types substituted, but completely different code. There are two kinds of template specializations in C++---explicit, or full, specializations and partial specialization. Let's start with the former.
\Trans{Template specializations allow us to make the generated template code differently for some types---not just the same code with different types substituted, but completely different code. There are two kinds of template specializations in C++---explicit, or full, specializations and partial specialization. Let's start with the former.}{}

\subsection{Explicit specialization}

% EN: Explicit template specialization defines a special version of the template for a particular set of types. In an explicit specialization, all generic types are replaced by specific, concrete types. Since an explicit specialization is not a generic class or function, it does not need to be instantiated later. For the same reason, it is sometimes called \textbf{full specialization}. If the generic types are fully substituted, there is nothing generic left. An explicit specialization should not be confused with an explicit template instantiation---while both create an instantiation of a template for a given set of type arguments, an explicit instantiation creates an instantiation of the generic code, with the generic types substituted by the specific types. An explicit specialization creates an instantiation of the function or class with the same name but it overrides the implementation, so the resulting code can be completely different. An example should help us understand this distinction.
\Trans{Explicit template specialization defines a special version of the template for a particular set of types. In an explicit specialization, all generic types are replaced by specific, concrete types. Since an explicit specialization is not a generic class or function, it does not need to be instantiated later. For the same reason, it is sometimes called \textbf{full specialization}. If the generic types are fully substituted, there is nothing generic left. An explicit specialization should not be confused with an explicit template instantiation---while both create an instantiation of a template for a given set of type arguments, an explicit instantiation creates an instantiation of the generic code, with the generic types substituted by the specific types. An explicit specialization creates an instantiation of the function or class with the same name but it overrides the implementation, so the resulting code can be completely different. An example should help us understand this distinction.}{}

% EN: Let's start with a class template. Let's say that, if both the numerator and the denominator of \texttt{Ratio} are \texttt{double}, we want to compute the ratio and store it as a single number. The generic \texttt{Ratio} code should remain the same, but for one particular set of types, we want the class to look entirely different. We can do this with an explicit specialization:
\Trans{Let's start with a class template. Let's say that, if both the numerator and the denominator of \texttt{Ratio} are \texttt{double}, we want to compute the ratio and store it as a single number. The generic \texttt{Ratio} code should remain the same, but for one particular set of types, we want the class to look entirely different. We can do this with an explicit specialization:}{}

\begin{code}
% EN: template <> class Ratio<double, double> {
  public:
  Ratio() : value_() { }
  template <typename N, typename D>
    Ratio(const N& num, const D& denom) :
      value_(double(num)/double(denom)) { }
  explicit operator double() const { return value_;  }
  private:
  double value_;
 };
\Trans{template <> class Ratio<double, double> { public: Ratio() : value_() {} template <typename N, typename D> Ratio(const N& num, const D& denom) : value_(double(num)/double(denom)) {} explicit operator double() const { return value_; } private: double value_; };}{}

\end{code}

% EN: Both template type parameters are specified to be \texttt{double}. The class implementation is totally unlike the generic version---instead of two data members, we have just one; the conversion operator simply returns the value, and the constructor now computes the ratio of the numerator and the denominator. But it is not even the same constructor---instead of the non-template constructor \texttt{Ratio(const\ double\&,\ const\ double\&)} that the generic version would have if it was instantiated for two \texttt{double} template arguments, we provided a template constructor that can take two arguments of any types as long as they are convertible to \texttt{double}.
\Trans{Both template type parameters are specified to be \texttt{double}. The class implementation is totally unlike the generic version---instead of two data members, we have just one; the conversion operator simply returns the value, and the constructor now computes the ratio of the numerator and the denominator. But it is not even the same constructor---instead of the non-template constructor \texttt{Ratio(const\ double\&,\ const\ double\&)} that the generic version would have if it was instantiated for two \texttt{double} template arguments, we provided a template constructor that can take two arguments of any types as long as they are convertible to \texttt{double}.}{}

% EN: Sometimes, we don't need to specialize the whole class template, because most of the generic code is still applicable. However, we may want to change the implementation of one or a few member functions. We can explicitly specialize the member function as well:
\Trans{Sometimes, we don't need to specialize the whole class template, because most of the generic code is still applicable. However, we may want to change the implementation of one or a few member functions. We can explicitly specialize the member function as well:}{}

\begin{code}
% EN: template <> Ratio<float, float>::operator double() const {
  return num_/denom_;
\Trans{template <> Ratio<float, float>::operator double() const { return num_/denom_;}{}

}
\end{code}

% EN: Template functions can be explicitly specialized as well. Again, unlike an explicit instantiation, we get to write the body of the function, and we can implement it any way we want:
\Trans{Template functions can be explicitly specialized as well. Again, unlike an explicit instantiation, we get to write the body of the function, and we can implement it any way we want:}{}

\begin{code}
% EN: template <typename T> T do_something(T x) {
  return ++x;
\Trans{template <typename T> T do_something(T x) { return ++x;}{}

}
% EN: template <> double do_something<double>(double x) {
  return x/2;
\Trans{template <> double do_something<double>(double x) { return x/2;}{}

}
% EN: do_something(3);        // 4
do_something(3.0);    // 1.5
\Trans{do_something(3); // 4 do_something(3.0); // 1.5}{}

\end{code}

% EN: We cannot, however, change the number or the types of arguments or the return type---they must match the result of the substitution of the generic types, so the following does not compile:
\Trans{We cannot, however, change the number or the types of arguments or the return type---they must match the result of the substitution of the generic types, so the following does not compile:}{}

\begin{code}
% EN: template <> long do_something<int>(int x) { return x*x; }
\Trans{template <> long do_something<int>(int x) { return x*x; }}{}
\end{code}

% EN: An explicit specialization must be declared before the first use of the template that would cause an implicit instantiation of the generic template for the same types. This makes sense---the implicit instantiation would create a class or a function with the same name and the same types as the explicit specialization. We would now have two versions of the same class or function in the program, and this violates the one definition rule and makes the program ill-formed (the exact rules can be found in the standard under \emph{{[}basic.def.odr{]}}).
\Trans{An explicit specialization must be declared before the first use of the template that would cause an implicit instantiation of the generic template for the same types. This makes sense---the implicit instantiation would create a class or a function with the same name and the same types as the explicit specialization. We would now have two versions of the same class or function in the program, and this violates the one definition rule and makes the program ill-formed (the exact rules can be found in the standard under \emph{{[}basic.def.odr{]}}).}{}

% EN: Explicit specializations are useful when we have one or a few types for which we need the template to behave very differently. However, this does not solve our problem with the ratio of pointers---we want a specialization that is still \emph{somewhat generic}, that is, it can handle pointers to any types, just not any other types. This is accomplished by a partial specialization, which we will look at next.
\Trans{Explicit specializations are useful when we have one or a few types for which we need the template to behave very differently. However, this does not solve our problem with the ratio of pointers---we want a specialization that is still \emph{somewhat generic}, that is, it can handle pointers to any types, just not any other types. This is accomplished by a partial specialization, which we will look at next.}{}

\subsection{Partial specialization}

% EN: Now, we are getting to the really interesting part of C++ template programming---partial template specializations. When a class template is partially specialized, it remains as generic code, but \emph{less generic} than the original template. The simplest form of a partial template is one where some of the generic types are replaced by concrete types, but other types remain generic:
\Trans{Now, we are getting to the really interesting part of C++ template programming---partial template specializations. When a class template is partially specialized, it remains as generic code, but \emph{less generic} than the original template. The simplest form of a partial template is one where some of the generic types are replaced by concrete types, but other types remain generic:}{}

\begin{code}
% EN: template <typename N, typename D> class Ratio {
  .....
 };
template <typename D> class Ratio<double, D> {
  public:
  Ratio() : value_() { }
  Ratio(const double& num, const D& denom) :
    value_(num/double(denom)) { }
  explicit operator double() const { return value_;  }
  private:
  double value_;
 };
\Trans{template <typename N, typename D> class Ratio { ..... }; template <typename D> class Ratio<double, D> { public: Ratio() : value_() {} Ratio(const double& num, const D& denom) : value_(num/double(denom)) {} explicit operator double() const { return value_; } private: double value_; };}{}

\end{code}

% EN: Here, we convert \texttt{Ratio} to a \texttt{double} value if the numerator is \texttt{double}, regardless of the denominator type. More than one partial specialization can be defined for the same template. For example, we can also specialize for the case when the denominator is \texttt{double} and the numerator is anything:
\Trans{Here, we convert \texttt{Ratio} to a \texttt{double} value if the numerator is \texttt{double}, regardless of the denominator type. More than one partial specialization can be defined for the same template. For example, we can also specialize for the case when the denominator is \texttt{double} and the numerator is anything:}{}

\begin{code}
% EN: template <typename N> class Ratio<N, double> {
  public:
  Ratio() : value_() { }
  Ratio(const N& num, const double& denom) :
    value_(double(num)/denom) { }
  explicit operator double() const { return value_;  }
  private:
  double value_;
 };
\Trans{template <typename N> class Ratio<N, double> { public: Ratio() : value_() {} Ratio(const N& num, const double& denom) : value_(double(num)/denom) {} explicit operator double() const { return value_; } private: double value_; };}{}

\end{code}

% EN: When the template is instantiated, the best specialization for the given set of types is selected. In our case, if neither the numerator nor the denominator is \texttt{double}, then the general template has to be instantiated---there are no other choices. If the numerator is \texttt{double}, then the first partial specialization is a better (more specific) match than the general template. If the denominator is \texttt{double}, then the second partial specialization is a better match. But what happens if both terms are \texttt{double}? In this case, the two partial specializations are equivalent; neither is more specific than the other. This situation is considered ambiguous and the instantiation fails. Note that only this particular instantiation, \texttt{Ratio\textless{}double,\ double\textgreater{}}, fails---it is not an error (at least, not a syntax error) to define both specializations, but it is an error to request an instantiation that cannot be uniquely resolved to the narrowest specialization. To allow any instantiation of our template, we have to remove this ambiguity, and the only way to do that is to provide an even more narrow specialization that would be preferred over the other two. In our case, there is only one option---a full specialization for \texttt{Ratio\textless{}double,\ double\textgreater{}}:
\Trans{When the template is instantiated, the best specialization for the given set of types is selected. In our case, if neither the numerator nor the denominator is \texttt{double}, then the general template has to be instantiated---there are no other choices. If the numerator is \texttt{double}, then the first partial specialization is a better (more specific) match than the general template. If the denominator is \texttt{double}, then the second partial specialization is a better match. But what happens if both terms are \texttt{double}? In this case, the two partial specializations are equivalent; neither is more specific than the other. This situation is considered ambiguous and the instantiation fails. Note that only this particular instantiation, \texttt{Ratio\textless{}double,\ double\textgreater{}}, fails---it is not an error (at least, not a syntax error) to define both specializations, but it is an error to request an instantiation that cannot be uniquely resolved to the narrowest specialization. To allow any instantiation of our template, we have to remove this ambiguity, and the only way to do that is to provide an even more narrow specialization that would be preferred over the other two. In our case, there is only one option---a full specialization for \texttt{Ratio\textless{}double,\ double\textgreater{}}:}{}

\begin{code}
% EN: template <> class Ratio<double, double> {
  public:
  Ratio() : value_() { }
  template <typename N, typename D>
    Ratio(const N& num, const D& denom) :
      value_(double(num)/double(denom)) { }
  explicit operator double() const { return value_;  }
  private:
  double value_;
 };
\Trans{template <> class Ratio<double, double> { public: Ratio() : value_() {} template <typename N, typename D> Ratio(const N& num, const D& denom) : value_(double(num)/double(denom)) {} explicit operator double() const { return value_; } private: double value_; };}{}

\end{code}

% EN: Now, the fact that the partial specializations are ambiguous for the instantiation of \texttt{Ratio\textless{}double,\ double\textgreater{}} is no longer relevant---we have a more specific version of the template than either of them, so that version is preferred over both.
\Trans{Now, the fact that the partial specializations are ambiguous for the instantiation of \texttt{Ratio\textless{}double,\ double\textgreater{}} is no longer relevant---we have a more specific version of the template than either of them, so that version is preferred over both.}{}

% EN: Partial specializations do not have to specify some of the generic types fully. Therefore, can keep all types generic, but impose some restrictions on them. For example, we still want a specialization where both the numerator and the denominator are pointers. They can be pointers to anything, so they are generic types, but \emph{less generic} than the arbitrary types of the general template:
\Trans{Partial specializations do not have to specify some of the generic types fully. Therefore, can keep all types generic, but impose some restrictions on them. For example, we still want a specialization where both the numerator and the denominator are pointers. They can be pointers to anything, so they are generic types, but \emph{less generic} than the arbitrary types of the general template:}{}

\begin{code}
% EN: template <typename N, typename D> class Ratio<N*, D*> {
  public:
  Ratio(N* num, D* denom) : num_(num), denom_(denom) { }
  explicit operator double() const {
    return double(*num_)/double(*denom_);
   }
  private:
  N* const num_;
  D* const denom_;
 };
int i = 5; double x = 10;
auto r(make_ratio(&i, &x));        // Ratio<int*, double*>
double(r);                    // 0.5
x = 2.5;
double(r);                    // 2
\Trans{template <typename N, typename D> class Ratio<N*, D*> { public: Ratio(N* num, D* denom) : num_(num), denom_(denom) {} explicit operator double() const { return double(*num_)/double(*denom_); } private: N* const num_; D* const denom_; }; int i = 5; double x = 10; auto r(make_ratio(&i, &x)); // Ratio<int*, double*> double(r); // 0.5 x = 2.5; double(r); // 2}{}

\end{code}

% EN: This partial specialization still has two generic types, but they are both pointer types, \texttt{N*} and \texttt{D*}, for any \texttt{N} and \texttt{D} types. The implementation is totally unlike that of the general template. When instantiated with two pointer types, the partial specialization is \emph{more specific} than the general template and is considered a better match. Note that, in our example, the denominator is \texttt{double}. So why isn't a partial specialization for the \texttt{double} denominator considered? That is because, while the denominator is \texttt{double} as far as the program logic is concerned, technically it is \texttt{double*}, a completely different type, and we do not have a specialization for that.
\Trans{This partial specialization still has two generic types, but they are both pointer types, \texttt{N*} and \texttt{D*}, for any \texttt{N} and \texttt{D} types. The implementation is totally unlike that of the general template. When instantiated with two pointer types, the partial specialization is \emph{more specific} than the general template and is considered a better match. Note that, in our example, the denominator is \texttt{double}. So why isn't a partial specialization for the \texttt{double} denominator considered? That is because, while the denominator is \texttt{double} as far as the program logic is concerned, technically it is \texttt{double*}, a completely different type, and we do not have a specialization for that.}{}

% EN: To define a specialization, a general template must first be declared. It does not, however, need to be defined---it is possible to specialize a template that does not exist in the general case. To do so, we must forward-declare the general template, then define all the specializations we need:
\Trans{To define a specialization, a general template must first be declared. It does not, however, need to be defined---it is possible to specialize a template that does not exist in the general case. To do so, we must forward-declare the general template, then define all the specializations we need:}{}

\begin{code}
% EN: template <typename T> class Value; // Declaration 
template <typename T> class Value<T*> {
  public:
  explicit Value(T* p) : v_(*p) { } private:
  T v_;
 };
template <typename T> class Value<T&> {
  public:
  explicit Value(T& p) : v_(p) { }
  private:
  T v_;
 };
int i = 5; int* p = &i; int& r = i;
Value<int*> v1(p); // T* specialization
Value<int&> v2(r); // T& specialization
\Trans{template <typename T> class Value; // Declaration template <typename T> class Value<T*> { public: explicit Value(T* p) : v_(*p) {} private: T v_; }; template <typename T> class Value<T&> { public: explicit Value(T& p) : v_(p) {} private: T v_; }; int i = 5; int* p = &i; int& r = i; Value<int*> v1(p); // T* specialization Value<int&> v2(r); // T& specialization}{}

\end{code}

% EN: Here, we have no general \texttt{Value} template, but we have partial specializations for any pointer or reference types. If we try to instantiate the template on some other type, like \texttt{int}, we will get an error stating that the \texttt{Value\textless{}int\textgreater{}} type is incomplete---this is no different than trying to define an object with only a forward declaration of the class.
\Trans{Here, we have no general \texttt{Value} template, but we have partial specializations for any pointer or reference types. If we try to instantiate the template on some other type, like \texttt{int}, we will get an error stating that the \texttt{Value\textless{}int\textgreater{}} type is incomplete---this is no different than trying to define an object with only a forward declaration of the class.}{}

% EN: So far, we have seen only examples of partial specializations for class templates. Unlike the earlier discussion of full specializations, we have not seen a single function specialization here. There is a very good reason for that---a partial function template specialization does not exist in C++. What is sometimes incorrectly called a partial specialization is nothing more than overloading template functions. On the other hand, overloading template functions can get quite complex and is worth learning about---we will cover this next.
\Trans{So far, we have seen only examples of partial specializations for class templates. Unlike the earlier discussion of full specializations, we have not seen a single function specialization here. There is a very good reason for that---a partial function template specialization does not exist in C++. What is sometimes incorrectly called a partial specialization is nothing more than overloading template functions. On the other hand, overloading template functions can get quite complex and is worth learning about---we will cover this next.}{}

\subsection{Template function overloading}

% EN: We are used to regular functions, or class methods, being overloaded---multiple functions with the same name have different parameter types. Each call invokes the function with the best match of the parameter types to the call arguments, as shown in the following example:
\Trans{We are used to regular functions, or class methods, being overloaded---multiple functions with the same name have different parameter types. Each call invokes the function with the best match of the parameter types to the call arguments, as shown in the following example:}{}

\begin{code}
% EN: // Example 07
void whatami(int x) {
  std::cout << x << " is int" << std::endl;
\Trans{// Example 07 void whatami(int x) { std::cout << x << " is int" << std::endl;}{}

}
% EN: void whatami(long x) {
  std::cout << x << " is long" << std::endl;
\Trans{void whatami(long x) { std::cout << x << " is long" << std::endl;}{}

}
% EN: whatami(5);    // 5 is int
whatami(5.0);    // Compilation error
\Trans{whatami(5); // 5 is int whatami(5.0); // Compilation error}{}

\end{code}

% EN: If the arguments are a perfect match for one of the overloaded functions with the given name, that function is called. Otherwise, the compiler considers conversions to the parameter types of the available functions. If one of the functions offers \emph{better} conversions, that function is selected. Otherwise, the call is ambiguous, just as in the last line of the preceding example. The precise definition of what constitutes the \emph{best} conversion can be found in the standard (see the section \emph{Overloading}, more specifically, subsection \emph{{[}over.match{]}}). Generally, the \emph{cheapest} conversions are the ones such as adding \texttt{const} or removing a reference; then, there are conversions between built-in types, conversions from derived to base class pointers, and so on. In the case of multiple arguments, each argument for the chosen function must have the best conversion. There is no \emph{voting}---if a function has three arguments, and two are an exact match for the first overload, while the third one is an exact match for the second overload, then even if the remaining arguments are implicitly convertible to their corresponding parameter types, the overloaded call is ambiguous.
\Trans{If the arguments are a perfect match for one of the overloaded functions with the given name, that function is called. Otherwise, the compiler considers conversions to the parameter types of the available functions. If one of the functions offers \emph{better} conversions, that function is selected. Otherwise, the call is ambiguous, just as in the last line of the preceding example. The precise definition of what constitutes the \emph{best} conversion can be found in the standard (see the section \emph{Overloading}, more specifically, subsection \emph{{[}over.match{]}}). Generally, the \emph{cheapest} conversions are the ones such as adding \texttt{const} or removing a reference; then, there are conversions between built-in types, conversions from derived to base class pointers, and so on. In the case of multiple arguments, each argument for the chosen function must have the best conversion. There is no \emph{voting}---if a function has three arguments, and two are an exact match for the first overload, while the third one is an exact match for the second overload, then even if the remaining arguments are implicitly convertible to their corresponding parameter types, the overloaded call is ambiguous.}{}

% EN: The presence of templates makes the overload resolution much more complex. Multiple function templates with the same name and, possibly, the same number of arguments, can be defined, in addition to non-template functions. All of these functions are the candidates for an overloaded function call, but the function templates can generate functions with different parameter types, so how do we decide what the actual overloaded functions are? The exact rules are even more complex than the ones for non-template functions, but the basic idea is this---if there is a non-template function that is a near-perfect match to the call arguments, that function is selected. The standard, of course, uses much more precise terms than \emph{near-perfect}, but \emph{trivial} conversions, such as adding \texttt{const}, fall under that category---you get them \emph{at no cost}. If there is no such function, the compiler will attempt to instantiate all function templates with the same name to a near-perfect match, using the template argument deduction. If exactly one of the templates was instantiated, the function created by this instantiation is called. Otherwise, overload resolution continues the usual way among the non-template functions.
\Trans{The presence of templates makes the overload resolution much more complex. Multiple function templates with the same name and, possibly, the same number of arguments, can be defined, in addition to non-template functions. All of these functions are the candidates for an overloaded function call, but the function templates can generate functions with different parameter types, so how do we decide what the actual overloaded functions are? The exact rules are even more complex than the ones for non-template functions, but the basic idea is this---if there is a non-template function that is a near-perfect match to the call arguments, that function is selected. The standard, of course, uses much more precise terms than \emph{near-perfect}, but \emph{trivial} conversions, such as adding \texttt{const}, fall under that category---you get them \emph{at no cost}. If there is no such function, the compiler will attempt to instantiate all function templates with the same name to a near-perfect match, using the template argument deduction. If exactly one of the templates was instantiated, the function created by this instantiation is called. Otherwise, overload resolution continues the usual way among the non-template functions.}{}

% EN: This is a very simplified description of a very complex process, but there are two important points---firstly, if there is an equally good match of a call to a template and a non-template function, the non-template function is preferred, and secondly, the compiler does not attempt to instantiate the function templates into something that might be convertible to the types we need. The template functions must match the call almost perfectly after the argument type deduction, or they are not called at all. Let's add a template to our previous example:
\Trans{This is a very simplified description of a very complex process, but there are two important points---firstly, if there is an equally good match of a call to a template and a non-template function, the non-template function is preferred, and secondly, the compiler does not attempt to instantiate the function templates into something that might be convertible to the types we need. The template functions must match the call almost perfectly after the argument type deduction, or they are not called at all. Let's add a template to our previous example:}{}

\begin{code}
% EN: void whatami(int x); // Same as above
void whatami(long x); // Same as above
template <typename T> void whatami(T* x) {
  std::cout << x << " is a pointer" << std::endl;
\Trans{void whatami(int x); // Same as above void whatami(long x); // Same as above template <typename T> void whatami(T* x) { std::cout << x << " is a pointer" << std::endl;}{}

}
% EN: int i = 5;
whatami(i);    // 5 is int
whatami(&i);    // 0x???? is a pointer
\Trans{int i = 5; whatami(i); // 5 is int whatami(&i); // 0x???? is a pointer}{}

\end{code}

% EN: Here, we have what looks like a partial specialization of a function template. But it really isn't---it is just a function template---there is no general template for which it could be a specialization. Instead, it is simply a function template whose type parameter is deduced from the same arguments, but using different rules. The template can have its type deduced if the argument is a pointer of any kind. This includes a pointer to \texttt{const}---\texttt{T} could be a \texttt{const} type, so if we call \texttt{whatami(ptr)}, where \texttt{ptr} is \texttt{const\ int*}, that first template overload is a perfect match when \texttt{T} is \texttt{const\ int}. If the deduction succeeds, the function generated by the template, that is, the template instantiation, is added to the overload set.
\Trans{Here, we have what looks like a partial specialization of a function template. But it really isn't---it is just a function template---there is no general template for which it could be a specialization. Instead, it is simply a function template whose type parameter is deduced from the same arguments, but using different rules. The template can have its type deduced if the argument is a pointer of any kind. This includes a pointer to \texttt{const}---\texttt{T} could be a \texttt{const} type, so if we call \texttt{whatami(ptr)}, where \texttt{ptr} is \texttt{const\ int*}, that first template overload is a perfect match when \texttt{T} is \texttt{const\ int}. If the deduction succeeds, the function generated by the template, that is, the template instantiation, is added to the overload set.}{}

% EN: For the \texttt{int*} argument, it is the only overload that works, so it is called. But what happens if more than one function template can match the call, and both instantiations are valid overloads? Let's add one more template:
\Trans{For the \texttt{int*} argument, it is the only overload that works, so it is called. But what happens if more than one function template can match the call, and both instantiations are valid overloads? Let's add one more template:}{}

\begin{code}
% EN: void whatami(int x); // Same as above
void whatami(long x); // Same as above
template <typename T> void whatami(T* x); // Same as above
template <typename T> void whatami(T&& x) {
  std::cout << "Something weird" << std::endl;
\Trans{void whatami(int x); // Same as above void whatami(long x); // Same as above template <typename T> void whatami(T* x); // Same as above template <typename T> void whatami(T&& x) { std::cout << "Something weird" << std::endl;}{}

}
% EN: class C {     };
C c;
whatami(c);    // Something weird
whatami(&c);    // 0x???? is a pointer
\Trans{class C { }; C c; whatami(c); // Something weird whatami(&c); // 0x???? is a pointer}{}

\end{code}

% EN: This template function accepts its arguments by the universal reference, so it can be instantiated for any call to \texttt{whatami()} with one argument. The first call, \texttt{whatami(c)}, is easy---the last overload, with \texttt{T\&\&}, is the only one that can be called. There are no conversions from \texttt{c} to a pointer or an integer. But the second call is tricky---we have not one, but two template instantiations that are a perfect match for the call, with no conversions needed. So why is this not an ambiguous overload? Because the rules for resolving overloaded function templates are different than the rules for non-template functions and resemble the rules for selecting the partial specialization of a class template (which is another reason why function template overloads are often confused with partial specializations). The template that is more specific is a better match.
\Trans{This template function accepts its arguments by the universal reference, so it can be instantiated for any call to \texttt{whatami()} with one argument. The first call, \texttt{whatami(c)}, is easy---the last overload, with \texttt{T\&\&}, is the only one that can be called. There are no conversions from \texttt{c} to a pointer or an integer. But the second call is tricky---we have not one, but two template instantiations that are a perfect match for the call, with no conversions needed. So why is this not an ambiguous overload? Because the rules for resolving overloaded function templates are different than the rules for non-template functions and resemble the rules for selecting the partial specialization of a class template (which is another reason why function template overloads are often confused with partial specializations). The template that is more specific is a better match.}{}

% EN: In our case, the first template is more specific---it can accept any pointer argument, but only pointers. The second template can accept any argument at all, so any time the first template is a possible match, the second is too, but not the reverse. If a more specific template can be used to instantiate a function that is a valid overload, then this template is used.
\Trans{In our case, the first template is more specific---it can accept any pointer argument, but only pointers. The second template can accept any argument at all, so any time the first template is a possible match, the second is too, but not the reverse. If a more specific template can be used to instantiate a function that is a valid overload, then this template is used.}{}

% EN: Otherwise, we have to fall back to the more general template.
\Trans{Otherwise, we have to fall back to the more general template.}{}

% EN: The very general template functions in the overload set sometimes lead to unexpected results. Let's say we have the following three overloads for \texttt{int}, \texttt{double}, and anything:
\Trans{The very general template functions in the overload set sometimes lead to unexpected results. Let's say we have the following three overloads for \texttt{int}, \texttt{double}, and anything:}{}

\begin{code}
% EN: void whatami(int x) {
  std::cout << x << " is int" << std::endl;
\Trans{void whatami(int x) { std::cout << x << " is int" << std::endl;}{}

}
% EN: void whatami(double x) {
  std::cout << x << " is double" << std::endl;
\Trans{void whatami(double x) { std::cout << x << " is double" << std::endl;}{}

}
% EN: template <typename T> void whatami(T&& x) {
  std::cout << "Something weird" << std::endl;
\Trans{template <typename T> void whatami(T&& x) { std::cout << "Something weird" << std::endl;}{}

}
% EN: int i = 5;
float x = 4.2;
whatami(i);    // i is int
whatami(x);    // Something weird
whatami(1.2);    // 1.2 is double
\Trans{int i = 5; float x = 4.2; whatami(i); // i is int whatami(x); // Something weird whatami(1.2); // 1.2 is double}{}

\end{code}

% EN: The first call has an \texttt{int} argument, so \texttt{whatami(int)} is a perfect match. The second call would have gone to \texttt{whatami(double)} if we did not have the template overload---the conversion from \texttt{float} to \texttt{double} is implicit (so is the conversion from \texttt{float} to \texttt{int}, but the conversion to \texttt{double} is preferred). But it's still a conversion, so when the function template instantiates to a perfect match of \texttt{whatami(float\&\&)}, that is the best match and the chosen overload. The last call has a \texttt{double} argument, and again we have a perfect match to a non-template function \texttt{whatami(double)}, so it is preferred over any alternative.
\Trans{The first call has an \texttt{int} argument, so \texttt{whatami(int)} is a perfect match. The second call would have gone to \texttt{whatami(double)} if we did not have the template overload---the conversion from \texttt{float} to \texttt{double} is implicit (so is the conversion from \texttt{float} to \texttt{int}, but the conversion to \texttt{double} is preferred). But it's still a conversion, so when the function template instantiates to a perfect match of \texttt{whatami(float\&\&)}, that is the best match and the chosen overload. The last call has a \texttt{double} argument, and again we have a perfect match to a non-template function \texttt{whatami(double)}, so it is preferred over any alternative.}{}

% EN: It should be noted that overloading pass-by-value and pass-by-reference functions for the same parameter types often creates ambiguities in overload resolution. For example, these two functions are almost always ambiguous:
\Trans{It should be noted that overloading pass-by-value and pass-by-reference functions for the same parameter types often creates ambiguities in overload resolution. For example, these two functions are almost always ambiguous:}{}

\begin{code}
% EN: template <typename T> void whatami(T&& x) {
  std::cout << "Something weird" << std::endl;
\Trans{template <typename T> void whatami(T&& x) { std::cout << "Something weird" << std::endl;}{}

}
% EN: template <typename T> void whatami(T x) {
  std::cout << "Something copyable" << std::endl;
\Trans{template <typename T> void whatami(T x) { std::cout << "Something copyable" << std::endl;}{}

}
% EN: class C { };
C c;
whatami(c);
\Trans{class C {}; C c; whatami(c);}{}

\end{code}

% EN: As long as the argument to the function can be copied (and our object \texttt{c} is copyable), the overload is ambiguous and the call will not compile. The problem does not happen when a more specific function overloads a more general one (in all our previous examples, \texttt{whatami(int)} used pass-by-value with no problems), but mixing the two types of parameter passing for similarly general functions is inadvisable.
\Trans{As long as the argument to the function can be copied (and our object \texttt{c} is copyable), the overload is ambiguous and the call will not compile. The problem does not happen when a more specific function overloads a more general one (in all our previous examples, \texttt{whatami(int)} used pass-by-value with no problems), but mixing the two types of parameter passing for similarly general functions is inadvisable.}{}

% EN: Finally, there is one more kind of function that has a special place in the overload resolution order---a variadic function.
\Trans{Finally, there is one more kind of function that has a special place in the overload resolution order---a variadic function.}{}

% EN: A variadic function is declared with \texttt{...} instead of arguments, and it can be called with any number of arguments of any type (\texttt{printf} is one such function). This function is the overload of the last resort---it is called only if no other overloads can be used:
\Trans{A variadic function is declared with \texttt{...} instead of arguments, and it can be called with any number of arguments of any type (\texttt{printf} is one such function). This function is the overload of the last resort---it is called only if no other overloads can be used:}{}

\begin{code}
% EN: void whatami(...) {
  std::cout << "It's something or somethings" << std::endl;
\Trans{void whatami(...) { std::cout << "It's something or somethings" << std::endl;}{}

}
\end{code}

% EN: As long as we have the overload \texttt{whatami(T\&\&\ x)} available, a variadic function will never be the preferred overload, at least not for any calls to \texttt{whatami()} with one argument. Without that template, \texttt{whatami(...)} is called for any argument that is not a number or a pointer. The variadic functions were around since the days of C, and are not to be confused with variadic templates that were introduced in C++11, and this is what we'll talk about next.
\Trans{As long as we have the overload \texttt{whatami(T\&\&\ x)} available, a variadic function will never be the preferred overload, at least not for any calls to \texttt{whatami()} with one argument. Without that template, \texttt{whatami(...)} is called for any argument that is not a number or a pointer. The variadic functions were around since the days of C, and are not to be confused with variadic templates that were introduced in C++11, and this is what we'll talk about next.}{}

\section{Variadic templates}

% EN: Probably the greatest difference between generic programming in C and C++ is type safety. It is possible to write generic code in C---the standard function \texttt{qsort()} is a perfect example---it can sort values of any type and they are passed in using a \texttt{void*} pointer, which can really be a pointer to any type. Of course, the programmer has to know what the real type is and cast the pointer to the right type. In a generic C++ program, the types are either explicitly specified or deduced at the time of the instantiation, and the type system for generic types is as strong as it is for regular types. Unless we want a function with an unknown number of arguments, that is, prior to C++11, the only way was the old C-style variadic functions where the compiler had no idea what the argument types were; the programmer just had to know and unpack the variable arguments correctly.
\Trans{Probably the greatest difference between generic programming in C and C++ is type safety. It is possible to write generic code in C---the standard function \texttt{qsort()} is a perfect example---it can sort values of any type and they are passed in using a \texttt{void*} pointer, which can really be a pointer to any type. Of course, the programmer has to know what the real type is and cast the pointer to the right type. In a generic C++ program, the types are either explicitly specified or deduced at the time of the instantiation, and the type system for generic types is as strong as it is for regular types. Unless we want a function with an unknown number of arguments, that is, prior to C++11, the only way was the old C-style variadic functions where the compiler had no idea what the argument types were; the programmer just had to know and unpack the variable arguments correctly.}{}

% EN: C++11 introduced the modern equivalent to a variadic function---a variadic template. We can now declare a generic function with any number of arguments:
\Trans{C++11 introduced the modern equivalent to a variadic function---a variadic template. We can now declare a generic function with any number of arguments:}{}

\begin{code}
% EN: template <typename ... T> auto sum(const T& ... x);
\Trans{template <typename ... T> auto sum(const T& ... x);}{}
\end{code}

% EN: This function takes one or more arguments, possibly of different types, and computes their sum. The return type is not easy to determine, but, fortunately, we can let the compiler figure it out---we just declare the return type as \texttt{auto}. How do we actually implement the function to add up the unknown number of values whose types we can't name, not even as generic types? In C++17, it's easy, because it has fold expressions:
\Trans{This function takes one or more arguments, possibly of different types, and computes their sum. The return type is not easy to determine, but, fortunately, we can let the compiler figure it out---we just declare the return type as \texttt{auto}. How do we actually implement the function to add up the unknown number of values whose types we can't name, not even as generic types? In C++17, it's easy, because it has fold expressions:}{}

\begin{code}
% EN: // Example 08a
template <typename ... T> auto sum(const T& ... x) {
  return (x + ...);
\Trans{// Example 08a template <typename ... T> auto sum(const T& ... x) { return (x + ...);}{}

}
% EN: sum(5, 7, 3);        // 15, int
sum(5, 7L, 3);        // 15, long
sum(5, 7L, 2.9);        // 14.9, double
\Trans{sum(5, 7, 3); // 15, int sum(5, 7L, 3); // 15, long sum(5, 7L, 2.9); // 14.9, double}{}

\end{code}

% EN: You can verify that the type of the result is what we say it is:
\Trans{You can verify that the type of the result is what we say it is:}{}

\begin{code}
% EN: static_assert(std::is_same_v<
  decltype(sum(5, 7L, 2.9)), double>);
\Trans{static_assert(std::is_same_v< decltype(sum(5, 7L, 2.9)), double>);}{}

\end{code}

% EN: In C++14, as well as in C++17, when a fold expression is not sufficient (and they are useful only in limited contexts, mostly when the arguments and combines using binary or unary operators), the standard technique is recursion, which is ever-popular in template programming:
\Trans{In C++14, as well as in C++17, when a fold expression is not sufficient (and they are useful only in limited contexts, mostly when the arguments and combines using binary or unary operators), the standard technique is recursion, which is ever-popular in template programming:}{}

\begin{code}
% EN: // Example 08b
template <typename T1> auto sum(const T1& x1) {
  return x1;
\Trans{// Example 08b template <typename T1> auto sum(const T1& x1) { return x1;}{}

}
% EN: template <typename T1, typename ... T>
auto sum(const T1& x1, const T& ... x) {
  return x1 + sum(x ...);
\Trans{template <typename T1, typename ... T> auto sum(const T1& x1, const T& ... x) { return x1 + sum(x ...);}{}

}
\end{code}

% EN: The first overload (not a partial specialization!) is for the \texttt{sum()} function with one argument of any type. That value is returned. The second overload is for more than one argument, and the first argument is explicitly added to the sum of the remaining arguments. The recursion continues until there is only one argument left, at which point the other overload is called and the recursion stops. This is the standard technique for unraveling the parameter packs in variadic templates, and we will see this many times in this book. The compiler will inline all the recursive function calls and generate straightforward code that adds all arguments together.
\Trans{The first overload (not a partial specialization!) is for the \texttt{sum()} function with one argument of any type. That value is returned. The second overload is for more than one argument, and the first argument is explicitly added to the sum of the remaining arguments. The recursion continues until there is only one argument left, at which point the other overload is called and the recursion stops. This is the standard technique for unraveling the parameter packs in variadic templates, and we will see this many times in this book. The compiler will inline all the recursive function calls and generate straightforward code that adds all arguments together.}{}

% EN: The class templates can also be variadic---they have an arbitrary number of type arguments and can build classes from a varying number of objects of different types. The declaration is similar to that of a function template. For example, let's build a class template, \texttt{Group}, that can hold any number of objects of different types and return the right object when it's converted to one of the types it holds:
\Trans{The class templates can also be variadic---they have an arbitrary number of type arguments and can build classes from a varying number of objects of different types. The declaration is similar to that of a function template. For example, let's build a class template, \texttt{Group}, that can hold any number of objects of different types and return the right object when it's converted to one of the types it holds:}{}

\begin{code}
% EN: // Example 09
template <typename ... T> struct Group;
\Trans{// Example 09 template <typename ... T> struct Group;}{}

\end{code}

% EN: The usual implementation of such templates is again recursive, using deeply nested inheritance, although a non-recursive implementation is sometimes possible. We will see one in the next section. The recursion has to be terminated when there is only one type parameter left. This is done using a partial specialization, so we will leave the general template we showed previously as a declaration only, and define a specialization for one type parameter:
\Trans{The usual implementation of such templates is again recursive, using deeply nested inheritance, although a non-recursive implementation is sometimes possible. We will see one in the next section. The recursion has to be terminated when there is only one type parameter left. This is done using a partial specialization, so we will leave the general template we showed previously as a declaration only, and define a specialization for one type parameter:}{}

\begin{code}
% EN: template <typename ... T> struct Group;
template <typename T1> struct Group<T1> {
  T1 t1_;
  Group() = default;
  explicit Group(const T1& t1) : t1_(t1) { }
  explicit Group(T1&& t1) : t1_(std::move(t1)) { }
  explicit operator const T1&() const { return t1_;  }
  explicit operator T1&() { return t1_;  }
 };
\Trans{template <typename ... T> struct Group; template <typename T1> struct Group<T1> { T1 t1_; Group() = default; explicit Group(const T1& t1) : t1_(t1) {} explicit Group(T1&& t1) : t1_(std::move(t1)) {} explicit operator const T1&() const { return t1_; } explicit operator T1&() { return t1_; } };}{}

\end{code}

% EN: This class holds the value of one type, \texttt{T1}, initializes it by copy or move and returns a reference to it when converted to the \texttt{T1} type. The specialization for an arbitrary number of type parameters contains the first one as a data member, together with the corresponding initialization and conversion methods, and inherits from the \texttt{Group} class template of the remaining types:
\Trans{This class holds the value of one type, \texttt{T1}, initializes it by copy or move and returns a reference to it when converted to the \texttt{T1} type. The specialization for an arbitrary number of type parameters contains the first one as a data member, together with the corresponding initialization and conversion methods, and inherits from the \texttt{Group} class template of the remaining types:}{}

\begin{code}
% EN: template <typename T1, typename ... T>
struct Group<T1, T ...> : Group<T ...> {
  T1 t1_;
  Group() = default;
  explicit Group(const T1& t1, T&& ... t) :
    Group<T ...>(std::forward<T>(t) ...), t1_(t1) { }
  explicit Group(T1&& t1, T&& ... t) :
    Group<T...>(std::forward<T>(t)...),
                t1_(std::move(t1)) { }
  explicit operator const T1&() const { return t1_;  }
  explicit operator T1&() { return t1_;  }
 };
\Trans{template <typename T1, typename ... T> struct Group<T1, T ...> : Group<T ...> { T1 t1_; Group() = default; explicit Group(const T1& t1, T&& ... t) : Group<T ...>(std::forward<T>(t) ...), t1_(t1) {} explicit Group(T1&& t1, T&& ... t) : Group<T...>(std::forward<T>(t)...), t1_(std::move(t1)) {} explicit operator const T1&() const { return t1_; } explicit operator T1&() { return t1_; } };}{}

\end{code}

% EN: For every type contained in a \texttt{Group} class, there are two possible ways it can be initialized---copy or move. Fortunately, we do not have to spell out the constructors for every combination of copy and move operations. Instead, we have two versions of the constructor for the two ways to initialize the first argument (the one stored in the specialization); we use perfect forwarding for the remaining arguments.
\Trans{For every type contained in a \texttt{Group} class, there are two possible ways it can be initialized---copy or move. Fortunately, we do not have to spell out the constructors for every combination of copy and move operations. Instead, we have two versions of the constructor for the two ways to initialize the first argument (the one stored in the specialization); we use perfect forwarding for the remaining arguments.}{}

% EN: Now, we can use our \texttt{Group} class template to hold some values of different types (it cannot handle multiple values of the same type since the attempt to retrieve this type would be ambiguous):
\Trans{Now, we can use our \texttt{Group} class template to hold some values of different types (it cannot handle multiple values of the same type since the attempt to retrieve this type would be ambiguous):}{}

\begin{code}
% EN: Group<int, long> g(3, 5);
int(g);    // 3
long(g);    // 5
\Trans{Group<int, long> g(3, 5); int(g); // 3 long(g); // 5}{}

\end{code}

% EN: It is rather inconvenient to write all the group types explicitly and to make sure they match the argument types. In C++17, we can use a deduction guide to enable class template parameter deduction from the constructor:
\Trans{It is rather inconvenient to write all the group types explicitly and to make sure they match the argument types. In C++17, we can use a deduction guide to enable class template parameter deduction from the constructor:}{}

\begin{code}
% EN: template <typename ... T> Group(T&&... t) -> Group<T...>;
Group g(3, 2.2, std::string("xyz"));
int(g);            // 3
double(g);            // 2.2
std::string(g);        // "xyz"
\Trans{template <typename ... T> Group(T&&... t) -> Group<T...>; Group g(3, 2.2, std::string("xyz")); int(g); // 3 double(g); // 2.2 std::string(g); // "xyz"}{}

\end{code}

% EN: Before C++17, the usual solution to this problem is to use a helper function template (a variadic template, of course) to take advantage of the template argument deduction:
\Trans{Before C++17, the usual solution to this problem is to use a helper function template (a variadic template, of course) to take advantage of the template argument deduction:}{}

\begin{code}
% EN: template <typename ... T> auto makeGroup(T&& ... t) {
  return Group<T ...>(std::forward<T>(t) ...);
\Trans{template <typename ... T> auto makeGroup(T&& ... t) { return Group<T ...>(std::forward<T>(t) ...);}{}

}
% EN: auto g = makeGroup(3, 2.2, std::string("xyz"));
\Trans{auto g = makeGroup(3, 2.2, std::string("xyz"));}{}
\end{code}

% EN: Note that the C++ standard library contains a class template, \texttt{std::tuple}, which is a much more complete and full-featured version of our \texttt{Group}.
\Trans{Note that the C++ standard library contains a class template, \texttt{std::tuple}, which is a much more complete and full-featured version of our \texttt{Group}.}{}

% EN: Variadic templates can have non-type parameters as well; in this case, the \texttt{makeGroup} template can be instantiated with an arbitrary number of arguments. Often, these non-type parameter packs are used in combination with \texttt{auto} (deduced) types. For example, here is a template that holds a list of compile-time constant values of different types:
\Trans{Variadic templates can have non-type parameters as well; in this case, the \texttt{makeGroup} template can be instantiated with an arbitrary number of arguments. Often, these non-type parameter packs are used in combination with \texttt{auto} (deduced) types. For example, here is a template that holds a list of compile-time constant values of different types:}{}

\begin{code}
% EN: // Example 10
template <auto... Values> struct value_list { };
\Trans{// Example 10 template <auto... Values> struct value_list {};}{}

\end{code}

% EN: Without \texttt{auto} (i.e., prior to C++17) it is almost impossible to declare such a template since the types must be explicitly specified. Note that this is the entire template: it holds the constant values as a part of its definition. To extract them, we need another variadic template:
\Trans{Without \texttt{auto} (i.e., prior to C++17) it is almost impossible to declare such a template since the types must be explicitly specified. Note that this is the entire template: it holds the constant values as a part of its definition. To extract them, we need another variadic template:}{}

\begin{code}
% EN: template <size_t N, auto... Values>
struct nth_value_helper;
template <size_t n, auto v1, auto... Values>
struct nth_value_helper<n, v1, Values...> {
  static constexpr auto value =
    nth_value_helper<n - 1, Values...>::value;
 };
template <auto v1, auto... Values>
struct nth_value_helper<0, v1, Values...> {
  static constexpr auto value = v1;
 };
template <size_t N, auto... Values>
constexpr auto nth_value(value_list<Values...>) {
  return nth_value_helper<N, Values...>::value;
\Trans{template <size_t N, auto... Values> struct nth_value_helper; template <size_t n, auto v1, auto... Values> struct nth_value_helper<n, v1, Values...> { static constexpr auto value = nth_value_helper<n - 1, Values...>::value; }; template <auto v1, auto... Values> struct nth_value_helper<0, v1, Values...> { static constexpr auto value = v1; }; template <size_t N, auto... Values> constexpr auto nth_value(value_list<Values...>) { return nth_value_helper<N, Values...>::value;}{}

}
\end{code}

% EN: The template function \texttt{nth\_value} deduces the parameter pack \texttt{Values} from the type of the \texttt{value\_list} argument (the argument itself contains no data and is of no interest except for its type). A recursive instantiation of partial class specializations is then used to iterate over the parameter pack until we get to the \texttt{N}-th value. Note that to store floating-point constants in this manner, we need C++20.
\Trans{The template function \texttt{nth\_value} deduces the parameter pack \texttt{Values} from the type of the \texttt{value\_list} argument (the argument itself contains no data and is of no interest except for its type). A recursive instantiation of partial class specializations is then used to iterate over the parameter pack until we get to the \texttt{N}-th value. Note that to store floating-point constants in this manner, we need C++20.}{}

% EN: Variadic templates can be used in combination with template template parameters to resolve some of the problems created when, for example, standard library containers are used as arguments substituted for template template parameters. A simple solution is to declare the parameter as taking any number of types:
\Trans{Variadic templates can be used in combination with template template parameters to resolve some of the problems created when, for example, standard library containers are used as arguments substituted for template template parameters. A simple solution is to declare the parameter as taking any number of types:}{}

\begin{code}
% EN: template <template <typename...> class Container,
         typename... T>
void print(const Container<T...>& container);
std::vector<int> v{ 鈥? };
print(v);
\Trans{template <template <typename...> class Container, typename... T> void print(const Container<T...>& container); std::vector<int> v{ 鈥?}; print(v);}{}

\end{code}

% EN: Note that the \texttt{std::vector} template has two type parameters. In C++17, a standard change made this a valid match for the parameter pack specified in the \texttt{Container} template template parameter. Most compilers allowed such matches even earlier.
\Trans{Note that the \texttt{std::vector} template has two type parameters. In C++17, a standard change made this a valid match for the parameter pack specified in the \texttt{Container} template template parameter. Most compilers allowed such matches even earlier.}{}

% EN: The variadic templates, especially combined with perfect forwarding, are extremely useful for writing very general template classes---for example, a vector can contain objects of an arbitrary type, and, to construct these objects in place instead of copying them, we have to call constructors with a different number of arguments. When the vector template is written, there is no way to know how many arguments are needed to initialize the objects the vector will contain, so a variadic template has to be used (indeed, the in-place constructors of \texttt{std::vector}, such as \texttt{emplace\_back}, are variadic templates).
\Trans{The variadic templates, especially combined with perfect forwarding, are extremely useful for writing very general template classes---for example, a vector can contain objects of an arbitrary type, and, to construct these objects in place instead of copying them, we have to call constructors with a different number of arguments. When the vector template is written, there is no way to know how many arguments are needed to initialize the objects the vector will contain, so a variadic template has to be used (indeed, the in-place constructors of \texttt{std::vector}, such as \texttt{emplace\_back}, are variadic templates).}{}

% EN: There is one more kind of template-like entity in C++ that we have to mention, one that has the appearance of both a class and a function---a lambda expression. The next section is dedicated to this.
\Trans{There is one more kind of template-like entity in C++ that we have to mention, one that has the appearance of both a class and a function---a lambda expression. The next section is dedicated to this.}{}

\section{Lambda expressions}

% EN: In C++, the regular function syntax is extended with the concept of a \emph{callable}, short for \emph{callable entity}---a callable is something that can be called in the same way as a function. Some examples of callables are functions (of course), function pointers, or objects with the \texttt{operator()}, also known as \textbf{functors}:
\Trans{In C++, the regular function syntax is extended with the concept of a \emph{callable}, short for \emph{callable entity}---a callable is something that can be called in the same way as a function. Some examples of callables are functions (of course), function pointers, or objects with the \texttt{operator()}, also known as \textbf{functors}:}{}

\begin{code}
% EN: void f(int i); struct G {
  void operator()(int i);
 };
f(5);            // Function
G g; g(5);        // Functor
\Trans{void f(int i); struct G { void operator()(int i); }; f(5); // Function G g; g(5); // Functor}{}

\end{code}

% EN: It is often useful to define a callable entity in a local context, right next to the place it is used. For example, to sort a sequence of objects, we may want to define a custom comparison function. We can use an ordinary function for this:
\Trans{It is often useful to define a callable entity in a local context, right next to the place it is used. For example, to sort a sequence of objects, we may want to define a custom comparison function. We can use an ordinary function for this:}{}

\begin{code}
% EN: bool compare(int i, int j) { return i < j;  }
void do_work() {
  std::vector<int> v;
  .....
  std::sort(v.begin(), v.end(), compare);
\Trans{bool compare(int i, int j) { return i < j; } void do_work() { std::vector<int> v; ..... std::sort(v.begin(), v.end(), compare);}{}

}
\end{code}

% EN: However, in C++, functions cannot be defined inside other functions, so our \texttt{compare()} function may have to be defined quite far from the place it is used. If it is a single-use comparison function, such separation is inconvenient and reduces the readability and maintainability of the code.
\Trans{However, in C++, functions cannot be defined inside other functions, so our \texttt{compare()} function may have to be defined quite far from the place it is used. If it is a single-use comparison function, such separation is inconvenient and reduces the readability and maintainability of the code.}{}

% EN: There is a way around this limitation---while we cannot declare functions inside functions, we can declare classes, and classes can be callable:
\Trans{There is a way around this limitation---while we cannot declare functions inside functions, we can declare classes, and classes can be callable:}{}

\begin{code}
% EN: void do_work() {
  std::vector<int> v;
  .....
  struct compare {
    bool operator()(int i, int j) const { return i < j;  }
   };
  std::sort(v.begin(), v.end(), compare());
\Trans{void do_work() { std::vector<int> v; ..... struct compare { bool operator()(int i, int j) const { return i < j; } }; std::sort(v.begin(), v.end(), compare());}{}

}
\end{code}

% EN: This is compact and local, but rather verbose. We do not actually need to give this class a name, and we only ever want one instance of this class. In C++11, we have a much better option, the lambda expression:
\Trans{This is compact and local, but rather verbose. We do not actually need to give this class a name, and we only ever want one instance of this class. In C++11, we have a much better option, the lambda expression:}{}

\begin{code}
% EN: void do_work() {
  std::vector<int> v;
  .....
  auto compare = [](int i, int j) { return i < j;  };
  std::sort(v.begin(), v.end(), compare);
\Trans{void do_work() { std::vector<int> v; ..... auto compare = [](int i, int j) { return i < j; }; std::sort(v.begin(), v.end(), compare);}{}

}
\end{code}

% EN: If we use this comparison function for just one call to \texttt{std::sort}, we don't even need to give it a name and can define it inside the call:
\Trans{If we use this comparison function for just one call to \texttt{std::sort}, we don't even need to give it a name and can define it inside the call:}{}

\begin{code}
% EN:   std::sort(v.begin(), v.end(),
            [](int i, int j) { return i < j;  });
\Trans{std::sort(v.begin(), v.end(), [](int i, int j) { return i < j; });}{}

\end{code}

% EN: This is as compact as it gets. The return type can be specified, but can usually be deduced by the compiler. The lambda expression creates an object, so it has a type, but that type is generated by the compiler, so the object declaration must use \texttt{auto}.
\Trans{This is as compact as it gets. The return type can be specified, but can usually be deduced by the compiler. The lambda expression creates an object, so it has a type, but that type is generated by the compiler, so the object declaration must use \texttt{auto}.}{}

% EN: The lambda expressions are objects, so they can have data members. Of course, a local callable class can also have data members. Usually, they are initialized from the local variables in the containing scope:
\Trans{The lambda expressions are objects, so they can have data members. Of course, a local callable class can also have data members. Usually, they are initialized from the local variables in the containing scope:}{}

\begin{code}
% EN: // Example 11
void do_work() {
  std::vector<double> v;
  .....
  struct compare_with_tolerance {
    const double tolerance;
    explicit compare_with_tolerance(double tol) :
      tolerance(tol) { }
    bool operator()(double x, double y) const {
      return x < y && std::abs(x - y) > tolerance;
     }
   };
  double tolerance = 0.01;
  std::sort(v.begin(), v.end(),
            compare_with_tolerance(tolerance));
\Trans{// Example 11 void do_work() { std::vector<double> v; ..... struct compare_with_tolerance { const double tolerance; explicit compare_with_tolerance(double tol) : tolerance(tol) {} bool operator()(double x, double y) const { return x < y && std::abs(x - y) > tolerance; } }; double tolerance = 0.01; std::sort(v.begin(), v.end(), compare_with_tolerance(tolerance));}{}

}
\end{code}

% EN: Again, this is a very verbose way to do something simple. We have to mention the tolerance variable three times---as a data member, a constructor argument, and in the member initialization list. A lambda expression makes this code simpler as well because it can capture local variables. In local classes, we are not allowed to reference variables from the containing scope, except by passing them through the constructor arguments, but for lambda expressions, the compiler automatically generates a constructor to capture all local variables mentioned in the body of the expression:
\Trans{Again, this is a very verbose way to do something simple. We have to mention the tolerance variable three times---as a data member, a constructor argument, and in the member initialization list. A lambda expression makes this code simpler as well because it can capture local variables. In local classes, we are not allowed to reference variables from the containing scope, except by passing them through the constructor arguments, but for lambda expressions, the compiler automatically generates a constructor to capture all local variables mentioned in the body of the expression:}{}

\begin{code}
% EN: void do_work() {
  std::vector<double> v;
  .....
  double tolerance = 0.01;
  auto compare_with_tolerance = [=](auto x, auto y) {
    return x < y && std::abs(x - y) > tolerance;
   };
  std::sort(v.begin(), v.end(), compare_with_tolerance);
\Trans{void do_work() { std::vector<double> v; ..... double tolerance = 0.01; auto compare_with_tolerance = [=](auto x, auto y) { return x < y && std::abs(x - y) > tolerance; }; std::sort(v.begin(), v.end(), compare_with_tolerance);}{}

}
\end{code}

% EN: Here, the name \texttt{tolerance} inside the lambda expression refers to the local variable with the same name. The variable is captured by value, which is specified in the lambda expression's capture clause \texttt{{[}={]}}. We could have captured by reference using \texttt{{[}\&{]}} like this:
\Trans{Here, the name \texttt{tolerance} inside the lambda expression refers to the local variable with the same name. The variable is captured by value, which is specified in the lambda expression's capture clause \texttt{{[}={]}}. We could have captured by reference using \texttt{{[}\&{]}} like this:}{}

\begin{code}
% EN: auto compare_with_tolerance = [&](auto x, auto y) {
  return x < y && std::abs(x - y) > tolerance;
 };
\Trans{auto compare_with_tolerance = [&](auto x, auto y) { return x < y && std::abs(x - y) > tolerance; };}{}

\end{code}

% EN: The difference is that, when capturing by value, a copy of the captured variable is created inside the lambda object at the point where it is constructed. This local copy is \texttt{const} by default, although we can declare the lambda mutable, which would let us change the captured values:
\Trans{The difference is that, when capturing by value, a copy of the captured variable is created inside the lambda object at the point where it is constructed. This local copy is \texttt{const} by default, although we can declare the lambda mutable, which would let us change the captured values:}{}

\begin{code}
% EN: double tolerance = 0.01;
size_t count = 0; // line 2
auto compare_with_tolerance = [=](auto x, auto y) mutable {
  std::cout << "called " << ++count << " times\n";
  return x < y && std::abs(x - y) > tolerance;
 };
std::vector<double> v;
鈥?store values in v 鈥?
// Counts calls but does not change the value on line 2
std::sort(v.begin(), v.end(), compare_with_tolerance);
\Trans{double tolerance = 0.01; size_t count = 0; // line 2 auto compare_with_tolerance = [=](auto x, auto y) mutable { std::cout << "called " << ++count << " times\n"; return x < y && std::abs(x - y) > tolerance; }; std::vector<double> v; 鈥?store values in v 鈥? // Counts calls but does not change the value on line 2 std::sort(v.begin(), v.end(), compare_with_tolerance);}{}

\end{code}

% EN: On the other hand, capturing the variables from the outer scope by reference makes every mention of this variable inside the lambda a reference to the original variable. Values captured by reference can be changed:
\Trans{On the other hand, capturing the variables from the outer scope by reference makes every mention of this variable inside the lambda a reference to the original variable. Values captured by reference can be changed:}{}

\begin{code}
% EN: double tolerance = 0.01;
size_t count = 0;
auto compare_with_tolerance = [&](auto x, auto y) mutable {
  ++count; // Changes count above
  return x < y && std::abs(x - y) > tolerance;
 };
std::vector<double> v;
鈥?store values in v 鈥?
std::sort(v.begin(), v.end(), compare_with_tolerance);
std::cout << "lambda called " << count << " times\n";
\Trans{double tolerance = 0.01; size_t count = 0; auto compare_with_tolerance = [&](auto x, auto y) mutable { ++count; // Changes count above return x < y && std::abs(x - y) > tolerance; }; std::vector<double> v; 鈥?store values in v 鈥? std::sort(v.begin(), v.end(), compare_with_tolerance); std::cout << "lambda called " << count << " times\n";}{}

\end{code}

% EN: It is also possible to explicitly capture some variables by value or by reference; for example, the capture \texttt{{[}=,\ \&count{]}} captures everything by value except \texttt{count}, which is captured by reference.
\Trans{It is also possible to explicitly capture some variables by value or by reference; for example, the capture \texttt{{[}=,\ \&count{]}} captures everything by value except \texttt{count}, which is captured by reference.}{}

% EN: Instead of changing the arguments of the lambda expression from \texttt{int} in the earlier example to \texttt{double}, we can declare them as \texttt{auto}, which effectively makes the \texttt{operator()} of the lambda expression a template (this is a C++14 feature).
\Trans{Instead of changing the arguments of the lambda expression from \texttt{int} in the earlier example to \texttt{double}, we can declare them as \texttt{auto}, which effectively makes the \texttt{operator()} of the lambda expression a template (this is a C++14 feature).}{}

% EN: Lambda expressions are most commonly used as local functions. However, they are not really functions; they are callable objects, and so they are missing one feature that functions have---the ability to overload them. The last trick we will learn in this section is how to work around that and create an overload set from lambda expressions.
\Trans{Lambda expressions are most commonly used as local functions. However, they are not really functions; they are callable objects, and so they are missing one feature that functions have---the ability to overload them. The last trick we will learn in this section is how to work around that and create an overload set from lambda expressions.}{}

% EN: First, the main idea---it is indeed impossible to overload callable objects. On the other hand, it is very easy to overload several \texttt{operator()} methods in the same object---methods are overloaded like any other function. Of course, the \texttt{operator()} of a lambda expression object is generated by the compiler, not declared by us, so it is not possible to force the compiler to generate more than one \texttt{operator()} in the same lambda expression. But classes have their own advantages, the main one being that we can inherit from them.
\Trans{First, the main idea---it is indeed impossible to overload callable objects. On the other hand, it is very easy to overload several \texttt{operator()} methods in the same object---methods are overloaded like any other function. Of course, the \texttt{operator()} of a lambda expression object is generated by the compiler, not declared by us, so it is not possible to force the compiler to generate more than one \texttt{operator()} in the same lambda expression. But classes have their own advantages, the main one being that we can inherit from them.}{}

% EN: Lambda expressions are objects---their types are classes, so we can inherit from them too. If a class inherits publicly from a base class, all public methods of the base class become public methods of the derived class. If a class inherits publicly from several base classes (multiple inheritance), its public interface is formed from all the public methods of all the base classes. If there are multiple methods with the same name in this set, they become overloaded and the usual overloading resolution rules apply (in particular, it is possible to create an ambiguous set of overloads, in which case the program will not compile).
\Trans{Lambda expressions are objects---their types are classes, so we can inherit from them too. If a class inherits publicly from a base class, all public methods of the base class become public methods of the derived class. If a class inherits publicly from several base classes (multiple inheritance), its public interface is formed from all the public methods of all the base classes. If there are multiple methods with the same name in this set, they become overloaded and the usual overloading resolution rules apply (in particular, it is possible to create an ambiguous set of overloads, in which case the program will not compile).}{}

% EN: So, we need to create a class that automatically inherits from any number of base classes. We have just seen the right tool for that---variadic templates. As we have learned in the previous section, the usual way to iterate over an arbitrary number of items in the parameter pack of a variadic template is through recursion:
\Trans{So, we need to create a class that automatically inherits from any number of base classes. We have just seen the right tool for that---variadic templates. As we have learned in the previous section, the usual way to iterate over an arbitrary number of items in the parameter pack of a variadic template is through recursion:}{}

\begin{code}
% EN: // Example 12a
template <typename ... F> struct overload_set;
template <typename F1>
struct overload_set<F1> : public F1 {
  overload_set(F1&& f1) : F1(std::move(f1)) { }
  overload_set(const F1& f1) : F1(f1) { }
  using F1::operator();
 };
template <typename F1, typename ... F>
struct overload_set<F1, F ...> :
    public F1, public overload_set<F ...> {
  overload_set(F1&& f1, F&& ... f) :
    F1(std::move(f1)),
    overload_set<F ...>(std::forward<F>(f) ...) { }
  overload_set(const F1& f1, F&& ... f) :
    F1(f1), overload_set<F ...>(std::forward<F>(f) ...) { }
  using F1::operator();
  using overload_set<F ...>::operator();
 };
template <typename ... F> auto overload(F&& ... f) {
  return overload_set<F ...>(std::forward<F>(f) ...);
\Trans{// Example 12a template <typename ... F> struct overload_set; template <typename F1> struct overload_set<F1> : public F1 { overload_set(F1&& f1) : F1(std::move(f1)) {} overload_set(const F1& f1) : F1(f1) {} using F1::operator(); }; template <typename F1, typename ... F> struct overload_set<F1, F ...> : public F1, public overload_set<F ...> { overload_set(F1&& f1, F&& ... f) : F1(std::move(f1)), overload_set<F ...>(std::forward<F>(f) ...) {} overload_set(const F1& f1, F&& ... f) : F1(f1), overload_set<F ...>(std::forward<F>(f) ...) {} using F1::operator(); using overload_set<F ...>::operator(); }; template <typename ... F> auto overload(F&& ... f) { return overload_set<F ...>(std::forward<F>(f) ...);}{}

}
\end{code}

% EN: The \texttt{overload\_set} is a variadic class template; the general template has to be declared before we can specialize it, but it has no definition. The first definition is for the special case of only one lambda expression---the \texttt{overload\_set} class inherits from the lambda expression and adds its \texttt{operator()} to its public interface. The specialization for \texttt{N} lambda expressions (\texttt{N\textgreater{}1}) inherits from the first one and from the \texttt{overload\_set} constructed from the remaining \texttt{N-1} lambda expressions. Finally, we have a helper function that constructs the overload set from any number of lambda expressions---in our case, this is a necessity and not mere convenience since we cannot explicitly specify the types of the lambda expressions, but have to let the function template deduce them. Now, we can construct an overload set from any number of lambda expressions:
\Trans{The \texttt{overload\_set} is a variadic class template; the general template has to be declared before we can specialize it, but it has no definition. The first definition is for the special case of only one lambda expression---the \texttt{overload\_set} class inherits from the lambda expression and adds its \texttt{operator()} to its public interface. The specialization for \texttt{N} lambda expressions (\texttt{N\textgreater{}1}) inherits from the first one and from the \texttt{overload\_set} constructed from the remaining \texttt{N-1} lambda expressions. Finally, we have a helper function that constructs the overload set from any number of lambda expressions---in our case, this is a necessity and not mere convenience since we cannot explicitly specify the types of the lambda expressions, but have to let the function template deduce them. Now, we can construct an overload set from any number of lambda expressions:}{}

\begin{code}
% EN: int i = 5;
double d = 7.3;
auto l = overload(
  [](int* i) { std::cout << "i=" << *i << std::endl;  },
  [](double* d) { std::cout << "d=" << *d << std::endl;  }
);
l(&i);    // i=5
l(&d);    // d=5.3
\Trans{int i = 5; double d = 7.3; auto l = overload( [](int* i) { std::cout << "i=" << *i << std::endl; }, [](double* d) { std::cout << "d=" << *d << std::endl; } ); l(&i); // i=5 l(&d); // d=5.3}{}

\end{code}

% EN: This solution is not perfect, because it does not handle ambiguous overloads well. In C++17, we can do better, and it gives us a chance to demonstrate an alternative way of using a parameter pack that does not need recursion. Here is the C++17 version:
\Trans{This solution is not perfect, because it does not handle ambiguous overloads well. In C++17, we can do better, and it gives us a chance to demonstrate an alternative way of using a parameter pack that does not need recursion. Here is the C++17 version:}{}

\begin{code}
% EN: // Example 12b
template <typename ... F>
struct overload_set : public F ... {
  overload_set(F&& ... f) : F(std::forward<F>(f)) ... { }
  using F::operator() ...;    // C++17
 };
template <typename ... F> auto overload(F&& ... f) {
  return overload_set<F ...>(std::forward<F>(f) ...);
\Trans{// Example 12b template <typename ... F> struct overload_set : public F ... { overload_set(F&& ... f) : F(std::forward<F>(f)) ... {} using F::operator() ...; // C++17 }; template <typename ... F> auto overload(F&& ... f) { return overload_set<F ...>(std::forward<F>(f) ...);}{}

}
\end{code}

% EN: The variadic template does not rely on partial specializations anymore; instead, it inherits directly from the parameter pack (this part of the implementation works in C++14 as well, but the \texttt{using} declaration needs C++17). The template helper function is the same---it deduces the types of all lambda expressions and constructs an object from the \texttt{overload\_set} instantiation with these types. The lambda expressions themselves are passed to the base classes using perfect forwarding, where they are used to initialize all the base objects of the \texttt{overload\_set} objects (lambda expressions are movable). Without the need for recursion or partial specialization, this is a much more compact and straightforward template. Its use is identical to the previous version of \texttt{overload\_set}, but it handles near-ambiguous overloads better.
\Trans{The variadic template does not rely on partial specializations anymore; instead, it inherits directly from the parameter pack (this part of the implementation works in C++14 as well, but the \texttt{using} declaration needs C++17). The template helper function is the same---it deduces the types of all lambda expressions and constructs an object from the \texttt{overload\_set} instantiation with these types. The lambda expressions themselves are passed to the base classes using perfect forwarding, where they are used to initialize all the base objects of the \texttt{overload\_set} objects (lambda expressions are movable). Without the need for recursion or partial specialization, this is a much more compact and straightforward template. Its use is identical to the previous version of \texttt{overload\_set}, but it handles near-ambiguous overloads better.}{}

% EN: We can get rid of the template function as well and use template deduction guides:
\Trans{We can get rid of the template function as well and use template deduction guides:}{}

\begin{code}
% EN: // Example 12c
template <typename ... F>
struct overload : public F ... {
  using F::operator() ...;
 };
template <typename ... F> // Deduction guide
overload(F&& ... ) -> overload<F ...>;
\Trans{// Example 12c template <typename ... F> struct overload : public F ... { using F::operator() ...; }; template <typename ... F> // Deduction guide overload(F&& ... ) -> overload<F ...>;}{}

\end{code}

% EN: The use of the \texttt{overload} template remains largely unchanged; note the curly braces used to construct an object:
\Trans{The use of the \texttt{overload} template remains largely unchanged; note the curly braces used to construct an object:}{}

\begin{code}
% EN: int i = 5;
double d = 7.3;
auto l = overload{
  [](int* i) { std::cout << "i=" << *i << std::endl;  },
  [](double* d) { std::cout << "d=" << *d << std::endl;  },
 };
l(&i);    // i=5
l(&d);    // d=5.3
\Trans{int i = 5; double d = 7.3; auto l = overload{ [](int* i) { std::cout << "i=" << *i << std::endl; }, [](double* d) { std::cout << "d=" << *d << std::endl; }, }; l(&i); // i=5 l(&d); // d=5.3}{}

\end{code}

% EN: We will see lambdas used extensively in later chapters of this book when we will need to write a fragment of code and attach it to an object so that it can be executed later.
\Trans{We will see lambdas used extensively in later chapters of this book when we will need to write a fragment of code and attach it to an object so that it can be executed later.}{}

% EN: Next, we are going to learn about a new C++ feature that, in a way, does the opposite of what we were trying to do so far: it makes templates \emph{less} general. As we have seen already, it is easy to over-promise with a template: we can define templates whose definitions then do not compile in some cases. It would be better to make any restrictions on the template arguments to be a part of the declaration, so let us see how that is done.
\Trans{Next, we are going to learn about a new C++ feature that, in a way, does the opposite of what we were trying to do so far: it makes templates \emph{less} general. As we have seen already, it is easy to over-promise with a template: we can define templates whose definitions then do not compile in some cases. It would be better to make any restrictions on the template arguments to be a part of the declaration, so let us see how that is done.}{}

\section{Concepts}

% EN: C++20 introduced a major enhancement to the C++ template machinery: concepts.
\Trans{C++20 introduced a major enhancement to the C++ template machinery: concepts.}{}

% EN: In C++20, templates (both class and function templates), as well as non-template functions (members of class templates, usually) may use a constraint to specify the requirements on template arguments. These constraints are useful to produce better error messages, but they are truly indispensable when there is a need to select a function overload or a template specialization based on some properties of template arguments.
\Trans{In C++20, templates (both class and function templates), as well as non-template functions (members of class templates, usually) may use a constraint to specify the requirements on template arguments. These constraints are useful to produce better error messages, but they are truly indispensable when there is a need to select a function overload or a template specialization based on some properties of template arguments.}{}

% EN: The basic syntax for a constraint is quite simple: a constraint is introduced by the keyword \texttt{requires} which can be specified after the function declaration or before the return type (in this book, we use both ways interchangeably so the reader becomes familiar with different styles of writing code). The expression itself usually uses the template parameters and must evaluate to a boolean value, for example:
\Trans{The basic syntax for a constraint is quite simple: a constraint is introduced by the keyword \texttt{requires} which can be specified after the function declaration or before the return type (in this book, we use both ways interchangeably so the reader becomes familiar with different styles of writing code). The expression itself usually uses the template parameters and must evaluate to a boolean value, for example:}{}

\begin{code}
% EN: // Example 13a
template <typename T> T copy(T&& t)
  requires (sizeof(T) > 1)
\Trans{// Example 13a template <typename T> T copy(T&& t) requires (sizeof(T) > 1)}{}

{
% EN:   return std::forward<T>(t);
\Trans{return std::forward<T>(t);}{}
}
\end{code}

% EN: Here the function \texttt{copy()} requires that the type of its argument has a size of at least two bytes. If we attempt to call this function with a \texttt{char} argument, the call will not compile. Note that if a constraint is violated, it is as if the function did not exist for the purposes of a particular call: if there is another overload, it will be considered next even if, without the constraint, the overloads were ambiguous.
\Trans{Here the function \texttt{copy()} requires that the type of its argument has a size of at least two bytes. If we attempt to call this function with a \texttt{char} argument, the call will not compile. Note that if a constraint is violated, it is as if the function did not exist for the purposes of a particular call: if there is another overload, it will be considered next even if, without the constraint, the overloads were ambiguous.}{}

% EN: Here is a more complex (and more useful) example:
\Trans{Here is a more complex (and more useful) example:}{}

\begin{code}
% EN: template <typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
\Trans{template <typename T1, typename T2> std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)}{}

{
% EN:   if (t1 < t2) return std::forward<T1>(t1);
  return std::forward<T2>(t2);
\Trans{if (t1 < t2) return std::forward<T1>(t1); return std::forward<T2>(t2);}{}

}
\end{code}

% EN: This is a function similar to \texttt{std::min}, except it takes two arguments of different types. This creates two potential issues: first, what is the return type? The return value is one of the two arguments, but there has to be a single return type. We can use the \texttt{std::common\_type} trait from the \texttt{\textless{}type\_traits\textgreater{}} header as a reasonable answer: for numeric types, it does the usual type promotion, for classes, it converts from base class to derived class if possible, and it respects implicit user-specified conversions. But there is a second problem: if the expression \texttt{t1\ \textless{}\ t2} does not compile, we get an error in the body of the function. This is unfortunate because the error is hard to analyze and may be misleading: it suggests that the body of the function is implemented incorrectly. We can address the second concern by adding a static assert:
\Trans{This is a function similar to \texttt{std::min}, except it takes two arguments of different types. This creates two potential issues: first, what is the return type? The return value is one of the two arguments, but there has to be a single return type. We can use the \texttt{std::common\_type} trait from the \texttt{\textless{}type\_traits\textgreater{}} header as a reasonable answer: for numeric types, it does the usual type promotion, for classes, it converts from base class to derived class if possible, and it respects implicit user-specified conversions. But there is a second problem: if the expression \texttt{t1\ \textless{}\ t2} does not compile, we get an error in the body of the function. This is unfortunate because the error is hard to analyze and may be misleading: it suggests that the body of the function is implemented incorrectly. We can address the second concern by adding a static assert:}{}

\begin{code}
% EN: static_assert(sizeof(t1 < t2) > 0);
\Trans{static_assert(sizeof(t1 < t2) > 0);}{}
\end{code}

% EN: This at least makes clear that we intended for the code to not compile if there is no matching \texttt{operator\textless{}()}. Note the weird way we had to formulate the assert: the expression \texttt{t1\ \textless{}\ t2} itself must, in general, evaluate at run time, and is just as likely to be false. We need a compile-time value, and we don't care which argument is less, just that they can be compared. So we assert something not about the result of the comparison but about the size of this result: \texttt{sizeof()} is always a compile-time value and the size of anything is at least 1 in C++. The only way this assertion can fail is if the expression does not compile at all.
\Trans{This at least makes clear that we intended for the code to not compile if there is no matching \texttt{operator\textless{}()}. Note the weird way we had to formulate the assert: the expression \texttt{t1\ \textless{}\ t2} itself must, in general, evaluate at run time, and is just as likely to be false. We need a compile-time value, and we don't care which argument is less, just that they can be compared. So we assert something not about the result of the comparison but about the size of this result: \texttt{sizeof()} is always a compile-time value and the size of anything is at least 1 in C++. The only way this assertion can fail is if the expression does not compile at all.}{}

% EN: This still does not solve the other part of the problem: the requirement on the argument types is not included in the interface of the function. The function can be called on any two types and then may or may not compile. With C++20 constraints, we can move the requirement from the implicit (compilation failure) or explicit (static assert) error in the function body to the function declaration and make it part of the function interface:
\Trans{This still does not solve the other part of the problem: the requirement on the argument types is not included in the interface of the function. The function can be called on any two types and then may or may not compile. With C++20 constraints, we can move the requirement from the implicit (compilation failure) or explicit (static assert) error in the function body to the function declaration and make it part of the function interface:}{}

\begin{code}
% EN: // Example 13b
template <typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires (sizeof(t1 < t2) > 0)
\Trans{// Example 13b template <typename T1, typename T2> std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2) requires (sizeof(t1 < t2) > 0)}{}

{
% EN:   if (t1 < t2) return std::forward<T1>(t1);
  return std::forward<T2>(t2);
\Trans{if (t1 < t2) return std::forward<T1>(t1); return std::forward<T2>(t2);}{}

}
\end{code}

% EN: As you learn to build more complex constraints, it is important to remember that the constraint expression must evaluate to a \texttt{bool} value; no conversions whatsoever are permitted, which is why a very similar expression does not work:
\Trans{As you learn to build more complex constraints, it is important to remember that the constraint expression must evaluate to a \texttt{bool} value; no conversions whatsoever are permitted, which is why a very similar expression does not work:}{}

\begin{code}
% EN: template <typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires (sizeof(t1 < t2));
\Trans{template <typename T1, typename T2> std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2) requires (sizeof(t1 < t2));}{}

\end{code}

% EN: The integer value of \texttt{sizeof()} is always non-zero and would have converted to \texttt{true}, but not in this context. The good news is that we don't have to use the \texttt{sizeof()} hack at all to write constraints. There is yet another type of constraint expression, a \emph{requires expression}, that is much more powerful and expresses our intent much clearer:
\Trans{The integer value of \texttt{sizeof()} is always non-zero and would have converted to \texttt{true}, but not in this context. The good news is that we don't have to use the \texttt{sizeof()} hack at all to write constraints. There is yet another type of constraint expression, a \emph{requires expression}, that is much more powerful and expresses our intent much clearer:}{}

\begin{code}
% EN: // Example 13b
template <typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires (requires { t1 < t2;  });
\Trans{// Example 13b template <typename T1, typename T2> std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2) requires (requires { t1 < t2; });}{}

\end{code}

% EN: The requires expression begins with the \texttt{requires} keyword followed by braces \texttt{\{\}}; it can contain any number of expressions that have to compile, or the value of the entire requires expression is false (it does not matter what the results of these expressions are, they just have to be valid C++). You can also use types, type traits, and combinations of requirements of different kinds. By a quirk of the language, the parentheses around the requires expression are optional, which means you can see code like \texttt{requires\ requires\ \{\ t1\ \textless{}\ t2\ \}} where the first and the second \texttt{requires} are completely different keywords.
\Trans{The requires expression begins with the \texttt{requires} keyword followed by braces \texttt{\{\}}; it can contain any number of expressions that have to compile, or the value of the entire requires expression is false (it does not matter what the results of these expressions are, they just have to be valid C++). You can also use types, type traits, and combinations of requirements of different kinds. By a quirk of the language, the parentheses around the requires expression are optional, which means you can see code like \texttt{requires\ requires\ \{\ t1\ \textless{}\ t2\ \}} where the first and the second \texttt{requires} are completely different keywords.}{}

% EN: The requirements on template types can be quite complex; often, the same requirements apply in many different templates. Sets of such requirements can be given names and defined for later use; these named requirements are called concepts. Each concept is a condition that is evaluated at compile time when used in a constraint.
\Trans{The requirements on template types can be quite complex; often, the same requirements apply in many different templates. Sets of such requirements can be given names and defined for later use; these named requirements are called concepts. Each concept is a condition that is evaluated at compile time when used in a constraint.}{}

% EN: The syntax for a constraint is similar to a template:
\Trans{The syntax for a constraint is similar to a template:}{}

\begin{code}
% EN: // Example 13c
template <typename T1, typename T2> concept Comparable =
  requires(T1 t1, T2 t2) { t1 < t2;  };
\Trans{// Example 13c template <typename T1, typename T2> concept Comparable = requires(T1 t1, T2 t2) { t1 < t2; };}{}

\end{code}

% EN: We are not going to cover the syntax in detail in this book -- for that, use a reference source such as cppreference.com. A concept can be used instead of the requirement it contains:
\Trans{We are not going to cover the syntax in detail in this book -- for that, use a reference source such as cppreference.com. A concept can be used instead of the requirement it contains:}{}

\begin{code}
% EN: template <typename T1, typename T2>
std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)
  requires Comparable<T1, T2>;
\Trans{template <typename T1, typename T2> std::common_type_t<T1, T2> min2(T1&& t1, T2&& t2) requires Comparable<T1, T2>;}{}

\end{code}

% EN: Concepts that constrain a single type can also be used as template parameter placeholders. Let us consider an example of a \texttt{swap()} function. For integral types, there is a trick that allows us to swap two values without using a temporary variable. It relies on the properties of a bitwise XOR operation. Let us assume, for the purposes of this demonstration, that, on a particular hardware, this version is faster than the usual way of implementing swap. We would like to write a swap template function \texttt{MySwap(T\&\ a,\ T\&\ b)} that automatically detects whether the type T supports an XOR operation and use it, if available; otherwise we fall back on the usual swap.
\Trans{Concepts that constrain a single type can also be used as template parameter placeholders. Let us consider an example of a \texttt{swap()} function. For integral types, there is a trick that allows us to swap two values without using a temporary variable. It relies on the properties of a bitwise XOR operation. Let us assume, for the purposes of this demonstration, that, on a particular hardware, this version is faster than the usual way of implementing swap. We would like to write a swap template function \texttt{MySwap(T\&\ a,\ T\&\ b)} that automatically detects whether the type T supports an XOR operation and use it, if available; otherwise we fall back on the usual swap.}{}

% EN: First, we need a concept for a type that supports XOR:
\Trans{First, we need a concept for a type that supports XOR:}{}

\begin{code}
% EN: // Example 14a,b
template <typename T> concept HasXOR =
  requires(T a, T b) { a ^ b;  };
\Trans{// Example 14a,b template <typename T> concept HasXOR = requires(T a, T b) { a ^ b; };}{}

\end{code}

% EN: The concept has a requires expression; every expression inside the curly braces must compile, otherwise, the requirement of the concept is not met.
\Trans{The concept has a requires expression; every expression inside the curly braces must compile, otherwise, the requirement of the concept is not met.}{}

% EN: Now, we can implement an XOR-based swap template. We could do it with a \texttt{requires} constraint, but there is a more compact way:
\Trans{Now, we can implement an XOR-based swap template. We could do it with a \texttt{requires} constraint, but there is a more compact way:}{}

\begin{code}
% EN: template <HasXOR T> void MySwap(T& x, T& y) {
     x = x ^ y;
     y = x ^ y;
     x = x ^ y;
\Trans{template <HasXOR T> void MySwap(T& x, T& y) { x = x ^ y; y = x ^ y; x = x ^ y;}{}

}
\end{code}

% EN: The concept name \texttt{HasXOR} can be used instead of the \texttt{typename} keyword to declare the template parameter. This restricts our \texttt{MySwap()} function to the types that have \texttt{operator\^{}()}. But we need a general case overload, too. We should also note that \emph{general} does not mean \emph{any} in our case: the type has to support move assignment and move construction. We need another concept:
\Trans{The concept name \texttt{HasXOR} can be used instead of the \texttt{typename} keyword to declare the template parameter. This restricts our \texttt{MySwap()} function to the types that have \texttt{operator\^{}()}. But we need a general case overload, too. We should also note that \emph{general} does not mean \emph{any} in our case: the type has to support move assignment and move construction. We need another concept:}{}

\begin{code}
% EN: template <typename T> concept Assignable =
  requires(T a, T b) {
    T(std::move(b));
    b = std::move(a);
   };
\Trans{template <typename T> concept Assignable = requires(T a, T b) { T(std::move(b)); b = std::move(a); };}{}

\end{code}

% EN: This is a very similar concept, except we have two expressions; both must be valid for the concept to be true.
\Trans{This is a very similar concept, except we have two expressions; both must be valid for the concept to be true.}{}

% EN: The second \texttt{MySwap()} overload accepts all \texttt{Assignable} types. However, we must explicitly exclude the types with XOR, or we will have ambiguous overloads. This is a perfect example to show that we can combine concepts as template placeholders with concepts in requirements:
\Trans{The second \texttt{MySwap()} overload accepts all \texttt{Assignable} types. However, we must explicitly exclude the types with XOR, or we will have ambiguous overloads. This is a perfect example to show that we can combine concepts as template placeholders with concepts in requirements:}{}

\begin{code}
% EN: template <Assignable T> void MySwap(T& x, T& y)
  requires (!HasXOR<T>)
\Trans{template <Assignable T> void MySwap(T& x, T& y) requires (!HasXOR<T>)}{}

{
% EN:   T tmp(std::move(x));
  x = std::move(y);
  y = std::move(tmp);
\Trans{T tmp(std::move(x)); x = std::move(y); y = std::move(tmp);}{}

}
\end{code}

% EN: Now a call to \texttt{MySwap()} will select the XOR-based overload if possible, otherwise, it will use the general overload (swapping non-assignable types will not compile at all).
\Trans{Now a call to \texttt{MySwap()} will select the XOR-based overload if possible, otherwise, it will use the general overload (swapping non-assignable types will not compile at all).}{}

% EN: Finally, let us return to one of the first examples in this chapter: that of a class template \texttt{ArrayOf2} in the section ``\emph{Class templates}.'' Recall that it has a member function sum() which has much more strict requirements on the template type than the rest of the class: it adds the values of the array elements. If the elements do not have \texttt{operator+()}, there is no problem as long as we don't call \texttt{sum()}, but if we do, we get a syntax error. It would have been better if this function was not a part of the class interface at all unless the type supports it. We can accomplish this with a constraint:
\Trans{Finally, let us return to one of the first examples in this chapter: that of a class template \texttt{ArrayOf2} in the section ``\emph{Class templates}.'' Recall that it has a member function sum() which has much more strict requirements on the template type than the rest of the class: it adds the values of the array elements. If the elements do not have \texttt{operator+()}, there is no problem as long as we don't call \texttt{sum()}, but if we do, we get a syntax error. It would have been better if this function was not a part of the class interface at all unless the type supports it. We can accomplish this with a constraint:}{}

\begin{code}
% EN: // Example 15
template <typename T> class ArrayOf2 {
  public:
  T& operator[](size_t i) { return a_[i];  }
  const T& operator[](size_t i) const { return a_[i];  }
  T sum() const requires (requires (T a, T b) { a + b;  }) {
    return a_[0] + a_[1];
   }
  private:
  T a_[2];
 };
\Trans{// Example 15 template <typename T> class ArrayOf2 { public: T& operator[](size_t i) { return a_[i]; } const T& operator[](size_t i) const { return a_[i]; } T sum() const requires (requires (T a, T b) { a + b; }) { return a_[0] + a_[1]; } private: T a_[2]; };}{}

\end{code}

% EN: If the expression \texttt{a\ +\ b} does not compile, the code behaves as if there was no member function \texttt{sum()} declared in the class interface. Of course, we could also use a named concept for this.
\Trans{If the expression \texttt{a\ +\ b} does not compile, the code behaves as if there was no member function \texttt{sum()} declared in the class interface. Of course, we could also use a named concept for this.}{}

% EN: We will see more ways to manage requirements on template parameters in \emph{Chapter 7}. For now, let us review what we have learned and go on to use these tools to solve common C++ problems.
\Trans{We will see more ways to manage requirements on template parameters in \emph{Chapter 7}. For now, let us review what we have learned and go on to use these tools to solve common C++ problems.}{}

\section{Summary}

% EN: Templates, variadic templates, and lambda expressions are all powerful features of C++, offering simplicity in use, but are rich in complex details. The examples in this chapter should serve to prepare the reader for the later chapters of this book, where we use these techniques to implement design patterns, both classic and novel, with the tools of the modern C++ language. The reader wishing to learn the art of using these complex and powerful tools to their fullest potential is referred to other books that are dedicated to teaching these subjects, some of which can be found at the end of this chapter.
\Trans{Templates, variadic templates, and lambda expressions are all powerful features of C++, offering simplicity in use, but are rich in complex details. The examples in this chapter should serve to prepare the reader for the later chapters of this book, where we use these techniques to implement design patterns, both classic and novel, with the tools of the modern C++ language. The reader wishing to learn the art of using these complex and powerful tools to their fullest potential is referred to other books that are dedicated to teaching these subjects, some of which can be found at the end of this chapter.}{}

% EN: The reader is now ready to learn common C++ idioms, starting with idioms for expressing memory ownership, in the next chapter.
\Trans{The reader is now ready to learn common C++ idioms, starting with idioms for expressing memory ownership, in the next chapter.}{}

\section{Questions}

\begin{enumerate}
\item
% EN:   What is the difference between a type and a template?
\Trans{What is the difference between a type and a template?}{}
\item
% EN:   What kind of templates does C++ have?
\Trans{What kind of templates does C++ have?}{}
\item
% EN:   What kinds of template parameters do C++ templates have?
\Trans{What kinds of template parameters do C++ templates have?}{}
\item
% EN:   What is the difference between a template specialization and a template instantiation?
\Trans{What is the difference between a template specialization and a template instantiation?}{}
\item
% EN:   How can you access the parameter pack of a variadic template?
\Trans{How can you access the parameter pack of a variadic template?}{}
\item
% EN:   What are lambda expressions used for?
\Trans{What are lambda expressions used for?}{}
\item
% EN:   How do concepts refine template interfaces?
\Trans{How do concepts refine template interfaces?}{}
\end{enumerate}

\section{Further reading}

\begin{itemize}
\item
  \emph{C++} \emph{Fundamentals}: https://www.packtpub.com/product/c-fundamentals
\item
  \emph{C++ Data Structures and} \emph{Algorithms}: https://www.packtpub.com/product/c-data-structures-and-algorithms
\item
  \emph{Mastering C++} \emph{Programming}: https://www.packtpub.com/product/mastering-c-programming
\end{itemize}


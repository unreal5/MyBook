\part{Getting Started with C++ Features and Concepts}

This part introduces and explains the features of C++ object-oriented programming, generic programming, and some of the other advanced language tools that are necessary for you to understand the rest of the book. We also discuss some of the more annoying limitations imposed by the language: many of the patterns we show in the later chapters are nothing but universally recognized solutions to these limitations. This is not meant as a complete guide for any of the features, but helps make the book more self-contained as a hands-on guide for programmers. This part has the following chapters:

\begin{itemize}
\item
  \emph{Chapter 1, An Introduction to Inheritance and Polymorphism}
\item
  \emph{Chapter 2, Class and Function Templates}
\item
  \emph{Chapter 3, Memory and Ownership}
\end{itemize}

\input{./chapters_eng/01-An_Introduction_to_Inheritance_and_Polymorphism.tex}
\input{./chapters_eng/02-Class_and_Function_Templates.tex}
\input{./chapters_eng/03-Memory_and_Ownership.tex}

\part{Common C++ Idioms}

This part describes some of the more common C++ idioms: established, universally recognized ways to express a specific idea or implement a frequently needed task. The boundary between ``patterns'' and ``idioms'' is fuzzy at best. In this book, we consider more complete design solutions to be patterns, while simpler techniques are idioms. In other words, choosing a pattern may influence the design of your entire application or its major component, while using an idiom is more of an implementation decision that has been learned from someone else's mistakes.

This part has the following chapters:

\begin{itemize}
\item
  \emph{Chapter 4, Swap - From Simple to Subtle}
\item
  \emph{Chapter 5, A Comprehensive Look at RAII}
\item
  \emph{Chapter 6, Understanding Type Erasure}
\item
  \emph{Chapter 7, SFINAE, Concepts, and Overload Resolution Management}
\end{itemize}



\part{C++ Design Patterns}

This part begins with the main portion of the book. It introduces the most important, frequently used C++ design patterns. Each pattern is generally used as a commonly accepted approach to solving a certain type of problem. Exactly what the problem is, varies a great deal: some are system architecture challenges, others are interface design problems, yet others deal with program performance.

This part has the following chapters:

\begin{itemize}
\item
  \emph{Chapter 8, The Curiously Recurring Template Pattern}
\item
  \emph{Chapter 9, Named Arguments, Method Chaining, and Builder Pattern}
\item
  \emph{Chapter 10, Local Buffer Optimization}
\item
  \emph{Chapter 11, Scopeguard}
\item
  \emph{Chapter 12, Friend Factory}
\item
  \emph{Chapter 13, Virtual Constructors and Factories}
\item
  \emph{Chapter 14, The Template Method Pattern and the Non-Virtual Idiom}
\end{itemize}


\part{Advanced C++ Design Patterns}

This part continues with the description and detailed explanation of C++ design patterns, moving on to the more advanced patterns. Some of these patterns use advanced features of the C++ language. Others represent complex concepts and address more difficult design problems. Yet other patterns implement very open-ended designs, where part of the solution can be factored out into a commonly accepted pattern, but the entire system must be customizable within very wide limits.

This part has the following chapters:

\begin{itemize}
\item
  \emph{Chapter 15, Policy-Based Design}
\item
  \emph{Chapter 16, Adapters and Decorators}
\item
  \emph{Chapter 17, The Visitor Pattern and Multiple Dispatch}
\item
  \emph{Chapter 18, Patterns for Concurrency}
\end{itemize}

\input{./chapters_eng/17-The_Visitor_Pattern_and_Multiple_Dispatch.tex}
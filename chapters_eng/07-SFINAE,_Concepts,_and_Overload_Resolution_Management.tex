\chapter{SFINAE, Concepts, and Overload Resolution Management}

The idiom we study in this chapter, \textbf{Substitution Failure Is Not An Error} (\textbf{SFINAE}), is one of the more complex in terms of the language features it uses. Thus, it tends to get inordinate amounts of attention from C++ programmers. There is something in this feature that appeals to the mindset of a typical C++ programmer - a normal person thinks that, if it isn't broken, don't mess with it. A programmer, especially one writing in C++, tends to think that, if it isn't broken, you're not using it to its full potential. Let's just say that SFINAE has a lot of potential.

We will cover the following topics in this chapter:

\begin{itemize}
\item
  What are function overloading and overload resolution? What are type deduction and substitution?
\item
  What is SFINAE, and why was it necessary in C++?
\item
  How can SFINAE be used to write insanely complex, and sometimes useful, programs?
\end{itemize}

\section{Technical requirements}

The example code for this chapter can be found at https://github.com/PacktPublishing/ Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07.

\section{Overload resolution and overload sets}

This section will test your knowledge of the latest and most advanced additions to the C++ standard. We will start with one of the most basic features of C++, functions, and their overloads.

\subsection{C++ function overloading}

\textbf{Function overloading} is a very straightforward concept in C++; multiple different functions can have the same name. That's it, that is all there is to overloading - when the compiler sees syntax that indicates a function call, formatted as \texttt{f(x)}, then there must be more than one function named \texttt{f}. If this happens, we are in an overload situation, and overload resolution must take place to find out which of these functions should be called.

Let's start with a simple example:

\begin{code}
// Example 01
void f(int i) { cout << 鈥渇(int)鈥?<< endl; }        // 1
void f(long i) { cout << 鈥渇(long)鈥?<< endl; }    // 2
void f(double i) { cout << 鈥渇(double)鈥?<< endl; }    // 3
f(5);        // 1
f(5l);    // 2
f(5.0);    // 3
\end{code}

Here, we have three function definitions for the same name, \texttt{f}, and three function calls. Note that the function signatures are all different (in that the parameter types are different). This is a requirement - overloaded functions must differ somehow in their parameters. It is not possible to have two overloads that take the exact same arguments but differ in the return type or the function body. Also, note that, while the example is for a regular function, the exact same rules apply to the overloaded member functions, so we will not pay special attention to member functions exclusively.

Back to our example, which of the \texttt{f()} functions is called on each line? To understand that, we need to know how overloaded functions are resolved in C++. The exact rules for overload resolution are fairly complex and differ in subtle ways between different versions of the standard, but for the most part, they are designed so that the compiler does what you would expect it to do in the most commonly encountered cases. We would expect \texttt{f(5)} to call the overload that accepts an integer argument since \texttt{5} is an \texttt{int} variable. And so it does. Similarly, \texttt{5l} has the long type, and so \texttt{f(5l)} calls the second overload. Finally, \texttt{5.0} is a floating-point number, and so the last overload is called.

That wasn't so hard, was it? But what happens if the argument does not match the parameter type exactly? Then, the compiler has to consider type conversions. For example, the type of the \texttt{5.0} literal is \texttt{double}. Let's see what happens if we call \texttt{f()} with an argument of the \texttt{float} type:

\begin{code}
f(5.0f);
\end{code}

Now we have to convert the argument from the \texttt{float} type to one of the \texttt{int}, \texttt{long}, or \texttt{double} types. Again, the standard has rules, but it should come as no surprise that the conversion to \texttt{double} is preferred and that the overload is called.

Let's see what happens with a different integer type, say, \texttt{unsigned} \texttt{int}:

\begin{code}
f(5u);
\end{code}

Now we have two options; convert \texttt{unsigned} \texttt{int} to a \texttt{signed} \texttt{int}, or to \texttt{signed} \texttt{long}. While it may be argued that the conversion to \texttt{long} is \emph{safer}, and thus better, the two conversions are considered so close by the standard that the compiler cannot choose. This call does not compile because the overload resolution is considered ambiguous; the error message should say as much. If you encounter such a problem in your code, you have to help the compiler by casting the arguments to a type that makes the resolution unambiguous. Usually, the simplest way is to cast the type of the parameter for the overload you want to call:

\begin{code}
unsigned int i = 5u;
f(static_cast<int>(i));
\end{code}

So far, we have dealt with a situation where the types of parameters were different, but their number was the same. Of course, if the number of parameters differs between different function declarations for the same name, only the functions that can accept the required number of arguments need to be considered. Here is an example of two functions with the same name but a different number of arguments:

\begin{code}
void f(int i) { cout << 鈥渇(int)鈥?<< endl; }            // 1
void f(long i, long j) { cout << 鈥渇(long2)鈥?<< endl; }    // 2
f(5.0, 7);
\end{code}

Here, the overload resolution is very simple - we need a function that can accept two arguments, and there is only one choice. Both arguments will have to be converted to \texttt{long}. But what if there is more than one function with the same number of parameters? Let's see what happens in the following example:

\begin{code}
// Example 02
void f(int i, int j) { cout << 鈥渇(int, int)鈥?<< endl; }// 1
void f(long i, long j) { cout << 鈥渇(long2)鈥?<< endl; }    // 2
void f(double i) { cout << 鈥渇(double)鈥?<< endl; }      // 3
f(5, 5);    // 1
f(5l, 5l);    // 2
f(5, 5.0);    // 1
f(5, 5l);    // ?
\end{code}

First of all, the obvious case - if the types of all arguments match exactly the types of the parameters for one of the overloads, that overload is called. Next, things start to get interesting - if there is no exact match, we can have conversions on each argument. Let's consider the third call, \texttt{f(5,\ 5.0)}. The first argument, \texttt{int}, matches the first overload exactly but could be converted to \texttt{long} if necessary. The second argument, \texttt{double}, does not match either overload but could be converted to match both. The first overload is a better match - it requires fewer argument conversions. Finally, what about the last line? The first overload can be called, with a conversion on the second argument. The second overload can also be made to work, with a conversion on the first argument. Again, this is an ambiguous overload, and this line will not compile. Note that it is not, in general, true that the overload with the fewer conversions always wins; in more complex cases, it is possible to have ambiguous overloads even if one requires fewer conversions (the general rule is, if there is an overload that has the best conversion on every argument, it wins; otherwise, the call is ambiguous). To resolve this ambiguity, you have to change the types of some of the arguments (by casting, in general, or by changing the type of the numeric literal, in our case) to make the intended overload be the preferred one.

Note how the third overload was completely left out because it has the wrong number of parameters for all function calls. It's not always that simple, though - functions can have default arguments, which means the number of arguments does not always have to match the number of parameters.

Consider the following code block:

\begin{code}
// Example 03
void f(int i) { cout << 鈥渇(int)鈥?<< endl; }            // 1
void f(long i, long j) { cout << 鈥渇(long2)鈥?<< endl; }    // 2
void f(double i, double j = 0) {                    // 3
  cout << 鈥渇(double, double = 0)鈥?<< endl;
}
f(5);        // 1
f(5l, 5);    // 2
f(5, 5);    // ?
f(5.0);    // 3
f(5.0f);    // 3
f(5l);    // ?
\end{code}

We now have three overloads. The first and the second can never be confused because they have a different number of parameters. The third overload, however, can be called with either one or two arguments; in the former case, the second argument is assumed to be zero. The first call is the simplest - one argument, where the type matches the parameter type of the first overload exactly. The second call reminds us of the case we have seen before - two arguments, where the first is an exact match to one of the overloads, but the second requires a conversion. The alternative overload needs conversions on both arguments, so the second function definition is the best match.

The third call seems straightforward enough with its two integer arguments, but this simplicity is deceptive - there are two overloads that accept two arguments, and in both overload cases, both arguments need conversions. While the conversion from \texttt{int} to \texttt{long} may seem better than the one from \texttt{int} to \texttt{double}, C++ does not see it this way. This call is ambiguous. The next call, \texttt{f(5.0)}, has only one argument, which can be converted to \texttt{int}, the type of the parameter in the one-argument overload. But it is still a better match for the third overload, where it needs no conversion at all. Change the argument type from \texttt{double} to \texttt{float}, and we get the next call. The conversion to \texttt{double} is better than that to \texttt{int}, and utilizing the default argument is not considered a conversion and so does not carry any other \emph{penalty} when overloads are compared. The last call is again ambiguous - both conversions to \texttt{double} and to \texttt{int} are considered of equal weight, thus the first and third overloads are equally good. The second overload offers an exact match to the first parameter; however, there is no way to call that overload without the second argument, so it is not even considered.

So far, we have considered only ordinary C++ functions, although everything we have learned applies equally to member functions as well. Now, we need to add template functions to the mix.

\subsection{Template functions}

In addition to regular functions, for which the parameter types are known, C++ also has \texttt{template} functions. When these functions are called, the parameter types are deduced from the types of the arguments at the call site. The template functions can have the same name as non-template functions, and several template functions can have the same name as well, so we need to learn about overload resolution in the presence of templates.

Consider the following example:

\begin{code}
// Example 04
void f(int i) { cout << 鈥渇(int)鈥?<< endl; }        // 1
void f(long i) { cout << 鈥渇(long)鈥?<< endl; }    // 2
template <typename T>
void f(T i) { cout << 鈥渇(T)鈥?<< endl; }        // 3
f(5);        // 1
f(5l);    // 2
f(5.0);    // 3
\end{code}

The \texttt{f} function name can refer to any of the three functions, one of which is a template. The best overload will be chosen from these three each time. The set of functions that are considered for the overload resolution of a particular function call is known as the \textbf{overload set}. The first call to \texttt{f()} matches exactly the first non-template function in the overload set - the argument type is \texttt{int}, and the first function is \texttt{f(int)}. If an exact match to a non-template function is found in the overload set, it is always considered the best overload.

The template function can also be instantiated with an exact match - the process of replacing template parameters with concrete types is known as template argument substitution (or type substitution), and, if \texttt{int} is substituted for the \texttt{T} template parameter, then we arrive at another function that exactly matches the call. However, a non-template function that matches exactly is considered a better overload. The second call is processed similarly, but it is an exact match to the second function in the overload set, so that is the function that will be called. The last call has an argument of the \texttt{double} type that can be converted to \texttt{int} or \texttt{long}, or substituted for \texttt{T} to make the template instantiation an exact match. Since there is no exactly matching non-template function, the template function instantiated to an exact match is the next best overload and is selected.

But what happens when there are multiple template functions that can have their template parameters substituted to match the argument types of the call? Let's find out:

\begin{code}
// Example 05
void f(int i) { cout << 鈥渇(int)鈥?<< endl; }    // 1
template <typename T>
void f(T i) { cout << 鈥渇(T)鈥?<< endl; }    // 2
template <typename T>
void f(T* i) { cout << 鈥渇(T*)鈥?<< endl; }    // 3
f(5);        // 1
f(5l);    // 2
int i = 0;
f(&i);    // 3
\end{code}

The first call is again an exact match to the non-template function, and so is resolved. The second call matches the first, non-template, overload, with a conversion, or the second overload exactly if the right type, \texttt{long}, is substituted for \texttt{T}. The last overload does not match either of these calls - there is no substitution that would make the \texttt{T*} parameter type match either \texttt{int} or \texttt{long}. The last call, however, can be matched to the third overload if \texttt{int} is substituted for \texttt{T}. The problem is that it could also match the second overload if \texttt{int*} were substituted for \texttt{T}. So which template overload is chosen? The answer is the more specific one - the first overload, \texttt{f(T)}, can be made to match any one-argument function call, while the second overload, \texttt{f(T*)}, can only match calls with pointer arguments. The more specific, narrower overload is considered a better match and is selected. This is a new notion, specific to templates - instead of choosing better conversions (in general, \emph{fewer} or \emph{simpler} conversions), we select the overload that is \emph{harder} to instantiate.

This rule seemingly breaks for null pointers: \texttt{f(NULL)} can call either the first or the second overload (\texttt{f(int)} or \texttt{f(T)}), and \texttt{f(nullptr)} call the second overload, \texttt{f(T)}. The pointer overload is never called, even though both \texttt{NULL} and \texttt{nullptr} are supposedly null pointers. However, this is actually the case of the compiler strictly following the rules. \texttt{NULL} in C++ is an integer zero, it's actually a macro:

\begin{code}
#define NULL 0 // Or 0L
\end{code}

Depending on whether it is defined as \texttt{0} or \texttt{0L}, \texttt{f(int)} or \texttt{f(T)} with \texttt{T==long} are called. The constant \texttt{nullptr}, despite having ``ptr'' in its name, is actually a constant value of type \texttt{nullptr\_t}. It is \emph{convertible} to any pointer type but it is not of any pointer type. This is why, when dealing with functions accepting pointers of different types, an overload with a \texttt{nullptr\_t} parameter is often declared.

Finally, there is one more kind of function that can match just about any function call with the same name, and that is the function that takes variable arguments:

\begin{code}
// Example 06
void f(int i) { cout << 鈥渇(int)鈥?<< endl; }    // 1
void f(...) { cout << 鈥渇(...)鈥?<< endl; }    // 2
f(5);        // 1
f(5l);    // 1
f(5.0);    // 1
struct A {};
A a;
f(a);    {};    // 2
\end{code}

The first of the overloads can be used for the first three function calls - it is an exact match for the first call, and conversions exist to make the other two calls fit the signature of the first overload for \texttt{f()}. The second function in this example can be called with any number of arguments of any type. This is considered the choice of last resort - a function with specific arguments that can be made to match the call with the right conversions is preferred. This includes user-defined conversions, as follows:

\begin{code}
struct B {
  operator int() const { return 0; }
};
B b;
f(b);        // 1
\end{code}

Only if there are no conversions that allow us to avoid calling the \texttt{f(...)} variadic function, then it has to be called.

Now we know the order of the overload resolution - first, a non-template function that matches the arguments exactly is chosen. If there is no such match in the overload set, then a template function is chosen if its parameters can be substituted with concrete types in a way that gives an exact match. If there is more than one option for such a template function, then a more specific overload is preferred over the more general one. If the attempt to match a template function in this manner also fails, then a non-template function is called if the arguments can be converted to its parameter types. Finally, if everything else fails, but a function with the right name that takes variable arguments is available, then that function is called. Note that certain conversions are considered \emph{trivial} and are included in the notion of the \emph{exact} match, for example, the conversion from \texttt{T} to \texttt{const} \texttt{T}. At every step, if there is more than one equally good option, the overload is considered ambiguous and the program is ill-formed.

The process of type substitution in a template function is what determines the final types of the template function parameters, and how good a match they are to the arguments of the function call. This process can lead to somewhat unexpected results and must be considered in more detail.

\section{Type substitution in template functions}

We must carefully differentiate between the two steps in instantiating a template function to match a particular call - first, the types of the template parameters are deduced from the argument types (a process referred to as type deduction). Once the types are deduced, the concrete types are substituted for all parameter types (this is a process called \textbf{type substitution}). The difference becomes more obvious when the function has multiple parameters.

\subsection{Type deduction and substitution}

Type deduction and substitution are closely related, but not exactly the same. The deduction is the process of ``\emph{guessing:''} what should the template type, or types, be in order to match the call? Of course, the compiler does not really guess but applies a set of rules defined in the standard. Consider the following example:

\begin{code}
// Example 07
template <typename T>
void f(T i, T* p) { std::cout << 鈥渇(T, T*)鈥?<< std::endl; }
int i;
f(5, &i);    // T == int
f(5l, &i);    // ?
\end{code}

When considering the first call, we can deduce from the first argument that the \texttt{T} template parameter should be \texttt{int}. Thus, \texttt{int} is substituted for \texttt{T} in both parameters of the function. The template is instantiated as \texttt{f(int,\ int*)} and is an exact match for the argument types. When considering the second call, we could deduce that \texttt{T} should be \texttt{long} from the first argument. Alternatively, we could deduce that \texttt{T} should be \texttt{int} from the second argument. This ambiguity leads to the failure of the type deduction process. If this is the only overload available, neither option is chosen, and the program does not compile. If more overloads exist, they are considered in turn, including possibly the overload of last resort, the \texttt{f(...)} variadic function. One important detail to note here is that conversions are not considered when deducing template types - the deduction of \texttt{T} as \texttt{int} would have yielded \texttt{f(int,\ int*)} for the second call, which is a viable option for calling \texttt{f(long,\ int*)} with the conversion of the first argument. However, this option is not considered at all, and instead, type deduction fails as ambiguous.

The ambiguous deduction can be resolved by explicitly specifying the template types, which removes the need for type deduction:

\begin{code}
f<int>(5l, &i);    // T == int
\end{code}

Now, type deduction is not done at all: we know what \texttt{T} is from the function call, as it is explicitly specified. Type substitution, on the other hand, still has to happen - the first parameter is of the \texttt{int} type, and the second is of the \texttt{int*} type. The function call succeeds with a conversion on the first argument. We could also force deduction the other way:

\begin{code}
f<long>(5l, &i);    // T == long
\end{code}

Again, deduction is not necessary, as we know what \texttt{T} is. Substitution proceeds in a straightforward way, and we end up with \texttt{f(long,\ long*)}. This function cannot be called with \texttt{int*} as the second argument since there is no valid conversion from \texttt{int*} to \texttt{long*}. Thus, the program does not compile. Note that, by explicitly specifying the types, we have also specified that \texttt{f()} must be a template function. The non-template overloads for \texttt{f()} are no longer considered. On the other hand, if there is more than one \texttt{f()} template function, then these overloads are considered as usual, but this time with the results of the argument deduction forced by our explicit specification.

Template functions can have default arguments, just like non-template functions, however, the values of these arguments are not used to deduce types (in C++11, template functions can have default values for their type parameters, which provides an alternative). Consider the following example:

\begin{code}
// Example 08
void f(int i, int j = 1) {                      // 1
  cout << 鈥渇(int2)鈥?<< endl;
}
template <typename T> void f(T i, T* p = nullptr) {    // 2
  cout << 鈥渇(T, T*)鈥?<< endl;
}
int i;
f(5);        // 1
f(5l);    // 2
\end{code}

The first call is an exact match to the \texttt{f(int,} \texttt{int)} non-template function, with the default value of \texttt{1} for the second argument. Note that it would have made no difference if we had declared the function as \texttt{f(int\ i,\ int\ j\ =\ 1L)}, with the default value as \texttt{long}. The type of the default argument does not matter - if it can be converted to the specified parameter type, then that's the value that is used, otherwise, the program would not compile from line 1. The second call is an exact match to the \texttt{f(T,\ T*)} template function, with \texttt{T\ ==\ long} and the default value of \texttt{NULL} for the second argument. Again, it does not matter at all that the type of that value is not \texttt{long*}.

We now understand the difference between type deduction and type substitution. Type deduction can be ambiguous when different concrete types can be deduced from different arguments. If this happens, it means we have failed to deduce the argument types and cannot use this template function. Type substitution is never ambiguous - once we know what \texttt{T} is, we simply substitute that type every time we see \texttt{T} in the function definition. This process can also fail, but in a different way.

\subsection{Substitution failure}

Once we have deduced the template parameter types, type substitution is a purely mechanical process:

\begin{code}
// Example 09
template <typename T> T* f(T i, T& j) {
  j = 2*i;
  return new T(i);
}
int i = 5, j = 7;
const int* p = f(i, j);
\end{code}

In this example, the \texttt{T} type can be deduced from the first argument as \texttt{int}. It can also be deduced from the second argument, also as \texttt{int}. Note that the return type is not used for type deduction. Since there is only one possible deduction for \texttt{T}, we now proceed to substitute \texttt{T} with \texttt{int} every time we see \texttt{T} in the function definition:

\begin{code}
int* f(int i, int& j) {
  j = 2*i;
  return new int(i);
}
\end{code}

Not all types, however, are created equal, and some allow more liberties than others. Consider this code:

\begin{code}
// Example 10
template <typename T>
void f(T i, typename T::t& j) {
  std::cout << 鈥渇(T, T::t)鈥?<< std::endl;
}
template <typename T>
void f(T i, T j) {
  std::cout << 鈥渇(T, T)鈥?<< std::endl;
}
struct A {
struct t { int i; }; t i; };
A a{5};
f(a, a.i);    // T == A
f(5, 7);    // T == int
\end{code}

When considering the first call, the compiler deduces the \texttt{T} template parameter as being of the \texttt{A} type, from both the first and second argument - the first argument is a value of the \texttt{A} type, and the second one is a reference to the value of the \texttt{A::t} nested type, which matches \texttt{T::t} if we stick with our original deduction of \texttt{T} as \texttt{A}. The second overload yields conflicting values for \texttt{T} from the two arguments and, therefore, cannot be used. Thus, the first overload is called.

Now, look closely at the second call. The \texttt{T} type can be deduced as \texttt{int} from the first argument for both overloads. Substituting \texttt{int} for \texttt{T}, however, yields something strange in the second argument of the first overload - \texttt{int::t}. This, of course, would not compile - \texttt{int} is not a class and does not have any nested types. In fact, we could expect that the first template overload will fail to compile for every \texttt{T} type that is not a class, or that does not have a nested type called \texttt{t}. Indeed, the attempt to substitute \texttt{int} for \texttt{T} in the first template function fails with an invalid type for the second argument. However, this substitution failure does not mean that the entire program cannot compile. Instead, it is silently ignored, and the overload that would otherwise be ill-formed is removed from the overload set. The overload resolution then continues as usual. Of course, we could discover that none of the overloads match the function call, and the program will still not compile, but the error message will not mention anything about \texttt{int::t} being invalid; it'll just say that there are no functions that can be called.

Again, it is important to differentiate between type deduction failure and type substitution failure. We can remove the former from consideration entirely:

\begin{code}
f<int>(5, 7);    // T == int
\end{code}

Now, the deduction is unnecessary, but the substitution of \texttt{int} for \texttt{T} must still take place, and this substitution yields an invalid expression in the first overload. Again, this substitution failure drops this candidate for \texttt{f()} from the overload set, and the overload resolution continues (in this case, successfully) with the remaining candidates. Ordinarily, this would be the end of our exercise in overloading: the template produces code that can't compile, so the entire program should not compile either. Fortunately, C++ is more forgiving in this one situation and has a special exception that we need to know about.

\subsection{Substitution Failure Is Not An Error}

The rule that a substitution failure arising from an expression that would be invalid with the specified or deduced types does not make the whole program invalid is known as \textbf{Substitution Failure Is Not An Error} (\textbf{SFINAE}). This rule is essential for using template functions in C++; without SFINAE, it would be impossible to write many otherwise perfectly valid programs. Consider the following template overload, which differentiates between regular pointers and member pointers:

\begin{code}
// Example 11
template <typename T> void f(T* i) {        // 1
  std::cout << 鈥渇(T*)鈥?<< std::endl;
}
template <typename T> void f(int T::* p) {    // 2
  std::cout << 鈥渇(T::*)鈥?<< std::endl;
}
struct A { int i; };
A a;
f(&a.i);    // 1
f(&A::i);    // 2
\end{code}

So far, so good - the first time, the function is called with a pointer to a specific variable, \texttt{a.i}, and the \texttt{T} type is deduced as \texttt{int}. The second call is with a pointer to a data member of the \texttt{A} class, where \texttt{T} is deduced as \texttt{A}. But now, let's call \texttt{f()} with a pointer to a different type:

\begin{code}
int i;
f(&i);    // 1
\end{code}

The first overload still works fine and is what we want to call. But the second overload isn't just less suitable, it is altogether invalid - it would cause a syntax error if we tried to substitute \texttt{int} for \texttt{T}. This syntax error is observed by the compiler and silently ignored, together with the overload itself.

Note that the SFINAE rule is not limited to invalid types, such as references to non-existing class members. There are many ways in which substitution can fail:

\begin{code}
// Example 12
template <size_t N>
void f(char(*)[N % 2] = nullptr) {    // 1
  std::cout << 鈥淣=鈥?<< N << 鈥?is odd鈥?<< std::endl;
}
template <size_t N>
void f(char(*)[1 - N % 2] = nullptr) { // 2
  std::cout << 鈥淣=鈥?<< N << 鈥?is even鈥?<< std::endl;
}
f<5>();
f<8>();
\end{code}

Here, the template parameter is a value, not a type. We have two template overloads that both take a pointer to an array of characters, and array size expressions are valid only for some values of \texttt{N}. Specifically, a zero-size array is invalid in C++. Therefore, the first overload is valid only if \texttt{N} \texttt{\%} \texttt{2} is non-zero, that is, if \texttt{N} is odd. Similarly, the second overload is valid only if \texttt{N} is even. No arguments are given to the function, so we intend to use the default arguments. The two overloads would have been ambiguous in every way, were it not for the fact that, for both calls, one of the overloads fails during template argument substitution and is silently removed.

The preceding example is very condensed - in particular, the template parameter value deduction, the equivalent of type deduction for numeric parameters is disabled by the explicit specification. We can bring the deduction back and still have the substitution fail, or not, depending on whether an expression is valid:

\begin{code}
// Example 13
template <typename T, size_t N = T::N>
void f(T t, char(*)[N % 2] = NULL) {
  std::cout << 鈥淣=鈥?<< N << 鈥?is odd鈥?<< std::endl;
}
template <typename T, size_t N = T::N>
void f(T t, char(*)[1 - N % 2] = NULL) {
  std::cout << 鈥淣=鈥?<< N << 鈥?is even鈥?<< std::endl;
}
struct A { enum {N = 5}; };
struct B { enum {N = 8}; };
A a;
B b;
f(a);
f(b);
\end{code}

Now, the compiler has to deduce the type from the first argument. For the first call, \texttt{f(a)}, the \texttt{A} type is easily deduced. There is no way to deduce the second template parameter, \texttt{N}, so the default value is used (we are now in C++11 territory). Having deduced both template parameters, we now proceed to the substitution, where \texttt{T} is replaced by \texttt{A}, and \texttt{N} is replaced by \texttt{5}. This substitution fails for the second overload but succeeds for the first one. With only one remaining candidate in the overload set, the overload resolution concludes. Similarly, the second call, \texttt{f(b)}, ends up calling the second overload.

Note that there is a subtle but very important difference between the preceding example and the earlier example where we had this function:

\begin{code}
template <typename T> void f(T i, typename T::t& j);
\end{code}

In this template, the substitution failure is ``\emph{natural:}'' the parameter that may cause the failure is needed and is intended to be of a pointer to member type. In the previous case, the template parameter \texttt{N} is gratuitous: it is not needed for anything other than artificially causing substitution failures and disabling some overloads. Why would you ever want to cause an artificial substitution failure? We have seen one reason, forcing the selection of otherwise ambiguous overloads. The more general reason has to do with the fact that type substitution sometimes can lead to errors.

\subsection{When substitution failure is still an error}

Note that SFINAE does not protect us from any and all syntax errors that might happen during template instantiation. For example, if the template parameters are deduced, and the template arguments are substituted, we may still end up with an ill-formed template function:

\begin{code}
// Example 14
template <typename T> void f(T) {
  std::cout << sizeof(T::i) << std::endl;
}
void f(...) { std::cout << 鈥渇(...)鈥?<< std::endl; }
f(0);
\end{code}

This code fragment is very similar to those we considered earlier, with one exception - we do not learn that the template overload presupposes that the \texttt{T} type is a class, and has a data member named \texttt{T::i}, until we examine the function body. By then, it is too late, as the overload resolution is done only on the basis of the function declaration - the parameters, the default arguments, and the return type (the latter is not used to deduce types or select a better overload, but still undergoes type substitution and is covered by SFINAE). Once the template is instantiated and chosen by the overload resolution, any syntax errors, such as an invalid expression in the body of the function, are not ignored - such a failure is very much an error. The exact list of contexts where a substitution failure is, or is not, ignored, is defined in the standard; it was significantly expanded in C++11, with subsequent standards making a few subtle tweaks.

There is another case where an attempt to use SFINAE leads to an error instead. Here is an example:

\begin{code}
// Example 15a
template <typename T> struct S {
  typename T::value_type f();
};
\end{code}

Here we have a class template. If the type \texttt{T} does not have a nested type \texttt{value\_type}, type substitution leads to an error, and this is a real error, it is not ignored. You can't even instantiate this class template with a type that does not have \texttt{value\_type}. Making the function into a template does not solve the problem:

\begin{code}
template <typename T> struct S {
  template <typename U> typename T::value_type f();
};
\end{code}

It is very important to remember that SFINAE applies only when the error occurs during the substitution of the types that were deduced for the template function. In the last example, the substitution error does not depend on the template type parameter \texttt{U}, so it is always going to be an error. If you really need to work around this, you have to use a member function template and use a template type parameter to trigger the substitution error. Since we do not need an additional template parameter, we can default it to be the same as the class template type parameter \texttt{T}:

\begin{code}
// Example 15b
template <typename T> struct S {
  template <typename U = T>
  std::enable_if_t<std::is_same_v<U, T>
  typename U::value_type f();
};
\end{code}

Now the substitution error, if any, will happen with a type dependent on the template type parameter \texttt{U::value\_type}. We do not need to specify type \texttt{U} since it is defaulted to \texttt{T}, and it can't be anything else because of the requirement that types \texttt{U} and \texttt{T} are the same (otherwise the return type of the function is invalid, which is a SFINAE error). Thus, our template member function \texttt{f()} does (almost) exactly what the original non-template function \texttt{f()} did (there are subtle differences if the function has overloads within the class). So, if you really need to ``hide'' a substitution error caused by a class template parameter, you can do so by introducing a redundant function template parameter and restricting the two to always be the same.

Before continuing, let's review the three kinds of substitution failures we encountered.

\subsection{Where and why does substitution failure happen?}

To understand the rest of this chapter, it is essential that we clearly differentiate between several kinds of substitution failures that can occur in template functions.

The first kind happens when the template declaration uses dependent types or other constructs that can cause a failure, and their use is necessary to declare the template properly. Here is a template function that is intended to be called with a container argument (all STL containers have a nested type \texttt{value\_type}):

\begin{code}
// Example 16
template <typename T>
bool find(const T& cont, typename T::value_type val);
\end{code}

If we try to call this function with an argument that does not define the nested type, \texttt{value\_type}, the function call will not compile (assuming we have no other overloads). There are many more examples where we naturally use dependent types and other expressions that may be invalid for some values of template parameters. Such invalid expressions cause a substitution failure. It does not have to happen in the argument declaration. Here is a template whose return type may be undefined:

\begin{code}
// Example 16
template <typename U, typename V>
std::common_type_t<U, V> compute(U u, V v);
\end{code}

In this template, the return type is the common type of the two template parameter types. But what if the template arguments are such that the types \texttt{U} and \texttt{V} have no common type? Then the type expression \texttt{std::common\_type\_t\textless{}U,\ V\textgreater{}} is invalid and the type substitution fails. Here is yet another example:

\begin{code}
// Example 15
template <typename T>
auto process(T p) -> decltype(*p);
\end{code}

Here, again, the substitution failure may occur in the return type, but we use the trailing return type so that we can directly check whether the expression \texttt{*p} compiles (or, more formally, is valid). If it is, the type of the result is the return type. Otherwise, the substitution fails. Note that there is a difference between this declaration and something like this:

\begin{code}
template <typename T> T process(T* p);
\end{code}

If the function argument is a raw pointer, both versions amount to the same thing. But the first variant also compiles for any type that can be dereferenced, such as container iterators and smart pointers, while the second version works only for raw pointers.

The second kind of substitution failure happens when the function declaration compiles successfully, including the type substitution, and then we get a syntax error in the function body. We can easily modify each of these examples to see how this might have happened. Let's start with the \texttt{find()} function:

\begin{code}
// Example 17
template <typename T, typename V>
bool find(const T& cont, V val) {
  for (typename T::value_type x : cont) {
    if (x == val) return true;
  }
  return false;
}
\end{code}

This time, we decided to accept a value of any type. This is not necessarily wrong in itself, but the body of our template function is written in the assumption that the container type \texttt{T} has the nested type \texttt{value\_type} and that this type is comparable with the type \texttt{V}. If we call the function with a wrong argument, the call will still compile because nothing particular is required of the argument types by the substitution that happens in the declaration of the template. But then we get a syntax error in the body of the template itself, rather than at the call site.

Here is how a similar thing can happen with the \texttt{compute()} template:

\begin{code}
// Example 17
template <typename U, typename V>
auto compute(U u, V v) {
  std::common_type_t<U, V> res = (u > v) ? u : v;
  return res;
}
\end{code}

This template function can be called for any two arguments, but then it won't compile unless there is a common type for both.

Note the very significant difference between the two kinds of substitution failures: if the failure happens in SFINAE context, the function is removed from the overload resolution as if it does not exist. If there is another overload (a function with the same name), it will be considered and may end up being called. If there is not, we will get a syntax error at the call site that boils down to ``there is no such function.'' On the other hand, if the failure happens in the body of the template (or in some other place not covered by SFINAE rules) then, assuming the function is the best, or the only, overload, it will be called. The client's code -- the call itself -- will compile fine, but the template will not.

There are several reasons why the first option is preferable. First of all, the caller may have wanted to call a different overload, the one that would have compiled fine, but the rules for overload resolution among templates are complex and the wrong overload was chosen. It may be very difficult for the caller to fix this error and force the choice of the intended overload. Second, the error messages you get when the body of the template fails compilation are often incomprehensible. Our examples were simple, but in a more realistic case, you may see an error that involves some internal types and objects that you know nothing about. The last reason is more of a conceptual statement: the interface of the template function, like any other interface, should describe the requirements on the caller as completely as possible. An interface is a contract; if the caller has complied with it, the implementer of the function must deliver as promised.

Let's assume that we have a template function whose body has some requirements on the type parameters and that these requirements are not captured by the interface written in a natural, straightforward way (the type substitution succeeds but the template does not compile). The only way to convert the hard substitution failure into an SFINAE failure is to make it happen in SFINAE context. To do this, we need to add something to the interface that is not necessary to declare the function. The only purpose of this addition is to trigger a substitution failure and remove the function from the overload resolution set before it could lead to a compilation error in the body of the function. Such ``artificial'' failure is the third kind of substitution failure. Here is an example where we enforce the requirement that the types are pointers even though the interface itself would be just fine without it:

\begin{code}
// Example 18
template <typename U, typename V>
auto compare(U pu, V pv) -> decltype(bool(*pu == *pv)) {
  return *pu < *pv;
}
\end{code}

This function takes two pointers (or any other pointer-like objects that can be dereferenced) and returns the Boolean result of comparing the values they point to. In order for the body of the function to compile, both arguments must be something that can be dereferenced. Furthermore, the results of dereferencing them must be comparable for equality. Finally, the result of the comparison must be convertible to bool. The trailing return type declaration is unnecessary: we could have just declared the function to return \texttt{bool}. But it does have an effect: it moves a possible substitution failure from the body of the function to its declaration, where it becomes an SFINAE failure. The return type is always \texttt{bool} unless the expression inside \texttt{decltype()} is invalid. That could happen for any of the same reasons the function body would not compile: one of the arguments cannot be dereferenced, the values are not comparable, or the result of the comparison is not convertible to \texttt{bool} (the latter is usually redundant, but we might as well enforce the entire contract).

Notice that the line between the ``natural'' and ``artificial'' substitution failures is not always clear. For example, one could have argued that using \texttt{std::common\_type\_t\textless{}U,\ V\textgreater{}} as the return type earlier was artificial (the third kind of substitution failure, not the first kind) and that the ``natural'' way would be to declare the return type as \texttt{auto} and let the function body fail if the common type could not be deduced. Indeed, the difference often boils down to the programmer's style and intent: if it wasn't for the need to enforce the type restriction, would the programmer have written the type expression in the template declaration anyway?

The failures of the first kind are straightforward: the template interface itself forms a contract, the attempted call violated the contract, and the function wasn't called. The failures of the second kind are, ideally, to be avoided altogether. But to do that, we have to employ the failures of the third kind, the artificial substitution failures in SFINAE context. The rest of this chapter deals with the ways to code such interface-limiting template contracts. Since the first days of C++, SFINAE techniques were used to artificially cause a substitution failure that would remove such functions from the overload set. C++20 added a totally different mechanism for solving this problem: concepts. Before we discuss controlling overload resolution with SFINAE, we need to learn more about this latest addition to the language.

\section{Concepts and constraints in C++20}

The rest of this chapter is all about the ``artificial'' substitution failures that are added to the template declaration to impose restrictions on the template arguments. In this section, we are going to learn about the new, C++20, way of coding these restrictions. In the next section, we will show what you can do if you can't use C++20 but still want to constrain your templates.

\subsection{Constraints in C++20}

C++20 changed the way we are using SFINAE to restrict template arguments by introducing concepts and constraints. Even though the overall feature is usually referred to as ``concepts,'' it is the constraints that are the most important part. What follows is not a complete or formal description of these features, but rather a demonstration of the best practices (it may be too early to say ``patterns'' since the community is still in the process of establishing what is and isn't sufficiently widely accepted).

The first way to specify a constraint is by writing a \texttt{requires} clause that has the form:

\begin{code}
requires(constant-boolean-expression)
\end{code}

The keyword \texttt{requires} and the constant (compile-time) expression in parentheses must appear either immediately after the template parameters or as the last element of the function declaration:

\begin{code}
// Example 19
template <typename T> requires(sizeof(T) == 8) void f();
template <typename T> void g(T p) requires(sizeof(*p) < 8);
\end{code}

Just like in the last section, the constraint written at the end of the declaration can refer to the function arguments by name, while the constraint written after the parameter list can refer only to the template parameters (other, more subtle differences between the two syntaxes are outside of the scope of this chapter). Unlike the last section, if a constraint fails, the compiler usually issues a clear diagnostic instead of simply reporting that ``no function f was found'' and template deduction failed.

What can be used in the constant expression in a \texttt{requires} clause? Anything that can be computed at compile time, really, as long as the overall result is a \texttt{bool}. Type traits such as \texttt{std::is\_convertible\_v} or \texttt{std::is\_default\_constructible\_v} are often used to restrict types. If the expressions are complex, \texttt{constexpr} functions can help to simplify them:

\begin{code}
template <typename V> constexpr bool valid_type() {
  return sizeof(T) == 8 && alignof(T) == 8 &&
    std::is_default_constructible_v<T>;
}
template <typename T> requires(valid_type<T>()) void f();
\end{code}

But there is one special expression that we have not seen before -- the \texttt{requires} expression. This expression can be used to check if some arbitrary expression compiles (technically, it ``is valid''):

\begin{code}
requires { a + b; }
\end{code}

Assuming the values \texttt{a} and \texttt{b} are defined in the context where the expression is used, this expression evaluates to \texttt{true} if the expression \texttt{a\ +\ b} is valid. What if we know the types we want to test but don't have the variables? Then we can use the second form of the \texttt{requires} expression:

\begin{code}
requires(A a, B b) { a + b; }
\end{code}

The types \texttt{A} and \texttt{B} usually refer to the template parameters or some dependent types.

Note that we said ``arbitrary expression is valid'' and not ``arbitrary code is valid.'' This is an important difference. For example, you can't write

\begin{code}
requires(C cont) { for (auto x: cont) {}; }
\end{code}

And require that the type \texttt{C} meets all requirements for a range-for loop. Most of the time, you test expressions such as \texttt{cont.begin()} and \texttt{cont.end()} instead. However, you can also come up with a more complex requirement by hiding the code in a lambda expression:

\begin{code}
requires(C cont) {
  [](auto&& c) {
    for (auto x: cont) { return x; };
  }(cont);
}
\end{code}

Woe is you if such code ever fails and you have to figure out the error message.

When a \texttt{requires} expression is used in a template constraint, the template is restricted not by a specific trait but by the required behavior of the types:

\begin{code}
// Example 20
template <typename T, typename P>
void f(T i, P p) requires( requires { i = *p; } );
template <typename T, typename P>
void f(T i, P p) requires( requires { i.*p; } );
\end{code}

First of all, yes, there are two keywords \texttt{requires} (by the way, parentheses are optional in this case and you can find this constraint written as \texttt{requires\ requires} ). The first \texttt{requires} introduces a constraint, a \texttt{requires} clause. The second \texttt{requires} begins the \texttt{requires} expression. The expression in the first function \texttt{f()} is valid if the second template argument \texttt{p} can be dereferenced (it can be a pointer, but it doesn't have to be) and the result can be assigned to the first argument \texttt{i}. We don't require that the types on both sides of the assignment be the same or even that \texttt{*p} can be convertible to \texttt{T} (usually it would be, but it's not required). We just need the expression \texttt{i\ =\ *p} to compile. Finally, if we did not have the right variables readily available, we could have declared them as parameters to the \texttt{requires} expression:

\begin{code}
// Example 20
template <typename T, typename P>
requires(requires(T t, P p) { t = *p; }) void f(T i, P p);
template <typename T, typename P>
requires(requires(T t, P p) { t.*p; }) void f(T i, P p);
\end{code}

These two examples also demonstrate that we can do SFINAE overload control with constraints: if a constraint fails, the template function is removed from the overload resolution set and the resolution continues.

As we have seen already, sometimes we need to check not an expression but a dependent type; we can do that inside the \texttt{requires} expression as well:

\begin{code}
requires { typename T::value_type; }
\end{code}

A requires expression evaluates to bool, so it can be used in a logical expression:

\begin{code}
requires(
  requires { typename T::value_type; } &&
  sizeof(T) <= 32
)
\end{code}

We could combine multiple requires expressions this way, but we can also write more code inside a single expression:

\begin{code}
requires(T t) { typename T::value_type; t[0]; }
\end{code}

Here we require that the type \texttt{T} has a nested type \texttt{value\_type} and an index operator that accepts integer indices.

Finally, sometimes we need to check not just that some expression compiles but that its result has a certain type (or satisfies some type requirements). This can be done with the compound form of the \texttt{requires} expression:

\begin{code}
requires(T t) { { t + 1 } -> std::same_as<T>; }
\end{code}

Here we require that the expression \texttt{t\ +\ 1} compiles and yields the result of the same type as the variable \texttt{t} itself. The last part is done using a concept; you will read about them in the next section, but for now, think of it as an alternative way to write the \texttt{std::is\_same\_v} type trait.

Speaking of concepts\ldots{} Everything we have described so far can be found under the heading of ``concepts'' in any C++20 book, except we have not mentioned the concepts themselves. That is about to change.

\subsection{Concepts in C++20}

Concepts are simply a named set of requirements -- the same requirements we were just learning about. In a way, they are similar to \texttt{constexpr} functions, except they operate on types, not values.

You use a concept when there is a set of requirements that you refer to often, or one that you want to give a meaningful name to. For example, a range is defined by a very simple requirement: it must have a begin iterator and an end iterator. We can write a simple requires expression every time we declare a function template that accepts a range argument, but it is both more convenient and more readable to give this requirement a name:

\begin{code}
// Example 21
template <typename R> concept Range = requires(R r) {
  std::begin(r);
  std::end(r);
};
\end{code}

We have just introduced a concept named \texttt{Range} with one template type parameter \texttt{R}; this type must have begin and end iterators (the reason we use \texttt{std::begin()} instead of the member function \texttt{begin()} is that C arrays are also ranges but they have no member functions).

Note that C++20 has a ranges library and a corresponding set of concepts (including \texttt{std::ranges::range} that should be used instead of our homemade \texttt{Range} in any real code) but the idea of ranges makes for convenient teaching material and we will use it to drive the examples.

Once we have a named concept, we can use it instead of spelling out the requirements in any template constraint:

\begin{code}
// Example 21
template <typename R> requires(Range<R>) void sort(R&& r);
\end{code}

As you can see, the concept can be used inside a \texttt{requires} clause as if it was a \texttt{constexpr} variable of type \texttt{bool}. Indeed, a concept can also be used in contexts such as static assert:

\begin{code}
static_assert(Range<std::vector<int>>);
static_assert(!Range<int>);
\end{code}

For simple template declarations where the concept is the whole requirement, the language provides a much simpler way to state it:

\begin{code}
// Example 21
template <Range R> void sort(R&& r);
\end{code}

In other words, the concept name can be used instead of the \texttt{typename} keyword in a template declaration. Doing so automatically restricts the corresponding type parameter to types that satisfy the concept. If necessary, a \texttt{requires} clause can still be used to define additional constraints. Finally, the concepts can also be used with the new C++20 template syntax:

\begin{code}
// Example 21
void sort(Range auto&& r);
\end{code}

All three declarations have the same effect and the choice is largely a matter of style and convenience.

\subsection{Concepts and type restrictions}

We have already seen how concepts and constraints are used to impose restrictions on the parameters of function templates. The \texttt{requires} clauses can appear after the template parameters or at the end of the function declaration; both places are SFINAE contexts and a substitution failure in either location does not stop the compilation of the entire program. In this regard, concepts are not fundamentally different from substitution failures: while you can use a constraint outside of an SFINAE context, a substitution failure would still be an error. For example, you cannot assert that a type does not have a nested type \texttt{value\_type} by using a constraint:

\begin{code}
static_assert(!requires{ typename T::value_type; });
\end{code}

You may expect that the \texttt{requires} expression evaluates to false if the requirement is not met, but in this case, it simply does not compile (you get the error that \texttt{T::value\_type} does not refer to a valid type).

However, there are restrictions you can enforce with concepts that were impossible to implement before. These are requirements for class templates. In the simplest form, we can use a concept to restrict class template type parameters:

\begin{code}
// Example 21
template <Range R> class C { 鈥?};
\end{code}

This class template can only be instantiated with types that satisfy the concept \texttt{Range}.

Then, we can constrain individual member functions, whether they are templates or not:

\begin{code}
// Example 21
template <typename T> struct holder {
  T& value;
  holder(T& t) : value(t) {}
  void sort() requires(Range<T>) {
    std::sort(std::begin(value), std::end(value));
  }
};
\end{code}

Now the class template itself can be instantiated on any type. However, its interface includes a member function \texttt{sort()} only if the type satisfies the \texttt{Range} constraint.

This is a very important difference between constraints and the old SFINAE: the artificial substitution failure helps only if it happens when substituting deduced type parameters in function templates. Earlier in this chapter, we had to add a dummy template type parameter to a member function just so we could create an SFINAE failure. With concepts, there is no need for any of that.

Concepts and constraints are the best way to specify restrictions on template parameters. They make a lot of the SFINAE tricks invented over the years obsolete. But not everyone has access to C++20 yet. Also, some of the SFINAE techniques are still used even with concepts. In the last section, we will learn about these techniques as well as see what can be done if you do not have C++20 but still want to constraint template types.

\section{SFINAE techniques}

The rule that a failure of the template argument substitution is not an error - the SFINAE rule - had to be added to the language simply to make certain narrowly defined template functions possible. But the ingenuity of a C++ programmer knows no bounds, and so SFINAE was repurposed and exploited to manually control the overload set by intentionally causing substitution failures. A huge variety of SFINAE-based techniques were invented over the years until the C++20 concepts made most of them obsolete.

Still, some use of SFINAE remains even in C++20, and then there is the vast body of pre-C++20 code that you may need to read, understand, and maintain.

Let's start with the applications of SFINAE that are still useful even when concepts are available.

\subsection{SFINAE in C++20}

First of all, even in C++20, there are still ``natural'' type substitution failures. For example, you may want to write this function:

\begin{code}
template <typename T> typename T::value_type f(T&& t);
\end{code}

This is still fine, assuming you really want to return a value of the type given by the nested \texttt{value\_type}. However, before you rush to answer ``yes'' you should examine closely what is the type you really want to return. What is the contract with the caller that you want to enforce? Maybe the existence of \texttt{value\_type} was used as a proxy for the real requirements, such as the type T has the index operator or can be used as a range to iterate over. In this case, you can now state the requirements directly, for example:

\begin{code}
template <typename T> auto f(T&& t)
requires( requires { *t.begin(); t.begin() != t.end(); } );
\end{code}

This says that what you really need is a type with member functions \texttt{begin()} and \texttt{end()}. The values returned by these functions (presumably, the iterators) are dereferenced and compared; if these operations are supported, the return values are close enough to iterators for our purposes. Finally, in the preceding example, we let the compiler determine the return type. This is often convenient, but the downside is that the interface -- our contract -- does not say what the return type is; the client of our code must read the implementation. Assuming we return a value we get by dereferencing an iterator, we can be explicit about it:

\begin{code}
template <typename T> auto f(T&& t)->decltype(*t.begin())
requires( requires {
  *t.begin();
  t.begin() != t.end();
  ++t.begin();
} );
\end{code}

This is a very comprehensive contract with the client, assuming, of course, that we as implementers guarantee that the body of the function will compile if the stated requirements are met. Otherwise, the contract is incomplete: for example, if we do use \texttt{T::value\_type} in the body of the function, we should add \texttt{typename\ T::value\_type} to the list of requirements, whether or not this is the type we eventually return (if it is, we could still use SFINAE for the return type, nothing wrong with that).

Similar considerations exist when a dependent type is used to declare a template function argument, for example:

\begin{code}
template <typename T>
bool find(const T& t, typename T::value_type x);
\end{code}

Again, we should ask ourselves if these really are the requirements we want to impose. Assuming the function is looking for the value \texttt{x} in the container \texttt{t}, do we really care what the type of \texttt{x} is as long as it can be compared with the values stored in the container? Consider this alternative:

\begin{code}
template <typename T, typename X>
bool find(const T& t, X x)
requires( requires {
  *t.begin() == x;
  t.begin() == t.end();
  ++t.begin();
} );
\end{code}

Now we require that the container has everything needed for a range-for loop and that the values stored in the container can be compared with \texttt{x} for equality. Assuming that all we do is iterate over the container and return true if a value equal to \texttt{x} is found, this is all we need to require from the caller.

You should not infer that the ``natural'' SFINAE should no longer be used in C++20 and be replaced by independent template parameters bound together by constraints. All we suggest is that you examine your code to determine whether the contract expressed by the interface and enforced through SFINAE is really what you want, or merely what was convenient to code. In the latter case, concepts offer a way to express what you really wanted to require but could not (but do read on, because there are concept-inspired techniques that can be used before C++20 and meet the same need). On the other hand, if the template function is best written in a way that triggers a substitution failure when the client supplies an invalid argument, then, by all means, continue to use SFINAE -- there is no need to rewrite everything to use concepts.

Even the ``artificial'' SFINAE still has uses in C++20, as we are about to see.

\subsection{SFINAE and type traits}

The most important application of ``artificial'' SFINAE in C++20 is writing type traits. Type traits are not going anywhere: even if you replace \texttt{std::is\_same\_v} (trait) with \texttt{std::same\_as} (concept) in your code, you should know that the concept's implementation uses the very trait it replaces.

Not all type traits require the use of SFINAE, but many do. These are the traits that check for the presence of some syntactic feature, such as the existence of a nested type. The implementation of these traits faces a common problem: if the type does not have the required feature, some code does not compile. But we don't want a compilation error. We want an expression that evaluates to \texttt{false}. So how do we get the compiler to ignore an error? By making it occur in an SFINAE context, of course.

Let's start with an example that was getting in our way throughout the entire chapter: we are going to write a trait to check whether a type has the nested type \texttt{value\_type}. We are going to use SFINAE, so we need a template function. This function must use the nested type in an SFINAE context. There are several options for that. Often, it is convenient to add a template argument that depends on the expression that may fail, for example:

\begin{code}
template <typename T, typename = T::value_type> void f();
\end{code}

Note that the second parameter has no name -- we never use it. If we attempt to instantiate this template with any type \texttt{T} that does not have a nested \texttt{value\_type}, for example, \texttt{f\textless{}int\textgreater{}()}, the substitution will fail, but this is not an error (SFINAE!). Of course, not having a function to call when we write \texttt{f(ptr)} is an error, so we must provide a fallback overload:

\begin{code}
template <typename T> void f(鈥?;
\end{code}

You may find the notion of the ``doubly universal'' \texttt{template\ f(...)} function curious - it takes any arguments of any type, even without the template, so why use the template? Of course, it is so a call with an explicitly specified type, such as \texttt{f\textless{}int\textgreater{}()}, considers this function as a possible overload (remember that, by specifying the template parameter type, we also exclude all non-template functions from consideration). However, we want the priority of this overload to be as low as possible, so the first overload is preferred as long as it exists. That's why we use \texttt{f(鈥?} which is the ``overload of the last resort.'' Alas, the overload of \texttt{f()} and \texttt{f(鈥?} is still considered ambiguous, so we need to have at least one argument. The type of the argument doesn't matter as long as we can readily construct an object of that type:

\begin{code}
template <typename T, typename = T::value_type>
void f(int);
template <typename T> void f(鈥?;
\end{code}

Now a call to \texttt{f\textless{}T\textgreater{}(0)} will choose the first overload if \texttt{T::value\_type} is a valid type. Otherwise, there is only one overload to choose from, the second one. All we need is a way to figure out which overload would be chosen if we made the call, without actually making it.

This turns out to be pretty easy: we can use \texttt{decltype()} to check the type of the result of the function (prior to C++11, \texttt{sizeof()} was used instead). Now, all we need is to give the two overloads different return types. Any two different types can be used. We can then write some conditional code on these types. However, remember that we are writing a type trait, and the traits that check for the existence of something usually end up being \texttt{std::true\_type} if the value exists and \texttt{std::false\_type} if it does not. There's no reason to overcomplicate our implementation -- we can just return the desired type from both overloads and use it as the trait:

\begin{code}
// Example 22
namespace detail {
template <typename T, typename = T::value_type>
void test_value_type(int);
template <typename T> void test_value_type (鈥?;
}
template <typename T> using has_value_type =
  decltype(detail::test_value_type <T>(0));
\end{code}

Since the functions are never called but used only inside \texttt{decltype()}, we do not need to provide the definition of the functions, only their declarations (but see the next section for a more complete and nuanced explanation). To avoid polluting the global namespace with the test functions that the client should not ever have to worry about, it is customary to hide them in a namespace such as \texttt{detail} or \texttt{internal}. Speaking of customary, we should define the two aliases:

\begin{code}
template <typename T>
using has_value_type_t = has_value_type<T>::type;
template <typename T> inline constexpr
bool has_value_type_v = has_value_type<T>::value;
\end{code}

Now we can use our trait like any standard trait, for example:

\begin{code}
static_assert(has_value_type_v<T>, 鈥淚 require value_type鈥?;
\end{code}

As we have seen earlier, there are several other SFINAE contexts we could have used to ``hide'' the potential error arising from using \texttt{T::value\_type}. The trailing return type could be used but is not convenient since we already have a return type we need (there is a way around that, but it's more complex than the alternatives). Also, if we ever need to use SFINAE with a constructor, the return type is not an option there.

The other common technique is adding extra arguments to the function; the substitution error occurs in the argument type and the arguments must have default values so the caller doesn't even know they exist. This used to be more popular in the past, but we are moving away from this practice: the dummy arguments can interfere with the overload resolution and it may be hard to come up with a reliable default value for such arguments.

The one other technique that is becoming standard practice is to have the substitution failure occur in an optional non-type template parameter:

\begin{code}
// Example 22a
template <typename T, std::enable_if_t<
  sizeof(typename T::value_type) !=0, bool> = true>
std::true_type test_value_type(int);
\end{code}

Here we have a non-type template parameter (a value of type \texttt{bool}) with a default value \texttt{true}. The substitution of type \texttt{T} in this parameter can fail in the same way all the earlier failures in this section occurred: if the nested type \texttt{T::value\_type} does not exist (if it does, the logical expression \texttt{sizeof(鈥?\ !=\ 0} never fails since the size of any type is non-negative). The advantage of this approach is that it's easier to combine multiple expressions if we need to check for several failures at once, for example:

\begin{code}
template <typename T, std::enable_if_t<
  sizeof(typename T::value_type) !=0 &&
  sizeof(typename T::size_type) !=0, bool> = true>
std::true_type test_value_type(int);
\end{code}

This technique is sometimes used with the failing expression in the default value instead of the type:

\begin{code}
template <typename T,
          bool = sizeof(typename T::value_type)>
std::true_type test_value_type(int);
\end{code}

This is a bad habit to get into: while it sometimes works and may seem easier to write, it has a major drawback. Often, you need to declare several overloads with different conditions such that only one of these succeeds. You can do so using the earlier approach:

\begin{code}
template <typename T, std::enable_if_t<cond1, bool> = true>
res_t func();
template <typename T, std::enable_if_t<cond2, bool> = true>
res_t func(); // OK as long as only one cond1,2 is true
\end{code}

But you cannot do this:

\begin{code}
template <typename T, bool = cond1> = true>
res_t func();
template <typename T, bool = cond2 > = true>
res_t func();
\end{code}

Two templates that have the same parameters but different default values are considered duplicate declarations, even if one of the conditions \texttt{cond1} or \texttt{cond2} always causes a substitution failure. It is better to get into the habit of writing such code with the (possibly failing) condition in the type of the non-type parameter.

To review everything we have learned about SFINAE, let's write another trait. This time, we are going to check whether a type is a class:

\begin{code}
// Example 23
namespace detail {
template <typename T> std::true_type test(int T::*);
template <typename T> std::false_type test(...);
}
template <typename T>
using is_class = decltype(detail::test<T>(nullptr));
\end{code}

The key difference between a class and not a class is that a class has members and, thus, member pointers. This time the easiest way is to declare a member function argument that is a member pointer (doesn't matter what kind of member, we're not going to call the function). The substitution failure occurs in the parameter type \texttt{T::*} if the type T does not have any members.

This is almost exactly how the standard trait \texttt{std::is\_class} is defined except it also checks for unions: unions are not considered classes by \texttt{std::is\_class}, but implementing \texttt{std::is\_union} requires compiler support, not SFINAE.

The techniques we have learned allow us to write any trait that checks for a particular property of a type: whether it is a pointer, whether it has a nested type or a member, etc. On the other hand, the concepts make it easy to check for behaviors: can a type be dereferenced, can two types be compared, etc? Note that I said ``easy'' not ``possible:'' you can use concepts to check for very narrowly defined features, and you can use traits to detect behaviors, but it is not as straightforward.

This chapter mainly targets a programmer who writes templates and template libraries in application code: if you write a library with the complexity and rigor of STL, you need to be very precise in your definitions (you also need a standard committee to debate and hash out those definitions to the necessary degree of precision). For the rest of us, the degree of formality provided by ``call \texttt{f(p)} if \texttt{*p} compiles'' is usually sufficient. In C++20, we can do this with concepts. If you do not use C++20 yet, you have to use one of the SFINAE techniques. Several such were discussed in this chapter; the community has developed many more over the years. However, the development of concepts had an interesting effect on these practices: in addition to the tools we can use directly in C++20, the standard offers us a way of thinking about this problem that is applicable much more broadly. Thus, several SFINAE techniques that somewhat resemble the concepts (for example, testing behaviors in a trailing \texttt{decltype()}) are becoming more popular, while other practices are falling out of favor. There have even been several attempts to implement a concept library using pre-C++20 language features. Of course, it is not possible to replicate concepts; in many ways, we can't even get close. However, we can still benefit from the thinking that went into developing the concepts language even if we cannot use the language itself. Thus, we can use SFINAE ``in the spirit'' of concepts, which provides a consistent way to implement SFINAE-based restrictions instead of an ad hoc collection of techniques. What follows is one such approach to implementing concept-like restrictions without the use of C++20.

\subsection{Concepts before concepts}

Our goal is not so much to implement a full concept library here: you can find such libraries online, and this book is about design patterns and best practices, not writing specific libraries. The aim of this section is to select the few best SFINAE-based techniques among the multitude of available options. These techniques also fit the concept-based mindset, as much as possible anyway. The methods and tricks we have not chosen are not necessarily inferior, but this section offers a set of SFINAE tools and practices that is consistent, uniform, and sufficient for the absolute majority of an application programmer's needs.

Just like with real concepts, we will need two kinds of entities: concepts and restrictions.

If you look at the way concepts are used, they strongly resemble constant Boolean variables:

\begin{code}
template <typename R> concept Range = 鈥?
template <typename R> requires(Range<R>) void sort(鈥?;
\end{code}

The \texttt{requires()} clause needs a Boolean value, it is not restricted to concepts (consider the expression \texttt{requires(std::is\_class\_v\textless{}T\textgreater{})}). The concept \texttt{Range\textless{}R\textgreater{}} thus acts like a Boolean value. Perforce, we are going to use \texttt{constexpr\ bool} variables instead of concepts in our attempt to emulate their behavior. From the comparison of \texttt{Range\textless{}R\textgreater{}} with \texttt{std::is\_class\_v\textless{}T\textgreater{}} we can also deduce that a trait-like mechanism is probably our best bet to implement concepts: \texttt{std::is\_class\_v} is also a \texttt{constexpr\ bool} variable, after all.

From the implementations of the traits we learned in the last section, we know that we are going to need two overloads:

\begin{code}
template <typename R> constexpr yes_t RangeTest(some-args);
template <typename R> constexpr no_t RangeTest(...);
\end{code}

The first overload is going to be valid and preferred for any type \texttt{R} that satisfies the requirements of \texttt{Range} (once we figure out how to do it). The second overload is always available but never preferred, so it is called only if this is the only overload left.

We can figure out which overload was called from the return types (\texttt{yes\_t} and \texttt{no\_t} are just placeholders for some types we haven't chosen yet). But there is a much simpler way; all we need for our \texttt{Range} ``concept'' is a constant Boolean value, so why not let the \texttt{constexpr} function return the right value directly, like so:

\begin{code}
template <typename R> constexpr bool RangeTest(some-args) {
  return true;
}
template <typename R> constexpr bool RangeTest(...) {
  return false;
}
template <typename R>
constexpr inline bool Range = RangeTest<R>(0);
\end{code}

The last two statements (the variable and the fallback overload) are complete. ``All'' we need is to make it so the first overload suffers a substitution failure when \texttt{R} is not a range. So, what is a range for our purposes? Just like we did in the section \emph{Concepts in C++20}, we are going to define a range as any type that has \texttt{begin()} and \texttt{end()}. Since we are testing for a specific behavior, which may fail to compile but should not cause an error, we should trigger this failure in an SFINAE context. As we have seen already, the easiest place for this possibly invalid code is the trailing return type:

\begin{code}
template <typename R>
constexpr auto RangeTest(??? r) -> decltype(
  std::begin(r),        // Ranges have begin()
  std::end(r),         // Ranges have end()
  bool{}            // But return type should be bool
) { return true; }
\end{code}

The trailing return type lets us write code that uses parameter names. All we need is a parameter \texttt{r} of type \texttt{R}. This is easy to do when using SFINAE in any template function that is meant to be called. But this function is never going to be called with an actual range. We could try to declare an argument of type \texttt{R\&} and then call the function with a default-constructed range \texttt{R\{\}}, but this is not going to work because \texttt{constexpr} functions must have \texttt{constexpr} arguments (otherwise they can still be called but not in a constant expression, i.e. not at compile time), and \texttt{R\{\}} is not going to be a \texttt{constexpr} value for most ranges.

We could give up on using references altogether and use pointers instead:

\begin{code}
// Example 24
template <typename R>
constexpr auto RangeTest(R* r) -> decltype(
  std::begin(*r),    // Ranges have begin()
  std::end(*r),         // Ranges have end()
  bool{}            // But return type should be bool
) { return true; }
template <typename R> constexpr bool RangeTest(...) {
  return false;
}
template <typename R>
constexpr inline bool Range = RangeTest<R>(nullptr);
\end{code}

While you may have expected that ``concept-like'' SFINAE is going to be incredibly complex, this is actually all you need to define a concept such as \texttt{Range}:

\begin{code}
static_assert(Range<std::vector<int>>);
static_assert(!Range<int>);
\end{code}

These two statements look exactly like their C++20 equivalents! Our ``concept'' even works in C++14 except there are no \texttt{inline} variables there so we have to use \texttt{static} instead.

Having finished with concepts for now, we also need to do something about constraints. Here our success is going to be much more limited. First of all, since we are using SFINAE, we can apply restrictions only to template function parameters (as we have seen, the C++20 constraints can apply even to non-template functions, such as member functions of class templates). Also, we are very limited in where we can write these constraints. The most universal way is to add a non-template parameter to the template and test the constraint there:

\begin{code}
template <typename R,
    std::enable_if_t<Range<R>, bool> = true>
void sort(R&& r);
\end{code}

We can hide the boilerplate code in a macro:

\begin{code}
// Example 24
#define REQUIRES(...) \
  std::enable_if_t<(__VA_ARGS__), bool> = true
template <typename R, REQUIRES(Range<R>)> void sort(R&& r);
\end{code}

The variadic macro neatly solves the common problem macros have when their arguments are code: commas are interpreted as separators between arguments. This is by no means as convenient as C++20 constraints, but it's as close as you're going to get.

Now let us come back to the concepts. What we wrote earlier works, but has two problems: first, there is a lot of boilerplate code there too. Second, we had to use pointers to introduce function parameter names we could later use to test the required behaviors. This limits what behaviors we can require because functions can pass arguments by reference and the behavior can depend on what type of reference is used, while we cannot form pointers to references. In fact, the code we just wrote won't compile in many cases because the type of the argument \texttt{R} to the template function \texttt{sort()} is deduced as a reference. To use it reliably, we have to check the underlying type instead:

\begin{code}
// Example 24
template <typename R, REQUIRES(Range<std::decay_t<R>>)>
void sort(R&& r);
\end{code}

It would be much more convenient if we could use reference arguments, but then we are back to the problem we already faced: how to invoke such a function? We can't use a value of the corresponding type, such as \texttt{R\{\}} because it is not a constant expression. The same problem happens if we try to use \texttt{R\{\}} as the default argument value -- it is still not a constant expression.

As with most problems in software engineering, this one can be solved by adding another level of indirection:

\begin{code}
template <typename R>
constexpr static auto RangeTest(R& r = ???) ->
  decltype(std::begin(r), std::end(r));
template <typename R>        // Overload for success
constexpr static auto RangeTest(int) ->
  decltype(RangeTest<R>(), bool{}) { return true; }
template <typename R>        // Fallback overload
constexpr bool RangeTest(...) { return false; }
template <typename R>
constexpr static bool Range = RangeTest<R>(0);
\end{code}

Our fallback overload remains the same, but the overload that is going to be called if the SFINAE test succeeds now attempts to call \texttt{RangeTest(r)} in a \texttt{decltype} context (also, we are back to using \texttt{int} instead of a pointer as the dummy argument). The last problem is what to use as the default value for the argument \texttt{r}.

The usual way of getting references to objects in code that is never going to be called is \texttt{std::declval}, so we might want to write this:

\begin{code}
template <typename R>
constexpr static auto RangeTest(R& r=std::declval<R>()) ->
  decltype(std::begin(r), std::end(r));
\end{code}

Unfortunately, this is not going to compile, and the error message is going to be something like ``\texttt{std::declval} must not be used.'' This is strange, we are not really using it (the entire function is used only inside \texttt{decltype()}) but let's try to work around it. After all, there is no magic in \texttt{std::declval}, we just need a function that returns a reference to our object:

\begin{code}
template <typename T> constexpr T& lvalue();
template <typename R>
constexpr static auto RangeTest(R& r = lvalue<R>()) ->
  decltype(std::begin(r), std::end(r));
\end{code}

On a standard-compliant compiler, this is not going to compile either, but the error is going to be different, this time the compiler will say something like this:

\begin{code}
inline function 'lvalue<std::vector<int>>' is used but not defined."
\end{code}

OK, we can define the function but make sure it is never called:

\begin{code}
template <typename T> constexpr T& lvalue() { abort(); }
template <typename R>
constexpr static auto RangeTest(R& r = lvalue<R>()) ->
  decltype(std::begin(r), std::end(r));
\end{code}

Adding \texttt{\{\ abort();\ \}} makes all the difference -- the program now compiles and (after you add the rest of the missing pieces) it runs without aborting. That is as it should be: the function \texttt{lvalue()} is used only inside \texttt{decltype}, and its implementation should not matter at all. I'm not going to keep you in suspense any longer, this is an issue with the standard itself; if you want to want to dive into the thorny details, you can follow \emph{Core Issue 1581} here: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html. For now, we will just have to keep the useless function body (it doesn't hurt anything). Of course, we can define similar functions for initializing default rvalue arguments as well as \texttt{const} lvalue references, and contain them in some implementation-only namespace:

\begin{code}
namespace concept_detail {
template <typename T>
  constexpr const T& clvalue() { abort(); }
template <typename T> constexpr T& lvalue() { abort(); }
template <typename T> constexpr T&& rvalue() { abort(); }
}
\end{code}

Now we can define concepts that test behaviors for the type of reference we want:

\begin{code}
// Example 24a
template <typename R>
constexpr static auto RangeTest(
  R& r = concept_detail::lvalue<R>()) ->
  decltype(std::begin(r), std::end(r));
template <typename R>
constexpr static auto RangeTest(int) ->
  decltype(RangeTest<R>(), bool{}) { return true; }
template <typename R>
constexpr bool RangeTest(...) { return false; }
template <typename R>
constexpr static bool Range = RangeTest<R>(0);
\end{code}

The constraints, including our \texttt{REQUIRES} macro, still work exactly the same way (after all, the concept itself did not change -- \texttt{Range} is still a constant Boolean variable).

There is still the issue of the boilerplate; in fact, we have even more of it with the unwieldy default argument values. That's the easiest to take care of, though, with the help of some macros:

\begin{code}
// Example 25
#define CLVALUE(TYPE, NAME) const TYPE& NAME = \
  Concepts::concept_detail::clvalue<TYPE>()
#define LVALUE(TYPE, NAME) TYPE& NAME = \
  Concepts::concept_detail::lvalue<TYPE>()
#define RVALUE(TYPE, NAME) TYPE&& NAME = \
  Concepts::concept_detail::rvalue<TYPE>()
\end{code}

Of the three template functions (such as \texttt{RangeTest}), the first function is the equivalent of the C++20 \texttt{concept} declaration -- that's where the behaviors we want to require are coded. Other than these macros, it can't really be made any shorter:

\begin{code}
// Example 25
template <typename R> CONCEPT RangeTest(RVALUE(R, r)) ->
  decltype(std::begin(r), std::end(r));
\end{code}

Here we also defined a macro:

\begin{code}
#define CONCEPT constexpr inline auto
\end{code}

This is done not so much to shorten the code but to make it clear to the reader (if not the compiler) that we are defining a concept. Compare it with the C++20 statement:

\begin{code}
template <typename R> concept Range =
  requires(R r) { std::begin(r); std::end(r); };
\end{code}

The other two overloads (\texttt{RangeTest(int)} and \texttt{RangeTest(鈥?}), as well as the definition of the concept variable itself, can easily be made universal for any concept (except for the name, of course). In fact, the only declaration that varies from one concept to another is the first one:

\begin{code}
template <typename R>
constexpr static auto RangeTest(int) ->
  decltype(RangeTest<R>(), bool{}) { return true; }
\end{code}

We can make it work for any concept-testing function if we use a variadic template:

\begin{code}
// Example 25
template <typename鈥?T>
constexpr static auto RangeTest(int) ->
  decltype(RangeTest<T鈥?(), bool{}) { return true; }
\end{code}

Since all of our argument macros, such as \texttt{LVALUE()}, include the default value for each argument, the function can always be called without arguments. We have to be mindful of the possibility that the test function we define conflicts with the function \texttt{RangeTest(int)}. This does not happen here because \texttt{int} is not a valid range, but it could happen for other arguments. Since we control these common overloads and the definition of the concept variable itself, we could make sure that they use an argument that will not conflict with anything we could ever write in regular code:

\begin{code}
// Example 25
struct ConceptArg {};
template <typename鈥?T>
constexpr static auto RangeTest(ConceptArg, int) ->
  decltype(RangeTest<T鈥?(), bool{}) { return true; }
template <typename T>
constexpr bool RangeTest(ConceptArg, ...) { return false; }
template <typename R>
constexpr static bool Range = RangeTest<R>(ConceptArg{},0);
\end{code}

This code is going to be the same for all concepts, except for the names such as \texttt{Range} and \texttt{RangeTest}. A single macro can generate all these lines from just two naming arguments:

\begin{code}
// Example 25
#define DECLARE_CONCEPT(NAME, SUFFIX) \
template <typename... T> constexpr inline auto     \
  NAME ## SUFFIX(ConceptArg, int) -> \
  decltype(NAME ## SUFFIX<T...>(), bool{}){return true;} \
template <typename... T> constexpr inline bool \
  NAME ## SUFFIX(ConceptArg, ...) { return false; } \
template <typename... T> constexpr static bool NAME = \
  NAME ## SUFFIX<T...>(ConceptArg{}, 0)
\end{code}

We did not do so for brevity, but if you want to use these concept-like utilities in your code, you should hide all the implementation details in a namespace.

Now we can define our range concept as follows:

\begin{code}
// Example 25
template <typename R> CONCEPT RangeTest(RVALUE(R, r)) ->
  decltype(std::begin(r), std::end(r));
DECLARE_CONCEPT(Range, Test);
\end{code}

Thanks to the variadic template, we are not limited to concepts with just one template parameter. Here is a concept for two types that can be added together:

\begin{code}
// Example 25
template <typename U, typename V> CONCEPT
  AddableTest(CLVALUE(U, u), CLVALUE(V, v)) ->
  decltype(u + v);
DECLARE_CONCEPT(Addable, Test);
\end{code}

For comparison, this is what the C++20 version looks like:

\begin{code}
template <typename U, typename V> concept Addable =
  require(U u, V v) { u + v; }
\end{code}

Of course, it is much shorter and more powerful. But the C++14 version is about as close as you can get (this is not the only approach but they all yield similar results).

These ``fake concepts'' can be used to constrain templates, just like C++20 concepts:

\begin{code}
 // Example 25
template <typename R, REQUIRES(Range<R>)> void sort(R&& r);
\end{code}

OK, not quite like the C++20 concepts -- we are limited to template functions, and any requirement must involve at least one template parameter. So, if you want to restrict a non-template member function of a template class, you have to play the template game:

\begin{code}
template <typename T> class C {
  template <typename U = T, REQUIRE(Range<U>)> void f(T&);
  鈥?
};
\end{code}

But we do get the same result in the end: a call to sort with a vector compiles and sort of something that is not a range does not:

\begin{code}
std::vector<int> v = 鈥?
sort(v);         // OK
sort(0);        // Does not compile
\end{code}

Unfortunately, one place where our pseudo-concepts really come up short is the error messages -- a C++20 compiler would usually tell us which concept was not satisfied and why, while the template substitution error messages are not easy to decipher.

By the way, when you write a test to make sure that something does not compile, you can now use a concept (or a pseudo-concept) to do that:

\begin{code}
// Example 25
template <typename R>
CONCEPT SortCompilesTest(RVALUE(R, r))->decltype(sort(r));
DECLARE_CONCEPT(SortCompiles, Test);
static_assert(SortCompiles<std::vector<int>>);
static_assert(!SortCompiles<int>);
\end{code}

The C++20 version is left as an exercise for you.

Before we end this chapter, let's look at the recommendations and the best practices for use of SFINAE and concepts in templates.

\section{Constrained templates -- the best practices}

We have recommended the most useful SFINAE and concept-based techniques as we encountered them throughout the chapter, but we had a lot of material to cover, so it may be helpful to concisely restate these guidelines. These guidelines are here mainly for a programmer who uses templates in their application code. That includes the foundational code such as core template libraries of the applications, but a programmer writing a library such as STL, written for the widest possible use under extremely varied conditions and documented very precisely in a formal standard, would find these guidelines lacking in precision and formality:

\begin{itemize}
\item
  Learn the basic rules of SFINAE: in which contexts it applies (declarations) and in which it does not (function body).
\item
  The ``natural'' use of SFINAE that arises from using parameter-dependent types in the template declarations and argument-dependent expressions in the trailing return type is almost always the simplest way to express constraints on the template parameters (but see the next guideline).
\item
  Ask yourself whether you use a dependent type such as \texttt{T::value\_type} because this is precisely the right type for the context where you use it, or is it just simpler than writing the real constraint on the interface (such as ``any type that converts to \texttt{T::value\_type} )? In the latter case, this chapter should have convinced you that such restrictions are not that hard to express.
\item
  Whenever it makes sense, make your templates more general by using additional template parameters and necessary constraints on them (instead of using \texttt{T::value\_type} as an argument type, use another template parameter and constrain it to be convertible to \texttt{T::value\_type}).
\item
  If you use C++20 and have access to concepts, avoid using ``artificial'' SFINAE, i.e. do not create substitution failures whose only purpose is to constrain the template. Use the \texttt{requires} clauses, with or without concepts, as needed.
\item
  If you can't use C++20 concepts, choose a common uniform approach to SFINAE-based constraints and follow it. Take advantage of the concept-based approach developed for C++20 even if you can't use the language tools: follow the same style and patterns when applying SFINAE-based techniques. The previous section presented one such approach.
\item
  Ideally, if a template declaration meets all specified restrictions, there should be no substitution errors in the body of the template (i.e. if the function invokes, it compiles). This is a difficult goal in practice: the restrictions may end up being verbose and sometimes difficult to write up, and you may not even be aware of all the constraints your implementation implicitly demands. Even STL, designed with the benefit of the committee scrutinizing every word in its requirements, does not fully meet this goal. Nonetheless, it is a good practice to aim for. Also, if you must allow a function to be invoked but not compile, at least have the requirements codified by static asserts in the body of the function -- they are much easier for your users to understand than the strange substitution errors in types they never even heard of.
\end{itemize}

After reading this chapter, these guidelines should not be too daunting for you.

\section{Summary}

SFINAE is a somewhat esoteric feature of the C++ standard - it is complex and has many subtle details. While it is usually mentioned in the context of \emph{manual control of the overload resolution}, its main purpose is actually not to enable very elaborate guru-level code but to make the regular (automatic) overload resolution work the way the programmer intended. In this role, it usually works exactly as desired and with no additional effort - in fact, the programmer usually does not need to even be aware of this feature. Most of the time, when you write a generic overload and a special overload for the pointers, you expect the latter not to be called for types that are not pointers. Most of the time, you probably don't even pause to notice that the rejected overload would be ill-formed - who cares, it's not supposed to be used. But to find out that it's not supposed to be used, the type has to be substituted, which would result in an invalid code. SFINAE breaks this chicken-and-egg problem - to find out that the overload should be rejected, we have to substitute types, but that would create code that should not compile, which should not be a problem, because the overload should be rejected in the first place, but we do not know that until we substitute the types, and so on. This is what we call ``natural'' SFINAE.

Of course, we did not go through a few dozen pages just to learn that the compiler magically does the right thing and you don't have to worry about it. The more elaborate use of SFINAE is to create an artificial substitution failure, and thus take control of the overload resolution by removing some of the overloads. In this chapter, we learned the \emph{safe} contexts for these \emph{temporary} errors that are eventually suppressed by SFINAE. With careful application, this technique can be used to inspect and differentiate, at compile time, anything from the simple features of different types (\emph{is this a class?}) to complex behaviors that can be provided by any number of C++ language features (\emph{is there any way to add these two types?}). In C++20, such code is greatly simplified by introducing constraints and concepts. However, we can apply concept-inspired thinking even to the code written for earlier standards.

In the next chapter, we will introduce another advanced template pattern that is used to greatly increase the power of class hierarchies in C++: class inheritance lets us pass information from the base class to the derived, and the Curiously Recurring Template Pattern does the opposite, it makes the base class aware of the derived.

\section{Questions}

\begin{enumerate}
\item
  What is an overload set?
\item
  What is overload resolution?
\item
  What are type deduction and type substitution?
\item
  What is SFINAE?
\item
  In what contexts can potentially invalid code be present and not trigger a compilation error, unless that code is actually needed?
\item
  How can we determine which overload was chosen without actually calling it?
\item
  How is SFINAE used to control conditional compilation?
\item
  Why are C++20 constraints superior to SFINAE for constraining templates?
\item
  How does the C++20 concepts standard benefit the programmers using earlier language versions?
\end{enumerate}


\part{C++ Design Patterns}

This part begins with the main portion of the book. It introduces the most important, frequently used C++ design patterns. Each pattern is generally used as a commonly accepted approach to solving a certain type of problem. Exactly what the problem is, varies a great deal: some are system architecture challenges, others are interface design problems, yet others deal with program performance.

This part has the following chapters:

\begin{itemize}
\item
  \emph{Chapter 8, The Curiously Recurring Template Pattern}
\item
  \emph{Chapter 9, Named Arguments, Method Chaining, and Builder Pattern}
\item
  \emph{Chapter 10, Local Buffer Optimization}
\item
  \emph{Chapter 11, Scopeguard}
\item
  \emph{Chapter 12, Friend Factory}
\item
  \emph{Chapter 13, Virtual Constructors and Factories}
\item
  \emph{Chapter 14, The Template Method Pattern and the Non-Virtual Idiom}
\end{itemize}


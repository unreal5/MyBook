\chapter{The Curiously Recurring Template Pattern}

We are already familiar with the concepts of inheritance, polymorphism, and virtual functions. A derived class inherits from the base class and customizes the behavior of the base class by overriding its virtual functions. All operations are done on an instance of the base class, polymorphically. When the base object is actually an instance of the derived class, the right customized overrides are called. The base class knows nothing about the derived class, which may not even have been written when the base class code was written and compiled. The \textbf{Curiously Recurring Template Pattern} (\textbf{CRTP}) turns this well-ordered picture on its head, and inside out.

The following topics will be covered in this chapter:

\begin{itemize}
\item
  What is CRTP?
\item
  What is static polymorphism and how does it differ from dynamic polymorphism?
\item
  What are the downsides of virtual function calls, and why may it be preferable to resolve such calls at compile time?
\item
  What are the other uses of CRTP?
\end{itemize}

\section{Technical requirements}

The Google Benchmark library: https://github.com/google/benchmark

Example code: https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter08{}

\subsection{Wrapping your head around CRTP}

CRTP was first introduced, under this name, by James Coplien in 1995, in his article in \emph{C++ Report}. It is a particular form of a more general bounded polymorphism (Peter S. Canning et al., \emph{F-bounded polymorphism for object-oriented programming, Conference on Functional Programming Languages and Computer Architecture}, 1989). While not a general replacement for virtual functions, it provides the C++ programmer with a similar tool that, under the right circumstances, offers several advantages.

\subsection{What is wrong with a virtual function?}

Before we can talk about a \emph{better} alternative to a virtual function, we should consider why we would want to have an alternative at all. What is not to like about virtual functions?

The problem is the performance overhead. A virtual function call can be several times more expensive than a non-virtual call, more for very simple functions that would have been inlined were they not virtual (recall that a virtual function can never be inlined). We can measure this difference with a microbenchmark, the ideal tool for measuring the performance of small fragments of code. There are many microbenchmark libraries and tools out there; in this book, we will use the Google Benchmark library. To follow along with the examples in this chapter, you must first download and install the library (the detailed instructions can be found in \emph{Chapter 5, A Comprehensive Look at RAII}). Then, you can compile and run the examples.

Now that we have the microbenchmark library ready, we can measure the overhead of a virtual function call. We are going to compare a very simple virtual function, with the minimum amount of code, against a non-virtual function doing the same thing. Here is our virtual function:

\begin{code}
// Example 01
class B {
  public:
  B() : i_(0) {}
  virtual ~B() {}
  virtual void f(int i) = 0;
  int get() const { return i_; }
  protected:
  int i_;
};
class D : public B {
  public:
  void f(int i) override { i_ += i; }
};
\end{code}

And, here is the equivalent non-virtual one:

\begin{code}
// Example 01
class A {
  public:
  A() : i_(0) {}
  void f(int i) { i_ += i; }
  int get() const { return i_; }
  protected:
  int i_;
};
\end{code}

We can now call both of them in a micro-benchmark fixture and measure how long each call takes:

\begin{code}
void BM_none(benchmark::State& state) {
  A* a = new A;
  int i = 0;
  for (auto _ : state) a->f(++i);
  benchmark::DoNotOptimize(a->get());
  delete a;
}
void BM_dynamic(benchmark::State& state) {
  B* b = new D;
  int i = 0;
  for (auto _ : state) b->f(++i);
  benchmark::DoNotOptimize(b->get());
  delete b;
}
\end{code}

The \texttt{benchmark::DoNotOptimize} wrapper prevents the compiler from optimizing away the unused object, and, along with it, removing the entire set of function calls as unnecessary. Note that there is a subtlety in measuring the virtual function call time; a simpler way to write the code would be to avoid the \texttt{new} and \texttt{delete} operators and simply construct the derived object on the stack:

\begin{code}
void BM_dynamic(benchmark::State& state) {
  D d;
  int i = 0;
  for (auto _ : state) d.f(++i);
  benchmark::DoNotOptimize(b->get());
}
\end{code}

However, this benchmark is likely to yield the same time as the non-virtual function call. The reason is not that a virtual function call has no overhead. Rather, in this code, the compiler is able to deduce that the call to the virtual function, \texttt{f()}, is always a call to \texttt{D::f()} (it helps that the call is not done through the base class pointer, but rather the derived class reference, so it could hardly be anything else). A decent optimizing compiler will de-virtualize such a call, for instance, generating a direct call to \texttt{D::f()} without the indirection and the reference to the \emph{v-table}. Such a call can even be inlined.

Another possible complication is that both microbenchmarks, especially the non-virtual call, may be too fast---the body of the benchmark loop is likely to take less time than the overhead of the loop. We can remedy that by making several calls inside the body of the loop. This can be accomplished with the copy-paste feature of your editor, or with the C++ preprocessor macros:

\begin{code}
#define REPEAT2(x) x x
#define REPEAT4(x) REPEAT2(x) REPEAT2(x)
#define REPEAT8(x) REPEAT4(x) REPEAT4(x)
#define REPEAT16(x) REPEAT8(x) REPEAT8(x)
#define REPEAT32(x) REPEAT16(x) REPEAT16(x)
#define REPEAT(x) REPEAT32(x)
\end{code}

Now, inside the benchmark loop, we can write the following:

\begin{code}
REPEAT(b->f(++i);)
\end{code}

The per-iteration time reported by the benchmark now refers to \texttt{32} function calls. While this does not matter for comparing the two calls, it may be convenient to make the benchmark itself report the true number of calls per second by adding this line to the end of the benchmark fixture, after the loop:

\begin{code}
state.SetItemsProcessed(32*state.iterations());
\end{code}

We can now compare the results of the two benchmarks:

\begin{code}
Benchmark           Time UserCounters...
BM_none          1.60 ns items_per_second=19.9878G/s
BM_dynamic       9.04 ns items_per_second=3.54089G/s
\end{code}

We see that the virtual function call is almost 10 times more expensive than the non-virtual one. Note that this is not exactly a fair comparison; the virtual call provides additional functionality. However, some of this functionality can be implemented in other ways, without paying the performance overhead.

\subsection{Introducing CRTP}

Now, we will introduce CRTP, which turns inheritance on its head:

\begin{code}
template <typename D> class B {
  ...
};
class D : public B<D> {
  ...
};
\end{code}

The first change that jumps out is that the base class is now a \texttt{class} template. The derived class still inherits from the base class, but now from the specific instantiation of the base class template---on its own! Class \texttt{B} is instantiated on class \texttt{D}, and class \texttt{D} inherits from that instantiation of class \texttt{B}, which is instantiated on class \texttt{D}, which inherits from class \texttt{B}, which... that's recursion in action. Get used to it because you will see it often in this chapter.

What is the motivation for this mind-twisting pattern? Consider that now the base class has compile-time information about the derived class. Therefore, what used to be a virtual function call can now be bound to the right function at compile time:

\begin{code}
// Example 01
template <typename D> class B {
  public:
  B() : i_(0) {}
  void f(int i) { static_cast<D*>(this)->f(i); }
  int get() const { return i_; }
  protected:
  int i_;
};
class D : public B<D> {
  public:
  void f(int i) { i_ += i; }
};
\end{code}

The call itself can still be done on the base class pointer:

\begin{code}
B<D>* b = ...;
b->f(5);
\end{code}

There is no indirection and no overhead for the virtual call. The compiler can, at compile time, track the call all the way to the actual function called, and even inline it:

\begin{code}
void BM_static(benchmark::State& state) {
  B<D>* b = new D;
  int i = 0;
  for (auto _ : state) {
    REPEAT(b->f(++i);)
  }
  benchmark::DoNotOptimize(b->get());
  state.SetItemsProcessed(32*state.iterations());
}
\end{code}

The benchmark shows that the function call made through the CRTP takes exactly as much time as a regular function call:

\begin{code}
Benchmark           Time UserCounters...
BM_none          1.60 ns items_per_second=19.9878G/s
BM_dynamic       9.04 ns items_per_second=3.54089G/s
BM_static        1.55 ns items_per_second=20.646G/s
\end{code}

The main restriction on the CRTP is that the size of the base class, \texttt{B}, cannot depend on its template parameter, \texttt{D}. More generally, the template for class \texttt{B} has to instantiate with type \texttt{D} being an incomplete type. For example, this will not compile:

\begin{code}
template <typename D> class B {
  using T = typename D::T;
  T* p_;
};
class D : public B<D> {
  using T = int;
};
\end{code}

The realization that this code will not compile may come somewhat as a surprise, given how similar it is to many widely used templates that refer to the nested types of their template parameters. For example, consider this template, which converts any sequence container with \texttt{push\_back()} and \texttt{pop\_back()} functions to a stack:

\begin{code}
template <typename C> class stack {
  C c_;
  public:
  using value_type = typename C::value_type;
  void push(const valuetype& v) { c.push_back(v); }
  value_type pop() {
    value_type v = c.back();
    c.pop_back();
    return v;
  }
};
stack<std::vector<int>> s;
\end{code}

Note that the \texttt{using} type alias for \texttt{value\_type} looks exactly the same as the preceding one, in our attempt to declare class \texttt{B}. So, what is wrong with the one in \texttt{B}? Actually, nothing is wrong with class \texttt{B} itself. It would compile just fine in a context similar to that of our stack class:

\begin{code}
class A {
  public:
  using T = int;
  T x_;
};
B<A> b; // Compiles with no problems
\end{code}

The problem lies not with class \texttt{B} itself, but with our intended use of it:

\begin{code}
class D : public B<D> ...
\end{code}

At the point where \texttt{B\textless{}D\textgreater{}} has to be known, type \texttt{D} has not been declared yet. It cannot be---the declaration of class \texttt{D} requires us to know exactly what the base class \texttt{B\textless{}D\textgreater{}} is. So, if class \texttt{D} has not been declared yet, how does the compiler know that the identified \texttt{D} even refers to a type? After all, you cannot instantiate a template on a completely unknown type. The answer lies somewhere in between---class \texttt{D} is forward-declared, the same as if we had this code:

\begin{code}
class A;
B<A> b; // Now does not compile
\end{code}

Some templates can be instantiated on forward-declared types, while others cannot. The exact rules can be painstakingly gathered from the standard, but the gist is this---anything that might affect the size of the class has to be fully declared. A reference to a type declared inside an incomplete type, such as our \texttt{using\ T\ =\ typename\ D::T}, would be a forward declaration of a nested class, and those are not allowed either.

On the other hand, the body of a member function of a class template is not instantiated until it's called. In fact, for a given template parameter, a member function does not even have to compile, as long as it's not called. Therefore, references to the derived class, its nested types, and its member functions, inside the member functions of the base class are perfectly fine. Also, since the derived class type is considered forward-declared inside the base class, we can declare pointers and references to it. Here is a very common refactoring of the CRTP base class that consolidates the uses of the static cast in one place:

\begin{code}
template <typename D> class B {
  ...
  void f(int i) { derived()->f(i); }
  D* derived() { return static_cast<D*>(this); }
};
class D : public B<D> {
  ...
  void f(int i) { i_ += i; }
};
\end{code}

The base class declaration owns a pointer to the incomplete (forward-declared) type \texttt{D}. It works like any other pointer to an incomplete type; by the time the pointer is de-referenced, the type has to be complete. In our case, this happens inside the body of the member function; \texttt{B::f()}, which, as we discussed, is not compiled until it's called by the client code.

So what do we do if we need to use a nested type of the derived class while writing the base class? Inside a function body, there is no problem. If we need to use the nested type in the base class itself, it is usually for one of two reasons. The first is to declare the return type of a member function:

\begin{code}
// Example 01a
template <typename D> class B {
  typename D::value_type get() const {
    return static_cast<const D*>(this)->get();
  }
  鈥?
};
D : public B<D> {
  using value_type = int;
  value_type get() const { 鈥?};
  鈥?
};
\end{code}

As we have just discussed, this will not compile. Fortunately, this problem is easy to solve, all we have to do is let the compiler deduce the return type:

\begin{code}
// Example 01a
template <typename D> class B {
  auto get() const {
    return static_cast<const D*>(this)->get();
  }
  鈥?
};
\end{code}

The second case is more difficult: the nested type is needed to declare a data member or a parameter. In this case, there is only one option left: the type should be passed into the base class as an additional template parameter. Of course, it introduces some redundancy into the code, but it can't be helped:

\begin{code}
// Example 01a
template <typename T, typename value_type> class B {
  value_type value_;
  鈥?
};
class D : public B<D, int> {
  using value_type = int;
  value_type get() const { 鈥?}
  鈥?
};
\end{code}

Now that we know what is CRTP and how to code it, let us see what design problems can be solved with it.

\section{CRTP and static polymorphism}

Since CRTP allows us to override base class functions with those of the derived class, it implements polymorphic behavior. The key difference is that polymorphism happens at compile time, not at runtime.

\subsection{Compile-time polymorphism}

As we have just seen, CRTP can be used to allow the derived class to customize the behavior of the base class:

\begin{code}
template <typename D> class B {
  public:
  ...
  void f(int i) { static_cast<D*>(this)->f(i); }
  protected:
  int i_;
};
class D : public B<D> {
  public:
  void f(int i) { i_ += i; }
};
\end{code}

If the base class \texttt{B::f()} method is called, it dispatches the call to the derived class method for the real derived class, just like a virtual function does. Of course, in order to fully take advantage of this polymorphism, we have to be able to call the methods of the base class through the base class pointer. Without this ability, we are simply calling methods of the derived class whose type we already know:

\begin{code}
D* d = ...; // Get an object of type D
d->f(5);
B<D>* b = ...; // Also has to be an object of type D
b->f(5);
\end{code}

Note that the function call looks exactly like any virtual function class, with the base class pointer. The actual function, \texttt{f()}, that is called comes from the derived class, \texttt{D::f()}. There is, however, a significant difference---the actual type of the derived class, \texttt{D}, has to be known at compile time---the base class pointer is not \texttt{B*} but rather \texttt{B\textless{}D\textgreater{}*}, which implies that the derived object is of type \texttt{D}. There does not seem to be much point to such \emph{polymorphism} if the programmer has to know the actual type. But, that is because we have not fully thought through what \emph{compile-time polymorphism} really means. Just as the benefit of a virtual function is that we can call member functions of a type we don't even know exists, the same has to be true for \emph{static polymorphism} to be useful.

How do we write a function that has to compile for parameters of an unknown type? With a function template, of course:

\begin{code}
// Example 01
template <typename D> void apply(B<D>* b, int& i) {
  b->f(++i);
}
\end{code}

This is a template function that can be called on any base class pointer, and it automatically deduces the type of the derived class, \texttt{D}. Now, we can write what looks like regular polymorphic code:

\begin{code}
B<D>* b = new D;    // 1
apply(b);         // 2
\end{code}

Note that, on line one, the object has to be constructed with the knowledge of the actual type. This is always the case; the same is true for regular runtime polymorphism with virtual functions:

\begin{code}
void apply(B* b) { ... }
B* b = new D;    // 1
apply(b);        // 2
\end{code}

In both cases, on line two, we invoke some code that was written only with the knowledge of the base class. The difference is that, with run-time polymorphism, we have a common base class and some functions that operate on it. With CRTP and static polymorphism, there is a common base class template but no single common base class (a template is not a type) and every function that operates on this base template becomes a template itself. To make the symmetry (not equivalence!) between the two types of polymorphism complete, we just need to figure out two more special cases: pure virtual functions and polymorphic destruction. Let's start with the former.

\subsection{The compile-time pure virtual function}

What would be the equivalent of the pure virtual function in the CRTP scenario? A pure virtual function must be implemented in all derived classes. A class that declares a pure virtual function, or inherits one and does not override it, is an abstract class; it can be further derived from, but it cannot be instantiated.

When we contemplate the equivalent of a pure virtual function for static polymorphism, we realize that our CRTP implementation suffers from a major vulnerability. What happens if we forget to override the \emph{compile-time virtual function,} \texttt{f()}, in one of the derived classes?

\begin{code}
// Example 02
template <typename D> class B {
  public:
  ...
  void f(int i) { static_cast<D*>(this)->f(i); }
};
class D : public B<D> {
  // no f() here!
};
...
B<D>* b = ...;
b->f(5); // 1
\end{code}

This code compiles with no errors or warnings---on line one, we call \texttt{B::f()}, which, in turn, calls \texttt{D::f()}. Class \texttt{D} does not declare its own version of the member \texttt{f()}, so the one inherited from the base class is the one that is called. That is, of course, the member function, \texttt{B::f()}, that we have already seen, which again calls \texttt{D::f()}, which is really \texttt{B::f()} \texttt{...} and we have an infinite loop.

The problem here is that nothing requires us to override the member function \texttt{f()} in the derived class, but the program is malformed if we don't. The root of the problem is that we are mixing together the interface and the implementation---the public member function declaration in the base class says that all derived classes must have a function, \texttt{void\ f(int)}, as a part of their public interface. The derived class's version of the same function provides the actual implementation. We will cover separating the interface and the implementation in \emph{Chapter 14, The Template Method Pattern and the Non-Virtual Idiom}, but for now, suffice it to say that our life would be a lot easier if these functions had different names:

\begin{code}
// Example 03
template <typename D> class B {
  public:
  ...
  void f(int i) { static_cast<D*>(this)->f_impl(i); }
};
class D : public B<D> {
  void f_impl(int i) { i_ += i; }
};
...
B<D>* b = ...;
b->f(5);
\end{code}

What happens now if we forget to implement \texttt{D::f\_impl()}? The code does not compile, because there is no such member function in class \texttt{D}, either directly or through inheritance. So, we have implemented a compile-time pure virtual function! Note that the virtual function is actually \texttt{f\_impl()}, not \texttt{f()}.

With that accomplished, how would we implement a regular virtual function, with a default implementation that can be optionally overridden? If we follow the same pattern of separating the interface and the implementation, we only have to provide the default implementation for \texttt{B::f\_impl()}:

\begin{code}
// Example 03
template <typename D> class B {
  public:
  ...
  void f(int i) { static_cast<D*>(this)->f_impl(i); }
  void f_impl(int i) {}
};
class D1 : public B<D1> {
  void f_impl(int i) { i_ += i; }
};
class D2 : public B<D2> {
  // No f() here
};
...
B<D1>* b = ...;
b->f(5); // Calls D1::f_impl()
B<D2>* b1 = ...;
b1->f(5); // Calls B::f_impl() by default
\end{code}

The last special case we need to cover is polymorphic destruction.

\subsection{Destructors and polymorphic deletion}

So far, we have willfully avoided tackling the issue of deleting objects implemented with CRTP in some sort of polymorphic fashion. In fact, if you go back and reread the examples that presented complete code, such as the benchmark fixture, \texttt{BM\_static}, in the \emph{Introducing CRTP} section, we either avoided deleting the object altogether or constructed a derived object on the stack. This is because polymorphic deletion presents an additional complication that we are finally ready to deal with.

First of all, let's note that, in many cases, polymorphic deletion is not a concern. All objects are created with their actual types known. If the code that constructs the objects also owns and eventually deletes them, the question \emph{what is the type of the deleted object?} is never really asked. Similarly, if the objects are stored in a container, they are not deleted through the base class pointer or reference:

\begin{code}
template <typename D> void apply(B<D>& b) {
  ... operate on b ...
}
{
  std::vector<D> v;
  v.push_back(D(...)); // Objects created as D
  ...
  apply(v[0]); // Objects processed as B&
} // Objects deleted as D
\end{code}

In many cases, as shown in the preceding example, the objects are constructed and deleted with their actual type known and no polymorphism involved, but the code that works on them in between is universal, written to work on the base type and, therefore, any class derived from that base type.

But, what if we need to actually delete the object through the base class pointer? Well, that is not easy. First of all, a simple call to the \texttt{delete} operator will do the wrong thing:

\begin{code}
B<D>* b = new D;
...
delete b;
\end{code}

This code compiles. Worse, even the compilers that normally warn when a class has a virtual function but a non-virtual destructor do not generate any warnings in this case, because there are no virtual functions, and CRTP polymorphism is not recognized by the compiler as a potential source of trouble. However, the trouble there is that only the destructor of the base class, \texttt{B\textless{}D\textgreater{}}, itself is called; the destructor of \texttt{D} is never called!

You may be tempted to resolve this problem the same way as we deal with other \emph{compile-time virtual} functions, by casting to the known derived type and calling the indented member function of the derived class:

\begin{code}
template <typename D> class B {
  public:
  ~B() { static_cast<D*>(this)->~D(); }
};
\end{code}

Unlike the regular functions, this attempt at polymorphism is badly broken, for not one but two reasons---first of all, in the destructor of the base class, the actual object is not of the derived type anymore, and calling any member functions of the derived class on it results in undefined behavior. Secondly, even if this somehow worked, the destructor of the derived class is going to do its work and then call the destructor of the base class, which results in an infinite loop.

There are two solutions to this problem. One option is to extend the compile-time polymorphism to the act of deletion in the same way as we do for any other operation, with a function template:

\begin{code}
template <typename D> void destroy(B<D>* b) {
  delete static_cast<D*>(b);
}
\end{code}

This is well-defined. The \texttt{delete} operator is called on the pointer of the actual type, \texttt{D}, and the right destructor is called. However, you must take care to always delete these objects using this \texttt{destroy()} function, instead of calling the \texttt{delete} operator.

The second option is to actually make the destructor virtual. This does bring back the overhead of the virtual function call, but only for the destructor. It also increases the object size by the size of the virtual pointer. If neither of these two sources of overhead is a concern, you could use this hybrid static-dynamic polymorphism, where all virtual function calls are bound at compile time and with no overhead, except the destructor.

\subsection{CRTP and access control}

When implementing CRTP classes, you do have to worry about access---any method you want to call has to be accessible. Either the method has to be public, or the caller has to have special access. This is a little different from the way virtual functions are called---when calling a virtual function, the caller must have access to the member function that is named in the call. For example, a call to the base class function, \texttt{B::f()}, requires that either \texttt{B::f()} is public or the caller has access to non-public member functions (another member function of class \texttt{B} can call \texttt{B::f()} even if it's private). Then, if \texttt{B::f()} is virtual and overridden by the derived class \texttt{D}, the override \texttt{D::f()} is actually called at \textbf{runtime}. There is no requirement that \texttt{D::f()} be accessible from the original call site; for example, \texttt{D::f()} can be private.

The situation with CRTP polymorphic calls is somewhat different. All calls are explicit in the code, and the callers must have access to the functions they call. Usually, it means that the base class must have access to the member functions of the derived class. Consider the following example from an earlier section, but now with explicit access control:

\begin{code}
template <typename D> class B {
  public:
  ...
  void f(int i) { static_cast<D*>(this)->f_impl(i); }
  private:
  void f_impl(int i) {}
};
class D : public B<D> {
  private:
  void f_impl(int i) { i_ += i; }
  friend class B<D>;
};
\end{code}

Here, both functions, \texttt{B::f\_impl()} and \texttt{D::f\_impl()}, are private in their respective classes. The base class has no special access to the derived class, and cannot call its private member functions. Unless we want to change the member function, \texttt{D::f\_impl()}, from private to public and allow any caller access to it, we have to declare the base class to be a friend of the derived class.

There is also some benefit in doing the reverse. Let's create a new derived class, \texttt{D1}, with a different override of the implementation function, \texttt{f\_impl()}:

\begin{code}
class D1 : public B<D> {
  private:
  void f_impl(int i) { i_ -= i; }
  friend class B<D1>;
};
\end{code}

This class has a subtle error---it is not actually derived from \texttt{B\textless{}D1\textgreater{}} but from the old class, \texttt{B\textless{}D\textgreater{}}; a mistake that is easy to make when creating a new class from an old template. This mistake will be found if we attempt to use the class polymorphically:

\begin{code}
B<D1>* b = new D1;
\end{code}

This does not compile because \texttt{B\textless{}D1\textgreater{}} is not a base class of \texttt{D1}. However, not all uses of CRTP involve a polymorphic call. In any case, it would be better if the error was caught when class \texttt{D1} was first declared. We can accomplish that by making class \texttt{B} into a sort of abstract class, only in the sense of static polymorphism. All it takes is to make the constructor of class \texttt{B} private and to declare the derived class to be a friend:

\begin{code}
template <typename D> class B {
  int i_;
  B() : i_(0) {}
  friend D;
  public:
  void f(int i) { static_cast<D*>(this)->f_impl(i); }
  private:
  void f_impl(int i) {}
};
\end{code}

Note the somewhat unusual form of the friend declaration---\texttt{friend\ D} and not \texttt{friend\ class\ D}. This is how you write a friend declaration for the template parameter. Now, the only type that can construct an instance of class \texttt{B\textless{}D\textgreater{}} is that specific derived class, \texttt{D}, which is used as the template parameter, and the erroneous code, \texttt{class\ D1\ :\ public\ B\textless{}D\textgreater{}}, does not compile any longer.

Now that we know how CRTP works, let us see what it is useful for.

\section{CRTP as a delegation pattern}

So far, we have used CRTP as a compile-time equivalent of dynamic polymorphism, including virtual-like calls through the base pointer (compile-time, of course, with a template function). This is not the only way CRTP can be used. In fact, more often than not, the function is called directly on the derived class. This is a very fundamental difference---typically, public inheritance expresses the \emph{is-a} relationship---the derived object is a kind of a base object. The interface and the generic code are in the base class, while the derived class overrides the specific implementation. This relation continues to hold when a CRTP object is accessed through the base class pointer or reference. Such use of CRTP is sometimes also called a \textbf{static interface}.

When the derived object is used directly, the situation is quite different---the base class is no longer the interface, and the derived class is not just the implementation. The derived class expands the interface of the base class, and the base class delegates some of its behavior to the derived class.

\subsection{Expanding the interface}

Let's consider several examples where CRTP is used to delegate behavior from the base class to the derived one.

The first example is a very simple one---for any class that provides \texttt{operator+=()}, we want to generate \texttt{operator+()} automatically that used the former:

\begin{code}
// Example 04
template <typename D> struct plus_base {
  D operator+(const D& rhs) const {
    D tmp = rhs;
    tmp += static_cast<const D&>(*this);
    return tmp;
  }
};
class D : public plus_base<D> {
  int i_;
  public:
  explicit D(int i) : i_(i) {}
  D& operator+=(const D& rhs) {
    i_ += rhs.i_;
    return *this;
  }
};
\end{code}

Any class that inherits from \texttt{plus\_base} in this manner automatically acquires the addition operator that is guaranteed to match the provided increment operator. The observant among you might point out that the way we have declared the operator \texttt{+} here is, well, strange. Aren't two-argument operators supposed to be non-member functions? Indeed, they usually are. Nothing in the standard requires them to be, and the preceding code is technically valid. The reason binary operators such as \texttt{==}, \texttt{+}, and so on are usually declared as non-member functions has to do with implicit conversions---if we have an addition, \texttt{x\ +\ y}, and the intended \texttt{operator+} is a member function, it has to be a member function of the \texttt{x} object. Not any object implicitly convertible to the type of \texttt{x}, but \texttt{x} itself---it's a member function call on \texttt{x}. In contrast, the \texttt{y} object has to be implicitly convertible to the type of the argument of that member \texttt{operator+} usually, the same type as \texttt{x}. To restore the symmetry and allow implicit conversions (if any are provided) on both the left- and right-hand side of the \texttt{+} sign, we have to declare \texttt{operator+} as a non-member function. Usually, such a function needs to have access to the private data members of the class, as in the example previously, so it has to be declared a friend. Putting all of this together, we arrive at this alternative implementation:

\begin{code}
// Example 05
template <typename D> struct plus_base {
  friend D operator+(const D& lhs, const D& rhs) {
    D tmp = lhs;
    tmp += rhs;
    return tmp;
  }
};
class D : public plus_base<D> {
  int i_;
  public:
  explicit D(int i) : i_(i) {}
  D& operator+=(const D& rhs) {
    i_ += rhs.i_;
    return *this;
  }
};
\end{code}

There is a significant difference between this use of CRTP and the one we saw earlier---the object that is going to be used in the program is of type \texttt{C}, and it will never be accessed through a pointer to \texttt{plus\_base\textless{}C\textgreater{}}. The latter isn't a complete interface for anything but is really an implementation that makes use of the interface provided by the derived class. CRTP here is used as an implementation technique, not as a design pattern. However, the boundary between the two is not always clear: some implementation techniques are so powerful that they can alter design choices.

One example is the generated comparison and ordering operations. In C++20, the recommended choice for designing interfaces of value types (or any other comparable and ordered types) is to provide only two operators, \texttt{operator==()} and \texttt{operator\textless{}=\textgreater{}()}. The compiler will generate the rest. If you like this approach to interface design and want to use it in earlier versions of C++, you need a way to implement it. CRTP offers us a possible implementation. We will need a base class that will generate \texttt{operator!=()} from the \texttt{operator==()} of the derived class. It will also generate all ordering operators; of course, we cannot use \texttt{operator\textless{}=\textgreater{}()} before C++20, but we can use any member function name we agree on, such as \texttt{cmp()}:

\begin{code}
template <typename D> struct compare_base {
  friend bool operator!=(const D& lhs, const D& rhs) {
    return !(lhs == rhs); }
  friend bool operator<=(const D& lhs, const D& rhs) {
    return lhs.cmp(rhs) <= 0;
  }
  friend bool operator>=(const D& lhs, const D& rhs) {
    return lhs.cmp(rhs) >= 0;
  }
  friend bool operator< (const D& lhs, const D& rhs) {
    return lhs.cmp(rhs) <  0;
  }
  friend bool operator> (const D& lhs, const D& rhs) {
    return lhs.cmp(rhs) >  0;
  }
};
class D : public compare_base<D> {
  int i_;
  public:
  explicit D(int i) : i_(i) {}
  auto cmp(const D& rhs) const {
    return (i_ < rhs.i_) ? -1 : ((i_ > rhs.i_) ? 1 : 0);
  }
  bool operator==(const D& rhs) const {
    return i_ == rhs.i_;
  }
};
\end{code}

There are many such examples to be found in the literature on CRTP. Along with these examples, you can find discussions on whether C++20 concepts offer a better alternative. The next section explains what this is about.

\subsection{CRTP and concepts}

At the first glance, it is unclear how concepts could replace CRTP. Concepts (which you can read more about in \emph{Chapter 7, SFINAE, Concepts, and Overload Resolution Management}) are all about restricting interfaces, while CRTP extends the interfaces.

There are discussions inspired by cases where both concepts and CRTP can solve the same problem by totally different means. Recall our use of CRTP to automatically generate \texttt{operator+()} from \texttt{operator+=()}; all we had to do was to inherit from the special base class template:

\begin{code}
// Example 05
template <typename D> struct plus_base {
  friend D operator+(const D& lhs, const D& rhs) { 鈥?}
};
class D : public plus_base<D> {
  D& operator+=(const D& rhs) { 鈥?}
};
\end{code}

Our base class serves two purposes. First, it generates \texttt{operator+()} from \texttt{operator+=()}. Second, it provides a mechanism for classes to opt into this automation: to receive the generated \texttt{operator+()}, a class must inherit from \texttt{plus\_base}.

The first problem by itself is easy to solve, we can just define a global \texttt{operator+()} template:

\begin{code}
template <typename T>
T operator+(const T& lhs, const T& rhs) {
  T tmp = lhs;
  tmp += rhs;
  return tmp;
}
\end{code}

There is a ``slight'' problem with this template: we just provided a global \texttt{operator+()} for every type in our program, whether it needs one or not. Furthermore, most of the time it won't even compile since not all classes define \texttt{operator+=()}.

This is where the concepts come in: we can restrict the applicability of our new \texttt{operator+()} so, in the end, it is generated for the same types that we would have otherwise inherited from \texttt{plus\_base} and no other.

One way to do this is to require that the template parameter type T at least have the increment operator:

\begin{code}
template <typename T>
requires( requires(T a, T b) { a += b; } )
T operator+(const T& lhs, const T& rhs) { 鈥?}
\end{code}

However, this is not the same result as what we got with CRTP. In some cases, it may be a better result: instead of having to opt every class into the automatic generation of \texttt{operator+()}, we did it for every class that satisfies certain restrictions. But in other cases, any reasonable description of these restrictions produces overly broad results, and we have to opt into our types one by one. This is easy to do with concepts as well, but the technique used is not widely known. All you need to do is to define a concept whose general case is false (a Boolean variable will suffice):

\begin{code}
template <typename T>
constexpr inline bool gen_plus = false; // General
template <typename T>
requires gen_plus<T>
T operator+(const T& lhs, const T& rhs) { 鈥?}
\end{code}

Then, for every type that needs to opt in, we specialize the concept:

\begin{code}
class D { // No special base
  D& operator+=(const D& rhs) { 鈥?}
};
template <>
constexpr inline bool generate_plus<D> = true; // Opt-in
\end{code}

There are some advantages to both approaches: CRTP uses a base class that can be more complex than just a wrapper for a definition of an operator; while concepts can combine explicit opt-in with some more general restrictions when appropriate. However, these discussions miss a much more important distinction: CRTP can be used to expand class interface with both member and non-member functions, while concepts can be used only with non-member functions, including non-member operators. When both concepts and CRTP-based solutions are applicable, you should choose the most appropriate one (for simple functions such as \texttt{operator+()}, concepts are probably easier to read). Also, you don't have to wait until C++20 to use the concept-based restrictions: the methods of emulating concepts shown in \emph{Chapter 7, SFINAE, Concepts, and Overload Resolution Management}, are more than adequate here.

Of course, we can use concepts with CRTP instead of trying to replace CRTP: if the CRTP base class template has some requirements on the type we want to derive from it, we can enforce these with concepts. The use of concepts here is no different from what we find in the chapter dedicated to them. But we are going to stay with CRTP and what else can be done with it.

\section{CRTP as an implementation technique}

As we pointed out earlier, CRTP is often used as a purely implementation pattern; however, even in this role, it can influence design: some design choices are desirable but hard to implement, and, if a good implementation technique comes along, the design choices often change. So, let us see what problems can be solved with CRTP.

\subsection{CRTP for code reuse}

Let us start with a specific implementation issue: we have multiple classes that have some common code. Ordinarily, we would write a base class for them. But the common code is not really common: it does the same thing for all classes except it for the types it uses. What we need is not a common base class but a common base class template. And that brings us to CRTP.

An example is an object registry. It may be desirable, often for debugging purposes, to know how many objects of a certain type are currently in existence, and perhaps even to maintain a list of such objects. We definitely do not want to instrument every class with the registry mechanism, so we want to move it to the base class. But, now we have a problem---if we have two derived classes, \texttt{C} and \texttt{D}, both inherit from the same base class, \texttt{B}, and the count of instances of \texttt{B} will be the total for both \texttt{C} and \texttt{D}. The problem is not that the base class can't determine what the real type of the derived class is---it can, if we're willing to pay the cost of runtime polymorphism. The problem is that the base class has only one counter (or however many are coded in the class), while the number of different derived classes is unlimited. We could implement a very complex, expensive, and non-portable solution that uses \textbf{Run-Time Type Information} (\textbf{RTTI}), such as \texttt{typeid}, to determine the class name and maintain a map of names and counters. But, what we really need is one counter per derived type, and the only way to do it is to make the base class aware of the derived class type at compile time. This brings us back to CRTP:

\begin{code}
// Example 08
template <typename D> class registry {
  public:
  static size_t count;
  static D* head;
  D* prev;
  D* next;
  protected:
  registry() {
    ++count;
    prev = nullptr;
    next = head;
    head = static_cast<D*>(this);
    if (next) next->prev = head;
  }
  registry(const registry&) {
    ++count;
    prev = nullptr;
    next = head;
    head = static_cast<D*>(this);
    if (next) next->prev = head;
  }
  ~registry() {
    --count;
    if (prev) prev->next = next;
    if (next) next->prev = prev;
    if (head == this) head = next;
  }
};
template <typename D> size_t registry<D>::count(0);
template <typename D> D* registry<D>::head(nullptr);
\end{code}

We have declared the constructor and the destructor protected because we don't want any registry objects created, except by the derived classes. It is also important to not forget the copy constructor, otherwise, the default one is generated by the compiler, and it does not increment the counter or update the list (but the destructor does, so the counter will go negative and overflow). For each derived class, \texttt{D}, the base class is \texttt{registry\textless{}D\textgreater{}}, which is a separate type with its own static data members, \texttt{count} and \texttt{head} (the latter is the head of the list of currently active objects). Any type that needs to maintain the runtime registry of active objects now only needs to inherit from \texttt{registry}:

\begin{code}
// Example 08
class C : public registry<C> {
  int i_;
  public:
  C(int i) : i_(i) {}
};
\end{code}

A similar example, where the base class needs to know the type of the derived class and use it to declare its own members, can be found in \emph{Chapter 9, Named Arguments, Method Chaining, and Builder Pattern}. Next, we will see another example of CRTP, and this time the availability of the implementation opens the door to a particular design choice.

\subsection{CRTP for generic interfaces}

Another scenario where it is often necessary to delegate behavior to derived classes is the problem of visitation. Visitors, in a general sense, are objects that are invoked to process a collection of data objects and execute a function on each one in turn. Often, there are hierarchies of visitors, where the derived classes customize or alter some aspect of the behavior of the base classes. While the most common implementation of visitors uses dynamic polymorphism and virtual function calls, a static visitor offers the same sort of performance benefits we saw earlier. Visitors are not usually invoked polymorphically; you create the visitor you want and run it. The base visitor class, however, does call the member functions that may be dispatched, at compile time, to the derived classes if they have the right overrides. Consider this generic visitor for a collection of animals:

\begin{code}
// Example 09
struct Animal {
  public:
  enum Type { CAT, DOG, RAT };
  Animal(Type t, const char* n) : type(t), name(n) {}
  const Type type;
  const char* const name;
};
template <typename D> class GenericVisitor {
  public:
  template <typename it> void visit(it from, it to) {
    for (it i = from; i != to; ++i) {
      this->visit(*i);
    }
  }
  private:
  D& derived() { return *static_cast<D*>(this); }
  void visit(const Animal& animal) {
    switch (animal.type) {
      case Animal::CAT:
        derived().visit_cat(animal); break;
      case Animal::DOG:
        derived().visit_dog(animal); break;
      case Animal::RAT:
        derived().visit_rat(animal); break;
    }
  }
  void visit_cat(const Animal& animal) {
    cout << "Feed the cat " << animal.name << endl;
  }
  void visit_dog(const Animal& animal) {
    cout << "Wash the dog " << animal.name << endl;
  }
  void visit_rat(const Animal& animal) {
  cout << "Eeek!" << endl;
}
  friend D;
  GenericVisitor() = default;
};
\end{code}

Note that the main visitation method is a template member function (a template within a template!), and it accepts any kind of iterator that can iterate over a sequence of \texttt{Animal} objects. Also, by declaring a private default constructor at the bottom of the class, we are protecting ourselves from making a mistake where the derived class incorrectly specifies its own type for the inheritance. Now, we can start creating some visitors. The default visitor simply accepts the default actions provided by the generic visitor:

\begin{code}
class DefaultVisitor :
  public GenericVisitor<DefaultVisitor> {
};
\end{code}

We can visit any sequence of \texttt{Animal} objects, for example, a vector:

\begin{code}
std::vector<Animal> animals {
  {Animal::CAT, "Fluffy"},
  {Animal::DOG, "Fido"},
  {Animal::RAT, "Stinky"}};
DefaultVisitor().visit(animals.begin(), animals.end());
\end{code}

The visitation yields the expected result:

\begin{code}
Feed the cat Fluffy
Wash the dog Fido
Eeek!
\end{code}

But, we don't have to constrain ourselves to the default actions---we can override the visitation actions for one or more animal types:

\begin{code}
class TrainerVisitor :
  public GenericVisitor<TrainerVisitor> {
  friend class GenericVisitor<TrainerVisitor>;
  void visit_dog(const Animal& animal) {
    cout << "Train the dog " << animal.name << endl;
  }
};
class FelineVisitor :
  public GenericVisitor<FelineVisitor> {
  friend class GenericVisitor<FelineVisitor>;
  void visit_cat(const Animal& animal) {
    cout << "Hiss at the cat " << animal.name << endl;
  }
  void visit_dog(const Animal& animal) {
    cout << "Growl at the dog " << animal.name << endl;
  }
  void visit_rat(const Animal& animal) {
    cout << "Eat the rat " << animal.name << endl;
  }
};
\end{code}

When a dog trainer chooses to visit our animals, we use \texttt{TrainerVisitor}:

\begin{code}
Feed the cat Fluffy
Train the dog Fido
Eeek!
\end{code}

Finally, a visiting cat would have a set of actions all of its own:

\begin{code}
Hiss at the cat Fluffy
Growl at the dog Fido
Eat the rat Stinky
\end{code}

We will learn a lot more about different kinds of visitors later, in \emph{Chapter 17, The Visitor Pattern and Multiple Dispatch}. Now, however, we are going to explore the use of CRTP in conjunction with another common pattern.

\section{CRTP and policy-based design}

Policy-based design is a compile-time variant of the well-known Strategy pattern; we have an entire chapter dedicated to it, \emph{Chapter 15}, aptly named \emph{Policy-Based Design}. Here, we're going to stay focused on the use of CRTP to provide additional functionality to the derived classes. Specifically, we are going to generalize the use of CRTP base classes to extend the interface of the derived class.

So far, we have used one base class to add features to the derived class:

\begin{code}
template <typename D> struct plus_base {鈥;
class D : public plus_base<D> {鈥;
\end{code}

However, if we want to extend the interface of the derived class in multiple ways, a single base class presents an unnecessary restriction. First of all, if we add several member functions, the base class can get quite large. Second, we may want a more modular approach to the interface design. For example, we can have one base class template that adds factory construction methods to any derived class:

\begin{code}
// Example 10
template <typename D> struct Factory {
  template <typename... Args>
  static D* create(Args&&... args) {
    return new D(std::forward<Args>(args)...);
  }
  static void destroy(D* d) { delete d; }
};
\end{code}

We can even have several different factories that present the same interface but allocate memory differently. We can have another base class template that adds the conversion to string to any class that has the stream inserter operator:

\begin{code}
// Example 10
template <typename D> struct Stringify {
  operator std::string() const {
    std::stringstream S;
    S << *static_cast<const D*>(this);
    return S.str();
  }
};
\end{code}

It makes no sense to combine the two into a single base. In a large system, there can be many more of these classes, each adds a specific feature to the derived class and uses CRTP to implement it. But not every derived class needs every one of these features. With multiple base classes to choose from, it is easy to construct a derived class that has a specific set of features:

\begin{code}
// Example 10
class C1 : public Stringify<C1>, public Factory<C1> {鈥;
\end{code}

This works, but we are in danger of repeating nearly identical code if we need to implement several derived classes that have very similar behavior, except for the features provided by the CRTP bases. For example, if we have another factory that constructs objects in thread-local memory to speed up the performance of concurrent programs (let's call it \texttt{TLFactory}), we might have to write this:

\begin{code}
class C2 : public Stringify<C2>, public TLFactory<C2> {鈥;
\end{code}

But the two classes \texttt{C1} and \texttt{C2} are exactly the same except for the base classes, and yet, as written we would have to implement and maintain two copies of identical code. It would be better if we could write a single class template and plug different base classes into it as needed. This is the main idea of policy-based design; there are different approaches to it and you can learn about them in \emph{Chapter 15, Policy-Based Design}. For now, let us focus on using CRTP base classes in a template. Since we now need a class template that accepts multiple base class types, we will need to use a variadic template. We need something like this:

\begin{code}
template <typename鈥?Policies>
class C : public Policies鈥?{};
\end{code}

There are versions of the policy-based design that use this exact template; but in our case, it won't compile if we try to use \texttt{Factory} or \texttt{Stringify} as policies. The reason is that they are not types (classes) and, therefore, cannot be used as a type name. They are templates, so we have to declare the template parameters of the template \texttt{C} as templates themselves (this is known as a template template parameter). The syntax is easier to understand if we first recall how to declare a single template template parameter:

\begin{code}
template <template <typename> class B> class C;
\end{code}

If we wanted to inherit from a specific instantiation of this class template \texttt{B}, we would write

\begin{code}
template <template <typename> class B>
class C : public B<template argument> {鈥;
\end{code}

When using CRTP, the template argument is the type of the derived class itself, \texttt{C\textless{}B\textgreater{}}:

\begin{code}
template <template <typename> class B>
class C : public B<C<B>> {鈥;
\end{code}

Generalizing this to a parameter pack is straightforward:

\begin{code}
// Example 11
template <template <typename> class... Policies>
class C : public Policies<C<Policies...>>... {鈥;
\end{code}

The template parameter is a pack (any number of templates instead of a single class). The derived class inherits from the entire pack \texttt{Policies鈥, except \texttt{Policies} are templates and we need to specify the actual instantiations of these templates. Each template in the pack is instantiated on the derived class, whose type is \texttt{C\textless{}Policies鈥textgreater{}}.

If we need additional template parameters, for example, to enable using different value types in the class \texttt{C}, we can combine them with policies:

\begin{code}
// Example 11
template <typename T,
          template <typename> class... Policies>
class C : public Policies<C<T, Policies...>>... {
  T t_;
  public:
  explicit C(T t) : t_(t) {}
  const T& get() const { return t_; }
  friend std::ostream&
  operator<<(std::ostream& out, const C c) {
    out << c.t_;
    return out;
  }
};
\end{code}

To use this class with a particular set of policies, it is convenient to define some aliases:

\begin{code}
using X = C<int, Factory, Stringify>;
\end{code}

If we want to use several classes with the same Policies, we can define a template alias as well:

\begin{code}
template <typename T> using Y = C<T, Factory, Stringify>;
\end{code}

We will learn more about policies in the \emph{Chapter 15, Policy-Based Design}. We will encounter the technique we just studied, CRPT, there and in other chapters of this book -- it is a flexible and powerful tool.

\section{Summary}

We have examined a rather convoluted design pattern that combines both sides of C++---generic programming (templates) and object-oriented programming (inheritance). True to its name, the Curiously Recurring Template Pattern creates a circular loop, where the derived class inherits the interface and the implementation from the base class, while the base class has access to the interface of the derived class through the template parameters. CRTP has two main use modes---true static polymorphism, or \emph{static interface}, where the object is primarily accessed as the base type, and expanding the interface, or delegation, where the derived class is accessed directly but the implementation uses CRTP to provide common functionality. The latter can vary from a simple addition of one or two methods to a complex task of composing the interfaces of derived classes from multiple building blocks or policies.

The next chapter introduces an idiom that makes use of the pattern we have just learned. This idiom also changes the standard way we pass arguments to functions, in order of the parameters, and lets us have order-independent named arguments instead. Read on to find out how!

\section{Questions}

\begin{enumerate}
\item
  How expensive is a virtual function call, and why?
\item
  Why does a similar function call, resolved at compile time, have no such performance overhead?
\item
  How would you make compile-time polymorphic function calls?
\item
  How would you use CRTP to expand the interface of the base class?
\item
  What is necessary to use multiple CRTP base classes in a single derived class?.
\end{enumerate}


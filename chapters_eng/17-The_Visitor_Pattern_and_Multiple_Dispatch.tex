\chapter{访问者模式和多重分派}

访问者模式是另一个经典的面向对象设计模式，是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides在《设计模式——可复用面向对象软件的要素》一书中介绍的23种模式之一。在面向对象编程的黄金时代，它是更受欢迎的模式之一，因为它可以用来使大型类层次结构更易于维护。近年来，访问者模式在C++中的使用有所下降，因为大型复杂层次结构变得不那么常见，而访问者模式是一个相当复杂的模式来实现。泛型编程——特别是C++11和C++14中添加的语言特性——使得实现和维护访问者类更容易，而旧模式的新应用重新点燃了人们对它逐渐消退的兴趣。

本章将涵盖以下主题：

\begin{itemize}
\item
  访问者模式
\item
  C++中访问者的实现
\item
  使用泛型编程简化访问者类
\item
  访问者用于复合对象
\item
  编译时访问者和反射
\end{itemize}

技术要求

本章的示例代码可以在以下GitHub链接中找到：\url{https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17}。

\section{访问者模式}

访问者模式因其复杂性而在其他经典面向对象模式中脱颖而出。一方面，访问者模式的基本结构相当复杂，涉及许多必须协同工作以形成模式的协调类。另一方面，即使是访问者模式的描述也很复杂——有几种非常不同的方式来描述同一个模式。许多模式可以应用于多种问题，但访问者模式超越了这一点——有几种方式来描述它的作用，这些方式使用完全不同的语言，谈论看似无关的问题，总体上没有任何共同点。然而，它们都描述了同一个模式。让我们首先审视访问者模式的多个面孔，然后转向实现。

\subsection{什么是访问者模式？}

访问者模式是一个将算法从对象结构中分离出来的模式，对象结构是该算法的数据。使用访问者模式，我们可以在不修改类本身的情况下向类层次结构添加新操作。访问者模式的使用遵循软件设计的\textbf{开放/封闭原则}——一个类（或另一个代码单元，如模块）应该对修改封闭；一旦类向其客户端呈现接口，客户端就会依赖于这个接口及其提供的功能。这个接口应该保持稳定；为了维护软件并继续其开发，不应该需要修改类。同时，一个类应该对扩展开放——可以添加新功能来满足新需求。与所有非常通用的原则一样，可以找到反例，其中严格应用规则比违反它更糟糕。同样，与所有通用原则一样，其价值不在于成为每种情况的绝对规则，而是一个\emph{默认}规则，一个在没有充分理由不遵循的情况下应该遵循的指导原则；现实是大多数日常工作都\emph{不特殊}，如果遵循这个原则，结果会更好。

从这个角度来看，访问者模式允许我们在不必修改类的情况下向类或整个类层次结构添加功能。这个特性在处理公共API时特别有用——API的用户可以用额外的操作扩展它，而不必修改源代码。

描述访问者模式的一种非常不同的、更技术性的方式是说它实现了\textbf{双重分派}。这需要一些解释。让我们从常规的虚函数调用开始：

\begin{code}
class Base {
  virtual void f() = 0;
};
class Derived1 : public Base {
  void f() override;
};
class Derived2 : public Base {
  void f() override;
};
\end{code}

如果我们通过指向\texttt{b}基类的指针调用\texttt{b-\textgreater{}f()}虚函数，调用会分派到\texttt{Derived1::f()}或\texttt{Derived2::f()}，取决于对象的真实类型。这是\textbf{单一分派}——实际调用的函数由单一因素决定，即对象的类型。

现在让我们假设函数\texttt{f()}也接受一个参数，该参数是指向基类的指针：

\begin{code}
class Base {
  virtual void f(Base* p) = 0;
};
class Derived1 : public Base {
  void f(Base* p) override;
};
class Derived2 : public Base {
  void f(Base* p) override;
};
\end{code}

\texttt{*p}对象的实际类型也是派生类之一。现在，\texttt{b-\textgreater{}f(p)}调用可以有四个不同的版本；\texttt{*b}和\texttt{*p}对象都可以是两种派生类型中的任一种。在每种情况下希望实现做不同的事情是合理的。这将是双重分派——最终运行的代码由两个独立的因素决定。虚函数不提供直接实现双重分派的方法，但访问者模式正是做到了这一点。

当以这种方式呈现时，\textbf{双重分派}访问者模式与\textbf{操作添加}访问者模式有任何关系并不明显。然而，它们正是同一个模式，这两个需求实际上是同一个。这里有一种可能有帮助的看法——如果我们想向层次结构中的所有类添加操作，这等同于添加虚函数，所以我们有一个因素控制每个调用的最终处置，即对象类型。但是，如果我们能有效地添加虚函数，我们可以添加不止一个——为我们需要支持的每个操作添加一个。操作类型是控制分派的第二个因素，类似于我们之前例子中函数的参数。因此，操作添加访问者能够提供双重分派。或者，如果我们有实现双重分派的方法，我们可以做访问者模式所做的事情——为我们想要支持的每个操作有效地添加虚函数。

现在我们知道了访问者模式做什么，合理的问题是，\emph{为什么}我们想要这样做？双重分派的\emph{用途}是什么？当我们可以只添加一个\emph{真正的}虚函数时，为什么我们需要\emph{另一种方式}来向类添加虚函数替代品？撇开源代码不可用的公共API的情况，为什么我们想要\emph{外部}添加操作而不是在每个类中实现它？考虑序列化/反序列化问题的例子。序列化是一个将对象转换为可以存储或传输的格式（例如，写入文件）的操作。反序列化是逆操作——它从其序列化和存储的映像构造新对象。为了以直接的面向对象方式支持序列化和反序列化，层次结构中的每个类都需要两个方法，每个操作一个。但是如果有不止一种存储对象的方式怎么办？例如，我们可能需要将对象写入内存缓冲区，以便通过网络传输并在另一台机器上反序列化。或者，我们可能需要将对象保存到磁盘，或者我们可能需要将容器中的所有对象转换为标记格式，如JSON。直接的方法是为每种序列化机制向每个对象添加序列化和反序列化方法。如果需要新的不同的序列化方法，我们必须遍历整个类层次结构并为其添加支持。

另一种选择是在可以处理所有类的单独函数中实现整个序列化/反序列化操作。生成的代码是一个遍历所有对象的循环，其中有一个大的决策树。代码必须询问每个对象并确定其类型，例如，使用动态转换。当新类添加到层次结构时，所有序列化和反序列化实现都必须更新以处理新对象。

这两种实现对于大型层次结构都难以维护。访问者模式提供了一个解决方案——它允许我们在类外部实现新操作——在我们的情况下是序列化——而不修改它们，但也没有循环中巨大决策树的缺点（注意访问者模式不是序列化问题的唯一解决方案；C++还提供其他可能的方法，但我们在本章中专注于访问者模式）。

正如我们在开始时所说，访问者模式是一个复杂的模式，有复杂的描述。我们可以通过研究具体的例子来最好地处理这个困难的模式，从下一节中非常简单的例子开始。

\subsection{C++中的基本访问者}

真正理解访问者模式如何操作的唯一方法是通过一个例子来工作。让我们从一个非常简单的开始。首先，我们需要一个类层次结构：

\begin{code}
// Example 01
class Pet {
  public:
  virtual ~Pet() {}
  Pet(std::string_view color) : color_(color) {}
  const std::string& color() const { return color_; }
  private:
  const std::string color_;
};
class Cat : public Pet {
  public:
  Cat(std::string_view color) : Pet(color) {}
};
class Dog : public Pet {
  public:
  Dog(std::string_view color) : Pet(color) {}
};
\end{code}

在这个层次结构中，我们有\texttt{Pet}基类和几个用于不同宠物动物的派生类。现在我们想要向我们的类添加一些操作，比如"喂宠物"或"和宠物玩"。实现取决于宠物的类型，所以如果直接添加到每个类中，这些必须是虚函数。对于如此简单的类层次结构，这不是问题，但我们正在预见未来需要维护更大系统的需求，在这种系统中修改层次结构中的每个类将是昂贵和耗时的。我们需要一个更好的方法，我们首先创建一个新类\texttt{PetVisitor}，它将应用于每个\texttt{Pet}对象（访问它）并执行我们需要的操作。首先，我们需要声明这个类：

\begin{code}
// Example 01
class Cat;
class Dog;
class PetVisitor {
  public:
  virtual void visit(Cat* c) = 0;
  virtual void visit(Dog* d) = 0;
};
\end{code}

我们必须前向声明\texttt{Pet}层次结构类，因为\texttt{PetVisitor}必须在具体的\texttt{Pet}类之前声明。现在我们需要使\texttt{Pet}层次结构可访问，这意味着我们确实需要修改它，但只需要一次，无论我们稍后想要添加多少操作。我们需要向每个可以被访问的类添加一个虚函数来接受访问者模式：

\begin{code}
// Example 01
class Pet {
  public:
  virtual void accept(PetVisitor& v) = 0;
  ...
};
class Cat : public Pet {
  public:
  void accept(PetVisitor& v) override { v.visit(this); }
  ...
};
class Dog : public Pet {
  public:
  void accept(PetVisitor& v) override { v.visit(this); }
  ...
};
\end{code}

现在我们的\texttt{Pet}层次结构是可访问的，我们有一个抽象的\texttt{PetVisitor}类。一切都准备好为我们的类实现新操作了（注意到目前为止我们所做的任何事情都不依赖于我们要添加什么操作；我们已经创建了必须实现一次的访问基础设施）。通过实现从\texttt{PetVisitor}派生的具体访问者类来添加操作：

\begin{code}
// Example 01
class FeedingVisitor : public PetVisitor {
  public:
  void visit(Cat* c) override {
    std::cout << "Feed tuna to the " << c->color()
              << " cat" << std::endl;
  }
  void visit(Dog* d) override {
    std::cout << "Feed steak to the " << d->color()
              << " dog" << std::endl;
  }
};
class PlayingVisitor : public PetVisitor {
  public:
  void visit(Cat* c) override {
    std::cout << "Play with a feather with the "
              << c->color() << " cat" << std::endl;
  }
  void visit(Dog* d) override {
    std::cout << "Play fetch with the " << d->color()
              << " dog" << std::endl;
  }
};
\end{code}

假设访问基础设施已经内置到我们的类层次结构中，我们可以通过实现派生访问者类及其所有\texttt{visit()}的虚函数重写来实现新操作。要在我们类层次结构中的对象上调用新操作之一，我们需要创建一个访问者并访问对象：

\begin{code}
// Example 01
Cat c("orange");
FeedingVisitor fv;
c.accept(fv); // Feed tuna to the orange cat
\end{code}

最新的调用例子在一个重要方面过于简单——在调用访问者的点上，我们知道我们正在访问的对象的确切类型。为了使例子更现实，我们必须多态地访问对象：

\begin{code}
// Example 02
std::unique_ptr<Pet> p(new Cat("orange"));
...
FeedingVisitor fv;
p->accept(fv);
\end{code}

这里我们在编译时不知道\texttt{p}指向的对象的实际类型；在接受访问者的点上，\texttt{p}可能来自不同的来源。虽然不太常见，访问者也可以多态地使用：

\begin{code}
// Example 03
std::unique_ptr<Pet> p(new Cat("orange"));
std::unique_ptr<PetVisitor> v(new FeedingVisitor);
...
p->accept(*v);
\end{code}

以这种方式编写时，代码突出了访问者模式的双重分派方面——对\texttt{accept()}的调用最终分派到特定的\texttt{visit()}函数，基于两个因素——可访问的\texttt{*p}对象的类型和\texttt{*v}访问者的类型。如果我们希望强调访问者模式的这个方面，我们可以使用辅助函数调用访问者：

\begin{code}
// Example 03
void dispatch(Pet& p, PetVisitor& v) { p.accept(v); }
std::unique_ptr<Pet> p = ...;
std::unique_ptr<PetVisitor> v = ...;
dispatch(*p, *v); // Double dispatch
\end{code}

我们现在有了C++中经典面向对象访问者的最基本例子。尽管它很简单，但它具有所有必要的组件；大型现实类层次结构和多个访问者操作的实现有更多代码，但没有新类型的代码，只是我们已经做过的事情的更多。这个例子显示了访问者模式的两个方面；一方面，如果我们专注于软件的功能，有了现在的访问基础设施，我们可以添加新操作而不对类本身进行任何更改。另一方面，如果我们只看操作调用的方式，即\texttt{accept()}调用，我们已经实现了双重分派。

我们可以立即看到访问者模式的吸引力，我们可以添加任意数量的新操作而不必修改层次结构中的每个类。如果新类被添加到\texttt{Pet}层次结构中，不可能忘记处理它——如果我们对访问者什么都不做，新类上的\texttt{accept()}调用将不会编译，因为没有相应的\texttt{visit()}函数可调用。一旦我们向\texttt{PetVisitor}基类添加新的\texttt{visit()}重载，我们也必须将其添加到所有派生类中；否则，编译器会让我们知道我们有一个没有重写的纯虚函数。后者也是访问者模式的主要缺点之一——如果新类被添加到层次结构中，所有访问者都必须更新，无论新类是否实际需要支持这些操作。因此，有时建议只在不经常添加新类的\emph{相对稳定}的层次结构上使用访问者。还有一种替代访问者实现在某种程度上缓解了这个问题；我们将在本章后面看到它。

本节中的例子非常简单——我们的新操作不接受参数也不返回结果。我们现在将考虑这些限制是否重要，以及如何消除它们。

\subsection{访问者的通用化和限制}

在前一节中，我们的第一个访问者允许我们有效地向层次结构中的每个类添加虚函数。该虚函数没有参数也没有返回值。前者很容易扩展；我们的\texttt{visit()}函数没有理由不能有参数。让我们通过允许我们的宠物有小猫和小狗来扩展我们的类层次结构。这种扩展不能仅使用访问者模式完成——我们不仅需要添加新操作，还需要添加新的数据成员。访问者模式可以用于前者，但后者需要代码更改。如果我们有远见提供适当的策略，基于策略的设计可以让我们将这种更改分解为现有策略的新实现。我们在本书中有关于\emph{第15章，基于策略的设计}的单独章节，所以这里我们将避免混合几个模式，只添加新的数据成员：

\begin{code}
// Example 04
class Pet {
  public:
  ..
  void add_child(Pet* p) { children_.push_back(p); }
  virtual void accept(PetVisitor& v, Pet* p = nullptr) = 0;
  private:
  std::vector<Pet*> children_;
};
\end{code}

每个父\texttt{Pet}对象跟踪其子对象（注意容器是指针向量，不是unique指针向量，所以对象不拥有其子对象，而只是可以访问它们）。我们还添加了新的\texttt{add\_child()}成员函数来向向量添加对象。我们可以用访问者来做这件事，但这个函数是非虚的，所以我们只需要将其添加到基类一次，而不是每个派生类——这里访问者是不必要的。\texttt{accept()}函数已被修改为具有额外参数，这也必须添加到所有派生类中，在那里它简单地转发给\texttt{visit()}函数：

\begin{code}
// Example 04
class Cat : public Pet {
  public:
  Cat(std::string_view color) : Pet(color) {}
  void accept(PetVisitor& v, Pet* p = nullptr) override {
    v.visit(this, p);
  }
};
class Dog : public Pet {
  public:
  Dog(std::string_view color) : Pet(color) {}
  void accept(PetVisitor& v, Pet* p = nullptr) override {
    v.visit(this, p);
  }
};
\end{code}

\texttt{visit()}函数也必须修改以接受额外的参数，即使对于不需要它的访问者也是如此。因此，更改\texttt{accept()}函数的参数是一个昂贵的全局操作，应该很少进行，如果有的话。注意层次结构中同一虚函数的所有重写已经必须具有相同的参数。访问者模式将这种限制扩展到使用相同基访问者对象添加的所有操作。这个问题的常见解决方法是使用聚合（将多个参数组合在一起的类或结构）传递参数。\texttt{visit()}函数被声明为接受指向基聚合类的指针，而每个访问者接收指向可能具有额外字段的派生类的指针，并根据需要使用它们。

现在，我们的额外参数通过虚函数调用链转发到访问者，在那里我们可以使用它。让我们创建一个记录宠物出生并将新宠物对象作为子对象添加到其父对象的访问者：

\begin{code}
// Example 04
class BirthVisitor : public PetVisitor {
  public:
  void visit(Cat* c, Pet* p) override {
    assert(dynamic_cast<Cat*>(p));
    c->add_child(p);
  }
  void visit(Dog* d, Pet* p) override {
    assert(dynamic_cast<Dog*>(p));
    d->add_child(p);
  }
};
\end{code}

注意，如果我们想确保在我们的家谱中没有生物学上的不可能性，验证必须在运行时完成——在编译时，我们不知道多态对象的实际类型。新访问者与上一节中的访问者一样容易使用：

\begin{code}
Pet* parent; // A cat
BirthVisitor bv;
Pet* child(new Cat("calico"));
parent->accept(bv, child);
\end{code}

一旦我们建立了亲子关系，我们可能想要检查我们的宠物家庭。这是我们想要添加的另一个操作，需要另一个访问者：

\begin{code}
// Example 04
class FamilyTreeVisitor : public PetVisitor {
  public:
  void visit(Cat* c, Pet*) override {
    std::cout << "Kittens: ";
    for (auto k : c->children_) {
      std::cout << k->color() << " ";
    }
    std::cout << std::endl;
  }
  void visit(Dog* d, Pet*) override {
    std::cout << "Puppies: ";
    for (auto p : d->children_) {
      std::cout << p->color() << " ";
    }
    std::cout << std::endl;
  }
};
\end{code}

不过，我们遇到了一个小问题，因为按所写的代码将不会编译。原因是\texttt{FamilyTreeVisitor}类试图访问\texttt{Pet::children\_}数据成员，这是私有的。这是访问者模式的另一个弱点——从我们的角度来看，访问者向类添加新操作，就像虚函数一样，但从编译器的角度来看，它们是完全独立的类，完全不像\texttt{Pet}类的成员函数，没有特殊访问权限。访问者模式的应用通常需要以两种方式之一放松封装——我们可以允许对数据的公共访问（直接或通过访问器成员函数）或声明访问者类为友元（这确实需要对源代码进行更改）。在我们的例子中，我们将遵循第二条路线：

\begin{code}
class Pet {
  ...
  friend class FamilyTreeVisitor;
};
\end{code}

现在家谱访问者按预期工作：

\begin{code}
Pet* parent; // A cat
...
FamilyTreeVisitor tv;
parent->accept(tv); // Prints kitten colors
\end{code}

与\texttt{BirthVisitor}不同，\texttt{FamilyTreeVisitor}不需要额外的参数。

现在我们有了实现带参数操作的访问者。返回值呢？技术上，\texttt{visit()}和\texttt{accept()}函数没有要求返回\texttt{void}。它们可以返回任何其他东西。然而，它们必须全部返回相同类型的限制通常使这种能力无用。虚函数可以有协变返回类型，其中基类虚函数返回某个类的对象，派生类重写返回从该类派生的对象，但即使这样通常也太限制了。有另一个更简单的解决方案——每个访问者对象的\texttt{visit()}函数完全访问该对象的数据成员。我们没有理由不能将返回值存储在访问者类本身中并稍后访问它。这很好地适合最常见的用法，其中每个访问者添加不同的操作并且可能具有唯一的返回类型，但操作本身通常对层次结构中的所有类具有相同的返回类型。例如，我们可以使我们的\texttt{FamilyTreeVisitor}计算子对象的总数并通过访问者对象返回值：

\begin{code}
// Example 05
class FamilyTreeVisitor : public PetVisitor {
  public:
  FamilyTreeVisitor() : child_count_(0) {}
  void reset() { child_count_ = 0; }
  size_t child_count() const { return child_count_; }
  void visit(Cat* c, Pet*) override {
    visit_impl(c, "Kittens: ");
  }
  void visit(Dog* d, Pet*) override {
    visit_impl(d, "Puppies: ");
  }
  private:
  template <typename T>
  void visit_impl(T* t, const char* s) {
    std::cout << s;
    for (auto p : t->children_) {
      std::cout << p->color() << " ";
        ++child_count_;
      }
      std::cout << std::endl;
  }
  size_t child_count_;
};
FamilyTreeVisitor tv;
parent->accept(tv);
std::cout << tv.child_count() << " kittens total"
          << std::endl;
\end{code}

This approach imposes some limitations in multithreaded programs - the visitor is now not thread-safe since multiple threads cannot use the same Visitor object to visit different pet objects. The most common solution is to use one Visitor object per thread, usually a local variable created on the stack of the function that calls the visitor. If this is not possible, more complex options are available to give the visitor a per-thread (thread-local) state, but the analysis of such options lies outside of the scope of this book. On the other hand, sometimes we want to accumulate results over multiple visitations, in which case the previous technique of storing the result in the Visitor object works perfectly. Also note that the same solution can be used to pass arguments into the Visitor operations, instead of adding them to the \texttt{visit()} functions; we can store the arguments inside the Visitor object itself, and then we don't need anything special to access them from the visitor. This technique works particularly well when the arguments don't change on every invocation of the visitor, but may vary from one Visitor object to another.

Let's return for a moment and examine the \texttt{FamilyTreeVisitor} implementation again. Note that it iterates over the child objects of the parent object and calls the same operation on each one, in turn. It does not, however, process the children of the child object - our family tree is only one-generation deep. The problem of visiting objects that contain other objects is very general and occurs rather often. Our motivational example from the very beginning of this chapter, the problem of serialization, demonstrates this need perfectly - every complex object is serialized by serializing its components, one by one, and they, in turn, are serialized the same way, until we get all the way down to the built-in types such as \texttt{int} and \texttt{double}, which we know how to read and write. The next section deals with visiting complex objects in a more comprehensive way than what we have done so far.

\section{访问复杂对象}

在上一节中，我们看到了访问者模式如何允许我们向现有层次结构添加新操作。在其中一个例子中，我们访问了包含指向其他对象的指针的复杂对象。访问者以有限的方式遍历这些指针。我们现在将考虑访问由其他对象组成的对象或包含其他对象的对象的一般问题，并构建到最后一个有效的序列化/反序列化解决方案的演示。

\subsection{访问复合对象}

访问复杂对象的一般思想非常直接——当访问对象本身时，我们通常不知道如何处理每个组件或包含对象的所有细节。但是有其他东西知道——该对象类型的访问者专门为处理该类而不是其他任何东西而编写。这个观察表明处理组件对象的正确方法是简单地访问每一个，从而将问题委托给其他人（在编程和其他方面都是一般强大的技术）。

让我们首先在简单容器类的例子上演示这个想法，例如\texttt{Shelter}类，它可以包含任意数量的表示等待收养的宠物的宠物对象：

\begin{code}
// Example 06
class Shelter {
  public:
  void add(Pet* p) {
    pets_.emplace_back(p);
  }
  void accept(PetVisitor& v) {
    for (auto& p : pets_) {
      p->accept(v);
    }
  }
  private:
  std::vector<std::unique_ptr<Pet>> pets_;
};
\end{code}

这个类本质上是一个适配器，使宠物对象的向量可访问（我们已经在同名章节中详细讨论了适配器模式）。注意这个类的对象确实拥有它们包含的宠物对象——当\texttt{Shelter}对象被销毁时，向量中的所有\texttt{Pet}对象也被销毁。任何unique指针的容器都是拥有其包含对象的容器；这是多态对象应该存储在像\texttt{std::vector}这样的容器中的方式（对于非多态对象，我们可以存储对象本身，但在我们的情况下不起作用，从\texttt{Pet}派生的对象是不同类型的）。

与我们当前问题相关的代码当然是\texttt{Shelter::accept()}，它确定如何访问\texttt{Shelter}对象。如你所见，我们不在\texttt{Shelter}对象本身上调用访问者。相反，我们将访问委托给每个包含的对象。由于我们的访问者已经编写来处理Pet对象，不需要做更多事情。当\texttt{Shelter}被比如\texttt{FeedingVisitor}访问时，收容所中的每只宠物都得到喂食，我们不必编写任何特殊代码来实现它。

复合对象的访问以类似的方式完成——如果对象由几个较小的对象组成，我们必须访问这些对象中的每一个。让我们考虑一个表示有两只家庭宠物（一只狗和一只猫）的家庭的对象（服务宠物的人类没有包括在以下代码中，但我们假设他们也在那里）：

\begin{code}
// Example 07
class Family {
  public:
  Family(const char* cat_color, const char* dog_color) :
  cat_(cat_color), dog_(dog_color) {}
  void accept(PetVisitor& v) {
    cat_.accept(v);
    dog_.accept(v);
  }
  private: // Other family members not shown for brevity
  Cat cat_;
  Dog dog_;
};
\end{code}

同样，用来自\texttt{PetVisitor}层次结构的访问者访问家庭被委托，以便每个\texttt{Pet}对象被访问，访问者已经拥有处理这些对象所需的一切（当然，\texttt{Family}对象也可以接受其他类型的访问者，我们必须为它们编写单独的\texttt{accept()}方法）。

现在，最后，我们拥有了解决任意对象序列化和反序列化问题所需的所有部分。下一个小节展示了如何使用访问者模式来完成这项工作。

\subsection{使用访问者进行序列化和反序列化}

问题本身在前一节中已经详细描述——对于序列化，每个对象需要转换为位序列，这些位需要被存储、复制或发送。动作的第一部分取决于对象（每个对象的转换方式不同），但第二部分取决于序列化的具体应用（保存到磁盘与通过网络发送不同）。实现取决于两个因素，因此需要双重分派，这正是访问者模式提供的。此外，如果我们有一种序列化某个对象然后反序列化它（从位序列重构对象）的方法，当这个对象包含在另一个对象中时，我们应该使用相同的方法。

为了演示使用访问者模式对类层次结构进行序列化/反序列化，我们需要一个比迄今为止使用的玩具例子更复杂的层次结构。让我们考虑这个二维几何对象的层次结构：

\begin{code}
// Example 08
class Geometry {
  public:
  virtual ~Geometry() {}
};
class Point : public Geometry {
  public:
  Point() = default;
  Point(double x, double y) : x_(x), y_(y) {}
  private:
  double x_ {};
  double y_ {};
};
class Circle : public Geometry {
  public:
  Circle() = default;
  Circle(Point c, double r) : c_(c), r_(r) {}
  private:
  Point c_;
  double r_ {};
};
class Line : public Geometry {
  public:
  Line() = default;
  Line(Point p1, Point p2) : p1_(p1), p2_(p2) {}
  private:
  Point p1_;
  Point p2_;
};
\end{code}

所有对象都从抽象的\texttt{Geometry}基类派生，但更复杂的对象包含一个或多个更简单的对象；例如，\texttt{Line}由两个\texttt{Point}对象定义。注意，归根结底，我们所有的对象都是由\texttt{double}数字组成的，因此将序列化为数字序列。关键是知道哪个\texttt{double}代表哪个对象的哪个字段；我们需要这个来正确恢复原始对象。

要使用访问者模式序列化这些对象，我们遵循在上一节中使用的相同过程。首先，我们需要声明基访问者类：

\begin{code}
// Example 08
class Visitor {
public:
  virtual void visit(double& x) = 0;
  virtual void visit(Point& p) = 0;
  virtual void visit(Circle& c) = 0;
  virtual void visit(Line& l) = 0;
};
\end{code}

这里有一个额外的细节——我们也可以访问double值；每个访问者需要适当地处理它们（写入它们、读取它们等等）。访问任何几何对象最终将导致访问组成它的数字。

我们的基\texttt{Geometry}类和从它派生的所有类都需要接受这个访问者：

\begin{code}
// Example 08
class Geometry {
  public:
  virtual ~Geometry() {}
  virtual void accept(Visitor& v) = 0;
};
\end{code}

当然，没有办法向double添加\texttt{accept()}成员函数，但我们不必这样做。派生类的\texttt{accept()}成员函数，每个都由一个或多个数字和其他类组成，按顺序访问每个数据成员：

\begin{code}
// Example 08
void Point::accept(Visitor& v) {
  v.visit(x_); // double
  v.visit(y_); // double
}
void Circle::accept(Visitor& v) {
  v.visit(c_); // Point
  \begin{code}
// Example 08
void Point::accept(Visitor& v) {
  v.visit(x_); // double
  v.visit(y_); // double
}
void Circle::accept(Visitor& v) {
  v.visit(c_); // Point
  v.visit(r_); // double
}
void Line::accept(Visitor& v) {
  v.visit(p1_); // Point
  v.visit(p2_); // Point
}
\end{code}

具体的访问者类，全部从基\texttt{Visitor}类派生，负责序列化和反序列化的具体机制。对象被分解为其组成部分直到数字的顺序由每个对象控制，但访问者决定对这些数字做什么。例如，我们可以使用格式化I/O将所有对象序列化为字符串（类似于我们将数字打印到\texttt{cout}时得到的结果）：

\begin{code}
// Example 08
class StringSerializeVisitor : public Visitor {
public:
  void visit(double& x) override { S << x << " "; }
  void visit(Point& p) override { p.accept(*this); }
  void visit(Circle& c) override { c.accept(*this); }
  void visit(Line& l) override { l.accept(*this); }
  std::string str() const { return S.str(); }
  private:
  std::stringstream S;
};
\end{code}

字符串在\texttt{stringstream}中累积，直到所有必要的对象被序列化：

\begin{code}
// Example 08
Line l(...);
Circle c(...);
StringSerializeVisitor serializer;
serializer.visit(l);
serializer.visit(c);
std::string s(serializer.str());
\end{code}

现在我们将对象打印到\texttt{s}字符串中，我们可以从这个字符串恢复它们，也许在不同的机器上（如果我们安排将字符串发送到那里）。首先，我们需要反序列化访问者：

\begin{code}
// Example 08
class StringDeserializeVisitor : public Visitor {
  public:
  StringDeserializeVisitor(const std::string& s) {
    S.str(s);
  }
  void visit(double& x) override { S >> x; }
  void visit(Point& p) override { p.accept(*this); }
  void visit(Circle& c) override { c.accept(*this); }
  void visit(Line& l) override { l.accept(*this); }
  private:
  std::stringstream S;
};
\end{code}

这个访问者从字符串中读取数字并将它们保存在被访问对象给它的变量中。成功反序列化的关键是按照保存时的相同顺序读取数字——例如，如果我们开始时写入点的\emph{X}和\emph{Y}坐标，我们应该从我们读取的前两个数字构造一个点，并将它们用作\emph{X}和\emph{Y}坐标。如果我们写入的第一个点是线的端点，我们应该使用我们构造的点作为新线的端点。访问者模式的美妙之处在于执行实际读写的函数不需要做任何特殊的事情来保持这个顺序——顺序由每个对象确定，并保证对所有访问者都是相同的（对象不区分特定的访问者，甚至不知道它是什么类型的访问者）。我们需要做的就是按照它们被序列化的相同顺序访问对象：

\begin{code}
// Example 08
Line l1;
Circle c1;
// s is the string from a serializer
StringDeserializeVisitor deserializer(s);
deserializer.visit(l1); // Restored Line l
deserializer.visit(c1); // Restored Circle c
\end{code}

到目前为止，我们已经知道哪些对象被序列化以及以什么顺序。因此，我们可以按相同顺序反序列化相同的对象。更一般的情况是当我们在反序列化期间不知道期望什么对象时——对象存储在可访问的容器中，类似于前面例子中的\texttt{Shelter}，它必须确保对象以相同的顺序序列化和反序列化。例如，考虑这个类，它存储表示为两个其他几何图形交集的几何图形：

\begin{code}
// Example 09
class Intersection : public Geometry {
  public:
  Intersection() = default;
  Intersection(Geometry* g1, Geometry* g2) :
    g1_(g1), g2_(g2) {}
  void accept(Visitor& v) override {
    g1_->accept(v);
    g2_->accept(v);
  }
  private:
  std::unique_ptr<Geometry> g1_;
  std::unique_ptr<Geometry> g2_;
};
\end{code}

这个对象的序列化很直接——我们按顺序序列化两个几何图形，通过将细节委托给这些对象。我们不能直接调用\texttt{v.visit()}，因为我们不知道\texttt{*g1\_}和\texttt{*g2\_}几何图形的类型，但我们可以让这些对象适当地分派调用。但反序列化，如所写的，将失败——几何图形指针是\texttt{null}，还没有分配对象，我们不知道应该分配什么类型的对象。不知何故，我们需要首先在序列化流中编码对象的类型，然后基于这些编码类型构造它们。有另一个模式为这个问题提供标准解决方案，那就是工厂模式（在构建复杂系统时必须使用多个设计模式是很常见的）。

有几种方法可以做到这一点，但它们都归结为将类型转换为数字并序列化这些数字。在我们的情况下，当我们声明基\texttt{Visitor}类时，我们必须知道几何类型的完整列表，以便我们也可以同时为所有这些类型定义枚举：

\begin{code}
// Example 09
class Geometry {
  public:
  enum type_tag {POINT = 100, CIRCLE, LINE, INTERSECTION};
  virtual type_tag tag() const = 0;
};
class Visitor {
  public:
  static Geometry* make_geometry(Geometry::type_tag tag);
  virtual void visit(Geometry::type_tag& tag) = 0;
  ...
};
\end{code}

\texttt{enum\ type\_tag}在\texttt{Geometry}类内部定义，或者\texttt{make\_geometry}工厂构造函数是\texttt{Visitor}类的静态成员函数，这些并不是必要的。它们也可以在任何类之外声明，但将为每个派生几何类型返回正确标签的虚\texttt{tag()}方法需要完全按所示声明。\texttt{tag()}重写必须在每个派生\texttt{Geometry}类中定义，例如，\texttt{Point}类：

\begin{code}
// Example 09
class Point : public Geometry {
  public:
  ...
  type_tag tag() const override { return POINT; }
};
\end{code}

其他派生类必须类似地修改。

然后我们需要定义工厂构造函数：

\begin{code}
// Example 09
Geometry* Visitor::make_geometry(Geometry::type_tag tag) {
  switch (tag) {
    case Geometry::POINT: return new Point;
    case Geometry::CIRCLE: return new Circle;
    case Geometry::LINE: return new Line;
    case Geometry::INTERSECTION: return new Intersection;
  }
}
\end{code}

这个工厂函数根据指定的类型标签构造正确的派生对象。剩下的就是让\texttt{Intersection}对象序列化和反序列化构成交集的两个几何图形的标签：

\begin{code}
// Example 09
class Intersection : public Geometry {
  public:
  void accept(Visitor& v) override {
    Geometry::type_tag tag;
    if (g1_) tag = g1_->tag();
    v.visit(tag);
    if (!g1_) g1_.reset(Visitor::make_geometry(tag));
    g1_->accept(v);
    if (g2_) tag = g2_->tag();
    v.visit(tag);
    if (!g2_) g2_.reset(Visitor::make_geometry(tag));
    g2_->accept(v);
  }
  ...
};
\end{code}

首先，标签被发送到访问者。序列化访问者应该与其余数据一起写入标签：

\begin{code}
// Example 09
class StringSerializeVisitor : public Visitor {
  public:
  void visit(Geometry::type_tag& tag) override {
    S << size_t(tag) << " ";
  }
  ...
};
\end{code}

反序列化访问者必须读取标签（实际上，它读取一个\texttt{size\_t}数字并将其转换为标签）：

\begin{code}
// Example 09
class StringDeserializeVisitor : public Visitor {
  public:
  void visit(Geometry::type_tag& tag) override {
    size_t t;
    S >> t;
    tag = Geometry::type_tag(t);
  }
  ...
};
\end{code}

一旦标签被反序列化访问者恢复，\texttt{Intersection}对象可以调用工厂构造函数来构造正确的几何对象。现在我们可以从流中反序列化这个对象，我们的\texttt{Intersection}被恢复为我们序列化的对象的精确副本。注意有其他方法来打包访问标签和对工厂构造函数的调用；最佳解决方案取决于系统中不同对象的角色——例如，反序列化访问者可以基于标签构造对象，而不是拥有这些几何图形的复合对象。然而，需要发生的事件序列保持相同。

到目前为止，我们一直在学习经典的面向对象访问者模式。在我们看到经典模式的C++特定变化之前，我们应该了解另一种类型的访问者，它解决了访问者模式中的一些不便之处。

\section{无环访问者}

正如我们迄今为止所看到的，访问者模式做了我们想要它做的事情。它将算法的实现与作为算法数据的对象分离，它允许我们基于两个运行时因素选择正确的实现——特定对象类型和我们想要执行的具体操作，两者都从其相应的类层次结构中选择。然而，美中不足的是——我们想要减少复杂性并简化代码维护，我们做到了，但现在我们必须维护两个并行的类层次结构，可访问对象和访问者，两者之间的依赖关系是非平凡的。这些依赖关系的最坏部分是它们形成了一个循环——访问者对象依赖于可访问对象的类型（每个可访问类型都有\texttt{visit()}方法的重载），基本可访问类型依赖于基本访问者类型。这种依赖的前半部分是最糟糕的。每次向层次结构添加新对象时，每个访问者都必须更新。后半部分不需要程序员做太多工作，因为可以随时添加新访问者而无需任何其他更改——这是访问者模式的全部要点。但基本可访问类对基本访问者类仍然存在编译时依赖，因此，所有派生类也是如此。如果访问者类发生更改，使用可访问类之一的每个文件都需要重新编译。访问者在其接口和实现方面大多是稳定的，除了一种情况——添加新的可访问类。因此，实际的循环看起来像这样——向可访问对象的层次结构添加新类。访问者类需要用新类型更新。由于基本访问者类已更改，基本可访问类和依赖于它的每行代码都必须重新编译，包括不使用新可访问类的代码，只使用旧的。即使尽可能使用前向声明也无济于事——如果添加了新的可访问类，所有旧的都必须重新编译。

传统访问者模式的另一个问题是必须处理对象类型和访问者类型的每种可能组合。通常存在一些组合没有意义的情况，某些对象永远不会被某些类型的访问者访问。但我们不能利用这一点，因为每种组合都必须有定义的动作（动作可能非常简单，但每个访问者类仍然必须定义完整的\texttt{visit()}成员函数集）。

无环访问者模式是访问者模式的变体，专门设计用于打破依赖循环并允许部分访问。无环访问者模式的基本可访问类与常规访问者模式相同：

\begin{code}
// Example 10
class Pet {
  public:
  virtual ~Pet() {}
  virtual void accept(PetVisitor& v) = 0;
  ...
};
\end{code}

然而，这就是相似性结束的地方。基本访问者类没有每个可访问对象的\texttt{visit()}重载。事实上，它根本没有\texttt{visit()}成员函数：

\begin{code}
// Example 10
class PetVisitor {
  public:
  virtual ~PetVisitor() {}
};
\end{code}

那么，谁来做访问呢？对于原始层次结构中的每个派生类，我们还声明相应的访问者类，这就是\texttt{visit()}函数所在的地方：

\begin{code}
// Example 10
class Cat;
class CatVisitor {
  public:
  virtual void visit(Cat* c) = 0;
};
class Cat : public Pet {
  public:
  Cat(std::string_view color) : Pet(color) {}
  void accept(PetVisitor& v) override {
    if (CatVisitor* cv = dynamic_cast<CatVisitor*>(&v)) {
      cv->visit(this);
    } else { // Handle error
      assert(false);
    }
  }
};
\end{code}

注意每个访问者只能访问它设计访问的类——\texttt{CatVisitor}只访问\texttt{Cat}对象，\texttt{DogVisitor}只访问\texttt{Dog}对象，依此类推。魔法在于新的\texttt{accept()}函数——当一个类被要求接受访问者时，它首先使用\texttt{dynamic\_cast}检查这是否是正确类型的访问者。如果是，一切都好，访问者被接受。如果不是，我们就有问题了，必须处理错误（确切的错误处理机制取决于应用程序；例如，可以抛出异常）。因此，具体的访问者类必须从通用的\texttt{PetVisitor}基类和特定类的基类（如\texttt{CatVisitor}）派生：

\begin{code}
// Example 10
class FeedingVisitor : public PetVisitor,
                       public CatVisitor,
                       public DogVisitor {
  public:
  void visit(Cat* c) override {
    std::cout << "Feed tuna to the " << c->color()
              << " cat" << std::endl;
  }
  void visit(Dog* d) override {
    std::cout << "Feed steak to the " << d->color()
              << " dog" << std::endl;
  }
};
\end{code}

每个具体访问者类都从通用访问者基类和每个必须由该访问者处理的类型的每个按类型访问者基类（\texttt{CatVisitor}、\texttt{DogVisitor}等）派生。另一方面，如果这个访问者不是为了访问层次结构中的某些类而设计的，我们可以简单地省略相应的访问者基类，然后我们也不需要实现虚函数重写：

\begin{code}
// Example 10
class BathingVisitor : public PetVisitor,
                       public DogVisitor
                       { // But no CatVisitor
  public:
  void visit(Dog* d) override {
    std::cout << "Wash the " << d->color()
              << " dog" << std::endl;
  }
  // No visit(Cat*) here!
};
\end{code}

无环访问者模式的调用与常规访问者模式完全相同：

\begin{code}
// Example 10
std::unique_ptr<Pet> c(new Cat("orange"));
std::unique_ptr<Pet> d(new Dog("brown"));
FeedingVisitor fv;
c->accept(fv);
d->accept(fv);
BathingVisitor bv;
//c->accept(bv); // Error
d->accept(bv);
\end{code}

如果我们试图访问特定访问者不支持的对象，会检测到错误。因此，我们解决了部分访问的问题。那循环依赖呢？这也得到了解决——通用的\texttt{PetVisitor}基类不需要列出可访问对象的完整层次结构，具体的可访问类只依赖于其按类访问者，而不依赖于其他类型的任何访问者。因此，当向层次结构添加另一个可访问对象时，现有的对象不需要重新编译。

无环访问者模式看起来如此之好，人们不得不想，\emph{为什么不一直使用它而不是常规访问者模式？}有几个原因。首先，无环访问者模式使用\texttt{dynamic\_cast}从一个基类转换到另一个基类（有时称为交叉转换）。这个操作通常比虚函数调用更昂贵，所以无环访问者模式比替代方案更慢。另外，无环访问者模式需要为每个可访问类设置一个访问者类，所以类的数量是两倍，并且它使用多重继承与许多基类。第二个问题对于大多数现代编译器来说不是什么大问题，但许多程序员发现处理多重继承很困难。第一个问题——动态转换的运行时成本——是否是问题取决于应用程序，但这是你需要注意的。另一方面，当可访问对象层次结构经常变化或重新编译整个代码库的成本很大时，无环访问者模式真的很出色。

你可能已经注意到无环访问者模式的另一个问题——它有很多样板代码。每个可访问类都必须复制几行代码。事实上，常规访问者模式也受到同样的问题困扰，因为实现任何一种访问者都涉及大量重复的输入。但C++有一套特殊的工具来用代码重用代替代码重复：这正是泛型编程的用途。接下来我们将看到访问者模式如何适应现代C++。

\section{现代C++中的访问者}

正如我们刚才看到的，访问者模式促进了关注点的分离；例如，序列化的顺序和序列化的机制是独立的，单独的类负责每一个。该模式还通过将执行给定任务的所有代码收集在一个地方来简化代码维护。访问者模式不提倡的是没有重复的代码重用。但那是面向对象的访问者模式，在现代C++之前。让我们看看我们可以用C++的泛型能力做什么，从常规访问者模式开始。

\subsection{泛型访问者}

我们将尝试减少访问者模式实现中的样板代码。让我们从\texttt{accept()}成员函数开始，它必须复制到每个可访问类中；它总是看起来相同：

\begin{code}
class Cat : public Pet {
  void accept(PetVisitor& v) override { v.visit(this); }
};
\end{code}

这个函数不能移动到基类，因为我们需要用实际类型调用访问者，而不是基类型——\texttt{visit()}接受\texttt{Cat*}、\texttt{Dog*}等，但不接受\texttt{Pet*}。如果我们引入一个中间模板化基类，我们可以让模板为我们生成这个函数：

\begin{code}
// Example 11
class Pet { // Same as before
  public:
  virtual ~Pet() {}
  Pet(std::string_view color) : color_(color) {}
  const std::string& color() const { return color_; }
  virtual void accept(PetVisitor& v) = 0;
  private:
  std::string color_;
};
template <typename Derived>
class Visitable : public Pet {
  public:
  using Pet::Pet;
  void accept(PetVisitor& v) override {
    v.visit(static_cast<Derived*>(this));
  }
};
\end{code}

模板由派生类参数化。在这方面，它类似于\textbf{奇异递归模板模式}（\textbf{CRTP}），但这里我们不从模板参数继承——我们使用它将\texttt{this}指针转换为正确的派生类指针。现在我们只需要从模板的正确实例化派生每个宠物类，我们就自动获得了\texttt{accept()}函数：

\begin{code}
// Example 11
class Cat : public Visitable<Cat> {
  using Visitable<Cat>::Visitable;
};
class Dog : public Visitable<Dog> {
  using Visitable<Dog>::Visitable;
};
\end{code}

这解决了一半的样板代码——派生可访问对象内部的代码。现在只剩下另一半：访问者类内部的代码，我们必须为每个可访问类一遍又一遍地输入相同的声明。我们对特定访问者无能为力；毕竟，这是真正工作完成的地方，而且，大概我们需要为不同的可访问类做不同的事情（否则为什么要使用双重分派？）

但是，如果我们引入这个泛型访问者模板，我们可以简化基本访问者类的声明：

\begin{code}
// Example 12
template <typename ... Types> class Visitor;
template <typename T> class Visitor<T> {
  public:
  virtual void visit(T* t) = 0;
};
template <typename T, typename ... Types>
class Visitor<T, Types ...> : public Visitor<Types ...> {
  public:
  using Visitor<Types ...>::visit;
  virtual void visit(T* t) = 0;
};
\end{code}

注意我们只需要实现这个模板一次：不是为每个类层次结构实现一次，而是永远实现一次（或者至少直到我们需要更改\texttt{visit()}函数的签名，例如添加参数）。这是一个很好的泛型库类。一旦我们有了它，为特定类层次结构声明访问者基类就变得如此简单，感觉虎头蛇尾：

\begin{code}
// Example 12
\end{code}

注意带有\texttt{class}关键字的有些不寻常的语法——它将模板参数列表与前向声明结合起来，等价于以下内容：

\begin{code}
class Cat;
class Dog;
using PetVisitor = Visitor<Cat, Dog>;
\end{code}

泛型访问者基类是如何工作的？它使用可变参数模板来捕获任意数量的类型参数，但主模板只是声明的，未定义的。其余的是特化。首先，我们有一个类型参数的特殊情况。我们为该类型声明纯\texttt{visit()}虚成员函数。然后我们有一个超过一个类型参数的特化，其中第一个参数是显式的，其余的在参数包中。我们为显式指定的类型生成\texttt{visit()}函数，并从同一个可变参数模板的实例化继承其余的函数，但参数少一个。实例化是递归的，直到我们只剩下一个类型参数，然后使用第一个特化。

这个泛型和可重用的代码有一个限制：它不能处理深层次结构。回想一下，每个可访问类都派生自一个通用基类：

\begin{code}
template <typename Derived>
class Visitable : public Pet {...};
class Cat : public Visitable<Cat> {...};
\end{code}

如果我们要从\texttt{Cat}派生另一个类，它也必须从\texttt{Visitable}派生：

\begin{code}
class SiameseCat : public Cat,
                   public Visitable<SiameseCat> {...};
\end{code}

我们不能只是从\texttt{Cat}派生\texttt{SiameseCat}，因为是Visitable模板为每个派生类提供了\texttt{accept()}方法。但我们也不能使用我们刚才尝试的双重继承，因为现在，\texttt{SiameseCat}类从Pet继承了两次：一次通过\texttt{Cat}基类，一次通过\texttt{Visitable}基类。如果你仍然想使用模板来生成\texttt{accept()}方法，唯一的解决方案是分离层次结构，使每个可访问类（如\texttt{Cat}）从\texttt{Visitable}和相应的基类\texttt{CatBase}继承，后者具有除了访问支持之外的所有"猫特定"功能。这使层次结构中的类数量翻倍，是一个主要缺点。

现在我们有了由模板生成的样板访问者代码，我们也可以简化具体访问者的定义。

\subsection{Lambda访问者}

定义具体访问者的大部分工作是为每个可访问对象编写必须发生的实际工作的代码。在特定访问者类中没有很多样板代码。但有时我们可能不想声明类本身。想想lambda表达式——任何可以用lambda表达式完成的事情也可以用显式声明的可调用类来完成，因为lambda是（匿名）可调用类。尽管如此，我们发现lambda表达式对于编写一次性可调用对象非常有用。类似地，我们可能想要编写一个访问者而不显式命名它——一个lambda访问者。我们希望它看起来像这样：

\begin{code}
auto v(lambda_visitor<PetVisitor>(
  [](Cat* c) { std::cout << "Let the " << c->color()
                         << " cat out" << std::endl;
  },
  [](Dog* d) { std::cout << "Take the " << d->color()
                         << " dog for a walk" << std::endl;
  }
));
pet->accept(v);
\end{code}

有两个问题需要解决——如何创建一个处理类型列表和相应对象的类（在我们的情况下，可访问类型和相应的lambda），以及如何使用lambda表达式生成一组重载函数。

前一个问题将需要我们在参数包上递归实例化模板，每次剥离一个参数。后一个问题的解决方案类似于lambda表达式的重载集，这在类模板章节中已经描述过。我们可以使用那一章的重载集，但我们可以使用我们需要的递归模板实例化来直接构建重载函数集。

这个实现中将有一个新的挑战——我们必须处理不是一个而是两个类型列表。第一个列表包含所有可访问类型；在我们的情况下，\texttt{Cat}和\texttt{Dog}。第二个列表具有lambda表达式的类型，每个可访问类型一个。我们还没有看到带有两个参数包的可变参数模板，这是有充分理由的——不可能简单地声明\texttt{template\textless{}typename...\ A,\ typename...\ B\textgreater{}}，因为编译器不知道第一个列表在哪里结束，第二个列表在哪里开始。诀窍是将一个或两个类型列表隐藏在其他模板中。在我们的情况下，我们已经有了在可访问类型列表上实例化的\texttt{Visitor}模板：

\begin{code}
using PetVisitor = Visitor<class Cat, class Dog>;
\end{code}

我们可以从\texttt{Visitor}模板中提取这个列表，并将每个类型与其lambda表达式匹配。用于同步处理两个参数包的偏特化语法很棘手，所以我们将分步骤进行。首先，我们需要为我们的\texttt{LambdaVisitor}类声明一般模板：

\begin{code}
// Example 13
template <typename Base, typename...>
class LambdaVisitor;
\end{code}

注意这里只有一个通用参数包，加上访问者的基类（在我们的情况下，它将是\texttt{PetVisitor}）。这个模板必须声明，但它永远不会被使用——我们将为每个需要处理的情况提供特化。第一个特化用于只有一个可访问类型和一个相应lambda表达式的情况：

\begin{code}
// Example 13
template <typename Base, typename T1, typename F1>
class LambdaVisitor<Base, Visitor<T1>, F1> :
  private F1, public Base
{
  public:
  LambdaVisitor(F1&& f1) : F1(std::move(f1)) {}
  LambdaVisitor(const F1& f1) : F1(f1) {}
  using Base::visit;
  void visit(T1* t) override { return F1::operator()(t); }
};
\end{code}

这个特化除了处理我们只有一个可访问类型的情况外，还用作每个递归模板实例化链中的最后一个实例化。由于它总是\texttt{LambdaVisitor}实例化递归层次结构中的第一个基类，它是唯一直接从基访问者类（如\texttt{PetVisitor}）继承的。注意，即使只有一个\texttt{T1}可访问类型，我们也使用\texttt{Visitor}模板作为它的包装器。这是为了准备一般情况，我们将有一个长度未知的类型列表。两个构造函数将\texttt{f1} lambda表达式存储在\texttt{LambdaVisitor}类中，如果可能的话使用移动而不是复制。最后，\texttt{visit(T1*)}虚函数重写只是将调用转发给lambda表达式。乍一看，从\texttt{F1}公开继承并同意使用函数调用语法（换句话说，将所有对\texttt{visit()}的调用重命名为对\texttt{operator()}的调用）可能看起来更简单。这不会工作；我们需要间接性，因为lambda表达式本身的\texttt{operator()}实例不能是虚函数重写。顺便说一下，这里的\texttt{override}关键字在检测代码中的错误方面是无价的，其中模板不是从正确的基类继承的，或者虚函数声明不完全匹配。

任意数量的可访问类型和lambda表达式的一般情况由这个偏特化处理，它显式处理两个列表中的第一个类型，然后递归实例化自身来处理列表的其余部分：

\begin{code}
// Example 13
template <typename Base,
          typename T1, typename... T,
          typename F1, typename... F>
class LambdaVisitor<Base, Visitor<T1, T...>, F1, F...> :
  private F1,
  public LambdaVisitor<Base, Visitor<T ...>, F ...>
{
  public:
  LambdaVisitor(F1&& f1, F&& ... f) :
    F1(std::move(f1)),
    LambdaVisitor<Base, Visitor<T...>, F...>(
      std::forward<F>(f)...)
  {}
  LambdaVisitor(const F1& f1, F&& ... f) :
    F1(f1),
    LambdaVisitor<Base, Visitor<T...>, F...>(
      std::forward<F>(f) ...)
  {}
  using LambdaVisitor<Base, Visitor<T ...>, F ...>::visit;
  void visit(T1* t) override { return F1::operator()(t); }
};
\end{code}

再次，我们有两个构造函数，它们在类中存储第一个lambda表达式，并将其余的转发给下一个实例化。在递归的每一步都生成一个虚函数重写，总是针对可访问类剩余列表中的第一个类型。然后从列表中删除该类型，处理以相同的方式继续，直到我们到达最后一个实例化，即单个可访问类型的实例化。

由于不可能显式命名lambda表达式的类型，我们也不能显式声明lambda访问者的类型。相反，lambda表达式类型必须通过模板参数推导来推导，所以我们需要一个\texttt{lambda\_visitor()}模板函数，它接受多个lambda表达式参数并从所有这些参数构造\texttt{LambdaVisitor}对象：

\begin{code}
// Example 13
template <typename Base, typename ... F>
auto lambda_visitor(F&& ... f) {
  return LambdaVisitor<Base, Base, F...>(
    std::forward<F>(f) ...);
}
\end{code}

在C++17中，可以用推导指南完成同样的事情。现在我们有了一个存储任意数量lambda表达式的类，并将每个表达式绑定到相应的\texttt{visit()}重写，我们可以像编写lambda表达式一样轻松地编写lambda访问者：

\begin{code}
// Example 13
void walk(Pet& p) {
  auto v(lambda_visitor<PetVisitor>(
  [](Cat* c){std::cout << "Let the " << c->color()
                         << " cat out" << std::endl;},
  [](Dog* d){std::cout << "Take the " << d->color()
                       << " dog for a walk" << std::endl;}
  ));
  p.accept(v);
}
\end{code}

注意，由于我们在继承自相应lambda表达式的同一类中声明\texttt{visit()}函数的方式，\texttt{lambda\_visitor()}函数参数列表中lambda表达式的顺序必须与\texttt{PetVisitor}定义中类型列表中类的顺序匹配。如果需要，可以以实现的一些额外复杂性为代价来消除这个限制。

在C++中处理类型列表的另一种常见方法是将它们存储在\texttt{std::tuple}中：例如，我们可以使用\texttt{std::tuple\textless{}Cat,\ Dog\textgreater{}}来表示由两种类型组成的列表。类似地，整个参数包可以存储在元组中：

\begin{code}
// Example 14
template <typename Base, typename F1, typename... F>
class LambdaVisitor<Base, std::tuple<F1, F...>> :
  public F1, public LambdaVisitor<Base, std::tuple<F...>>;
\end{code}

您可以比较示例13和14，看看如何使用\texttt{std::tuple}来存储类型列表。

我们现在已经看到访问者代码的常见片段如何转换为可重用的模板，以及这如何让我们创建lambda访问者。但我们没有忘记在本章中学到的另一个访问者实现，无环访问者模式。让我们看看它如何也能从现代C++语言特性中受益。

\subsection{泛型无环访问者}

无环访问者模式不需要带有所有可访问类型列表的基类。但是，它有自己的样板代码。首先，每个可访问类型都需要\texttt{accept()}成员函数，它比原始访问者模式中的类似函数有更多代码：

\begin{code}
// Example 10
class Cat : public Pet {
  public:
  void accept(PetVisitor& v) override {
    if (CatVisitor* cv = dynamic_cast<CatVisitor*>(&v)) {
      cv->visit(this);
    } else { // Handle error
      assert(false);
    }
  }
};
\end{code}

假设错误处理是统一的，这个函数为不同类型的访问者重复出现，每个对应于其可访问类型（如这里的\texttt{CatVisitor}）。然后是按类型访问者类本身，例如：

\begin{code}
class CatVisitor {
  public:
  virtual void visit(Cat* c) = 0;
};
\end{code}

再次，这个代码在程序中到处粘贴，稍作修改。让我们将这种容易出错的代码重复转换为易于维护的可重用代码。

我们首先需要创建一些基础设施。无环访问者模式将其层次结构基于所有访问者的通用基类，如下所示：

\begin{code}
class PetVisitor {
  public:
  virtual ~PetVisitor() {}
};
\end{code}

注意这里没有\texttt{Pet}层次结构特定的东西。使用更好的名称，这个类可以作为任何访问者层次结构的基类：

\begin{code}
// Example 15
class VisitorBase {
  public:
  virtual ~VisitorBase() {}
};
\end{code}

我们还需要一个模板来生成所有这些特定于可访问类型的访问者基类，以替换几乎相同的\texttt{CatVisitor}、\texttt{DogVisitor}等。由于这些类需要的只是纯虚\texttt{visit()}方法的声明，我们可以通过可访问类型参数化模板：

\begin{code}
// Example 15
template <typename Visitable> class Visitor {
  public:
  virtual void visit(Visitable* p) = 0;
};
\end{code}

任何类层次结构的基本可访问类现在使用通用的\texttt{VisitorBase}基类接受访问者：

\begin{code}
// Example 15
class Pet {
  ...
  virtual void accept(VisitorBase& v) = 0;
};
\end{code}

我们不是直接从\texttt{Pet}派生每个可访问类并粘贴\texttt{accept()}方法的副本，而是引入一个中间模板基类，可以生成具有正确类型的此方法：

\begin{code}
// Example 15
template <typename Visitable>
class PetVisitable : public Pet {
  public:
  using Pet::Pet;
  void accept(VisitorBase& v) override {
    if (Visitor<Visitable>* pv =
        dynamic_cast<Visitor<Visitable>*>(&v)) {
      pv->visit(static_cast<Visitable*>(this));
    } else { // Handle error
      assert(false);
    }
 }
};
\end{code}

这是我们需要编写的\texttt{accept()}函数的唯一副本，它包含我们应用程序首选的错误处理实现，用于处理访问者不被基类接受的情况（回想一下，无环访问者允许部分访问，其中访问者和可访问的某些组合不受支持）。就像常规访问者一样，中间CRTP基类使得使用这种方法处理深层次结构变得困难。

具体的可访问类通过中间的\texttt{PetVisitable}基类间接从通用的\texttt{Pet}基类继承，这也为它们提供了可访问接口。\texttt{PetVisitable}模板的参数是派生类本身（再次，我们看到CRTP在起作用）：

\begin{code}
// Example 15
class Cat : public PetVisitable<Cat> {
  using PetVisitable<Cat>::PetVisitable;
};
class Dog : public PetVisitable<Dog> {
  using PetVisitable<Dog>::PetVisitable;
};
\end{code}

当然，不是强制性的为所有派生类使用相同的基类构造函数，因为可以根据需要在每个类中定义自定义构造函数。

剩下的就是实现访问者类。回想一下，无环访问者模式中的特定访问者从通用访问者基类和表示支持的可访问类型的每个访问者类继承。这不会改变，但我们现在有了按需生成这些访问者类的方法：

\begin{code}
// Example 15
class FeedingVisitor : public VisitorBase,
                       public Visitor<Cat>,
                       public Visitor<Dog>
{
  public:
  void visit(Cat* c) override {
    std::cout << "Feed tuna to the " << c->color()
              << " cat" << std::endl;
  }
  void visit(Dog* d) override {
    std::cout << "Feed steak to the " << d->color()
              << " dog" << std::endl;
  }
};
\end{code}

让我们回顾一下我们所做的工作——访问者类的并行层次结构不再需要显式输入；相反，它们按需生成。重复的\texttt{accept()}函数被简化为单个\texttt{PetVisitable}类模板。不过，我们必须为每个新的可访问类层次结构编写这个模板。我们也可以泛化这一点，为所有层次结构创建一个可重用的模板，由基本可访问类参数化：

\begin{code}
// Example 16
template <typename Base, typename Visitable>
class VisitableBase : public Base {
  public:
  using Base::Base;
  void accept(VisitorBase& vb) override {
    if (Visitor<Visitable>* v = 
        dynamic_cast<Visitor<Visitable>*>(&vb)) {
      v->visit(static_cast<Visitable*>(this));
    } else { // Handle error
      assert(false);
    }
  }
};
\end{code}

现在，对于每个可访问类层次结构，我们只需要创建一个模板别名：

\begin{code}
// Example 16
template <typename Visitable>
using PetVisitable = VisitableBase<Pet, Visitable>;
\end{code}

我们可以再做一个简化，允许程序员将可访问类的列表指定为类型列表，而不是像我们之前所做的那样从\texttt{Visitor\textless{}Cat\textgreater{}}、\texttt{Visitor\textless{}Dog\textgreater{}}等继承。这需要一个可变参数模板来存储类型列表。实现类似于我们之前看到的\texttt{LambdaVisitor}实例：

\begin{code}
// Example 17
template <typename ... V> struct Visitors;
template <typename V1>
struct Visitors<V1> : public Visitor<V1> {};
template <typename V1, typename ... V>
struct Visitors<V1, V ...> : public Visitor<V1>,
                             public Visitors<V ...> {};
\end{code}

我们可以使用这个包装器模板来缩短特定访问者的声明：

\begin{code}
// Example 17
class FeedingVisitor :
  public VisitorBase, public Visitors<Cat, Dog>
{
  ...
};
\end{code}

如果需要，我们甚至可以在单类型参数的\texttt{Visitors}模板定义中隐藏\texttt{VisitorBase}。

我们现在已经看到了经典的面向对象访问者模式及其可重用实现，这得益于C++的泛型编程工具。在前面的章节中，我们已经看到一些模式如何完全在编译时应用。现在让我们考虑访问者模式是否也可以这样做。

\section{编译时访问者}

在本节中，我们将分析在编译时使用访问者模式的可能性，以类似于策略模式应用导致基于策略的设计的方式。

首先，当在模板上下文中使用时，访问者模式的多重分派方面变得微不足道：

\begin{code}
template <typename T1, typename T2> auto f(T1 t1, T2 t2);
\end{code}

模板函数可以轻松地为\texttt{T1}和\texttt{T2}类型的任何组合运行不同的算法。与使用虚函数实现的运行时多态性不同，基于两个或更多类型不同地分派调用不需要额外成本（当然，除了为我们需要处理的所有组合编写代码）。基于这一观察，我们可以轻松地在编译时模仿经典访问者模式：

\begin{code}
// Example 18
class Pet {
  std::string color_;
  public:
  Pet(std::string_view color) : color_(color) {}
  const std::string& color() const { return color_; }
  template <typename Visitable, typename Visitor>
  static void accept(Visitable& p, Visitor& v) {
    v.visit(p);
  }
};
\end{code}

\texttt{accept()}函数现在是一个模板和静态成员函数——第一个参数的实际类型，即从\texttt{Pet}类派生的可访问对象，将在编译时推导出来。具体的可访问类以通常的方式从基类派生：

\begin{code}
// Example 18
class Cat : public Pet {
  public:
  using Pet::Pet;
};
class Dog : public Pet {
  public:
  using Pet::Pet;
};
\end{code}

访问者不需要从通用基类派生，因为我们现在在编译时解析类型：

\begin{code}
// Example 18
class FeedingVisitor {
  public:
  void visit(Cat& c) {
    std::cout << "Feed tuna to the " << c.color()
              << " cat" << std::endl;
  }
  void visit(Dog& d) {
    std::cout << "Feed steak to the " << d.color()
              << " dog" << std::endl;
  }
};
\end{code}

可访问类可以接受任何具有正确接口的访问者，即层次结构中所有类的\texttt{visit()}重载：

\begin{code}
// Example 18
Cat c("orange");
Dog d("brown");
FeedingVisitor fv;
Pet::accept(c, fv);
Pet::accept(d, fv);
\end{code}

当然，任何接受访问者参数并需要支持多个访问者的函数也必须成为模板（仅有通用基类不再足够，它只有助于在运行时确定实际对象类型）。

编译时访问者解决了与经典访问者相同的问题，它允许我们有效地向类添加新的成员函数而无需编辑类定义。然而，它看起来比运行时版本更不令人兴奋。

当我们将访问者模式与组合模式结合时，会出现更有趣的可能性。当我们讨论复杂对象的访问时，我们已经这样做过一次，特别是在序列化问题的上下文中。这特别有趣的原因是它与C++中缺少的少数几个\emph{重要}特性之一的连接有关；即反射。编程中的反射是程序检查和内省其自身源代码，然后基于这种内省生成新行为的能力。一些编程语言，如Delphi或Python，具有原生反射能力，但C++没有。反射对于解决许多问题很有用：例如，如果我们能让编译器迭代对象的所有数据成员并递归序列化每一个，直到我们到达内置类型，序列化问题就能轻松解决。我们可以使用编译时访问者模式实现类似的东西。

再次，我们将考虑几何对象的层次结构。由于现在一切都在编译时发生，我们对类的多态性质不感兴趣（如果运行时操作需要，它们仍然可以使用虚函数；我们只是不会在本节中编写或查看它们）。例如，这是\texttt{Point}类：

\begin{code}
// Example 19
class Point {
  public:
  Point() = default;
  Point(double x, double y) : x_(x), y_(y) {}
  template <typename This, typename Visitor>
  static void accept(This& t, Visitor& v) {
    v.visit(t.x_);
    v.visit(t.y_);
  }
  private:
  double x_ {};
  double y_ {};
};
\end{code}

如前所述，访问通过\texttt{accept()}函数提供，但现在它是特定于类的。我们有第一个模板参数\texttt{This}的唯一原因是为了轻松支持const和非const操作：\texttt{This}可以是\texttt{Point}或\texttt{const\ Point}。该类的任何访问者都被发送去访问定义点的两个值，\texttt{x\_}和\texttt{y\_}。访问者必须有适当的接口，特别是接受\texttt{double}参数的\texttt{visit()}成员函数。像大多数C++模板库一样，包括\textbf{标准模板库}（\textbf{STL}），这个代码由约定保持在一起——没有要重写的虚函数或要派生的基类，只有对系统中涉及的每个类的接口的要求。更复杂的类由更简单的类组成；例如，这是\texttt{Line}类：

\begin{code}
// Example 19
class Line {
  public:
  Line() = default;
  Line(Point p1, Point p2) : p1_(p1), p2_(p2) {}
  template <typename This, typename Visitor>
  static void accept(This& t, Visitor& v) {
    v.visit(t.p1_);
    v.visit(t.p2_);
  }
  private:
  Point p1_;
  Point p2_;
};
\end{code}

\texttt{Line}类由两个点组成。在编译时，访问者被指示访问每个点。这就是\texttt{Line}类参与的结束；\texttt{Point}类得以确定如何被访问（正如我们刚刚看到的，它也将工作委托给另一个访问者）。由于我们不再使用运行时多态性，现在可以容纳不同类型几何图形的容器类必须是模板：

\begin{code}
// Example 19
template <typename G1, typename G2>
class Intersection {
  public:
  Intersection() = default;
  Intersection(G1 g1, G2 g2) : g1_(g1), g2_(g2) {}
  template <typename This, typename Visitor>
  static void accept(This& t, Visitor& v) {
    v.visit(t.g1_);
    v.visit(t.g2_);
  }
  private:
  G1 g1_;
  G2 g2_;
};
\end{code}

我们现在有了可访问类型。我们可以在这个接口上使用不同种类的访问者，不仅仅是序列化访问者。但是，我们现在专注于序列化。以前，我们已经看到了将对象转换为ASCII字符串的访问者。现在让我们将对象序列化为二进制数据，连续的位流。序列化访问者可以访问一定大小的缓冲区，并将对象写入该缓冲区，每次一个\texttt{double}：

\begin{code}
// Example 19
class BinarySerializeVisitor {
  public:
  BinarySerializeVisitor(char* buffer, size_t size) :
    buf_(buffer), size_(size) {}
  void visit(double x) {
    if (size_ < sizeof(x))
      throw std::runtime_error("Buffer overflow");
    memcpy(buf_, &x, sizeof(x));
    buf_ += sizeof(x);
    size_ -= sizeof(x);
  }
  template <typename T> void visit(const T& t) {
    T::accept(t, *this);
  }
  private:
  char* buf_;
  size_t size_;
};
\end{code}

反序列化访问者从缓冲区读取内存，并将其复制到它恢复的对象的数据成员中：

\begin{code}
// Example 19
class BinaryDeserializeVisitor {
  public:
  BinaryDeserializeVisitor(const char* buffer, size_t size)
    : buf_(buffer), size_(size) {}
  void visit(double& x) {
    if (size_ < sizeof(x))
      throw std::runtime_error("Buffer overflow");
    memcpy(&x, buf_, sizeof(x));
    buf_ += sizeof(x);
    size_ -= sizeof(x);
  }
  template <typename T> void visit(T& t) {
    T::accept(t, *this);
  }
  private:
  const char* buf_;
  size_t size_;
};
\end{code}

两个访问者都通过将内置类型复制到缓冲区和从缓冲区复制来直接处理内置类型，同时让更复杂的类型决定如何处理对象。在这两种情况下，如果超出缓冲区大小，访问者都会抛出异常。现在我们可以使用我们的访问者，例如，通过套接字将对象发送到另一台机器：

\begin{code}
// Example 19
// On the sender machine:
Line l = ...;
Circle c = ...;
Intersection<Circle, Circle> x = ...;
char buffer[1024];
BinarySerializeVisitor serializer(buffer, sizeof(buffer));
serializer.visit(l);
serializer.visit(c);
serializer.visit(x);
... send the buffer to the receiver ...
// On the receiver machine:
Line l;
Circle c;
Intersection<Circle, Circle> x;
BinaryDeserializeVisitor deserializer(buffer, 
  sizeof(buffer));
deserializer.visit(l);
deserializer.visit(c);
deserializer.visit(x);
\end{code}

虽然我们不能在没有语言支持的情况下实现通用反射，但我们可以让类以有限的方式反映其内容，如这种复合访问模式。我们还可以考虑主题的一些变化。

首先，按照惯例，只有一个\emph{重要}成员函数的对象是可调用的；换句话说，我们不调用成员函数，而是使用函数调用语法调用对象本身。这个约定规定\texttt{visit()}成员函数应该称为\texttt{operator()}：

\begin{code}
// Example 20
class BinarySerializeVisitor {
  public:
  void operator()(double x);
  template <typename T> void operator()(const T& t);
  ...
};
\end{code}

可访问类现在像函数一样调用访问者：

\begin{code}
// Example 20
class Point {
  public:
  static void accept(This& t, Visitor& v) {
    v(t.x_);
    v(t.y_);
  }
  ...
};
\end{code}

在多个对象上调用访问者也可能很方便地实现包装函数：

\begin{code}
// Example 20
SomeVisitor v;
Object1 x; Object2 y; ...
visitation(v, x, y, z);
\end{code}

这很容易使用可变参数模板实现：

\begin{code}
// Example 20
template <typename V, typename T>
void visitation(V& v, T& t) {
  v(t);
}
template <typename V, typename T, typename... U>
void visitation(V& v, T& t, U&... u) {
  v(t);
  visitation(v, u ...);
}
\end{code}

在C++17中，我们有折叠表达式，不需要递归模板：

\begin{code}
// Example 20
template <typename V, typename T, typename... U>
void visitation(V& v, U&... u) {
  (v(u), ...);
}
\end{code}

在C++14中，我们可以使用基于\texttt{std::initializer\_list}的技巧来模仿折叠表达式：

\begin{code}
template <typename V, typename T, typename... U>
void visitation(V& v, U&... u) {
  using fold = int[];
  (void)fold { 0, (v(u), 0)... };
}
\end{code}

这可以工作，但它不会在清晰度或可维护性方面获得任何奖项。

编译时访问者通常更容易实现，因为我们不必做任何巧妙的事情来获得多重分派，因为模板开箱即用地提供了它。我们只需要想出模式的有趣应用，比如我们刚刚探索的序列化/反序列化问题。

\section{C++17中的访问者}

C++17在我们使用访问者模式的方式上引入了重大变化，将\texttt{std::variant}添加到标准库中。\texttt{std::variant}模板本质上是一个"智能联合："\texttt{std::variant\textless{}T1,\ T2,\ T3\textgreater{}}类似于\texttt{union\ \{\ T1\ v1;\ T2\ v2;\ T3\ v3;\ \}}，因为两者都可以存储指定类型之一的值，并且一次只能存储一个值。关键区别在于variant对象知道它包含哪种类型，而对于联合，程序员完全负责读取与之前写入的相同类型。将联合作为与用于初始化它的类型不同的类型访问是未定义行为：

\begin{code}
union { int i; double d; std::string s; } u;
u.i = 0;
++u.i;               // OK
std::cout << u.d;     // Undefined behavior
\end{code}

相比之下，\texttt{std::variant}提供了一种在同一内存中存储不同类型值的安全方式。在运行时检查当前在variant中存储哪种替代类型很容易，将variant作为错误类型访问会抛出异常：

\begin{code}
std::variant<int, double, std::string> v;
std::get<int>(v) = 0;     // Initialized as int
std::cout << v.index();     // 0 is the index of int
++std::get<0>(v);     // OK, int is 0th type
std::get<1>(v);          // throws std::bad_variant_access
\end{code}

在许多方面，\texttt{std::variant}提供了类似于基于继承的运行时多态性的能力：两者都让我们编写代码，其中相同的变量名可以在运行时引用不同类型的对象。两个主要区别是：首先，\texttt{std::variant}不要求其所有类型都来自同一层次结构（它们根本不需要是类），其次，variant对象只能存储其声明中列出的类型之一，而基类指针可以指向任何派生类。换句话说，向层次结构添加新类型通常不需要重新编译使用基类的代码，而向variant添加新类型需要更改variant对象的类型，因此引用此对象的所有代码都必须重新编译。

在本节中，我们将专注于使用\texttt{std::variant}进行访问。这种能力由恰当命名的函数\texttt{std::visit}提供，它接受一个可调用和一个variant：

\begin{code}
std::variant<int, double, std::string> v;
struct Print {
  void operator()(int i) { std::cout << i; }
  void operator()(double d) { std::cout << d; }
  void operator()(const std::string& s) { std::cout << s; }
} print;
std::visit(print, v);
\end{code}

要与\texttt{std::visit}一起使用，可调用必须为可以存储在variant中的每种类型声明\texttt{operator()}（否则调用将无法编译）。当然，如果实现相似，我们可以使用模板\texttt{operator()}，无论是在函数对象中还是在lambda中：

\begin{code}
std::variant<int, double, std::string> v;
std::visit([](const auto& x) { std::cout << x;}, v);
\end{code}

我们现在将使用\texttt{std::variant}和\texttt{std::visit}重新实现我们的宠物访问者。首先，\texttt{Pet}类型不再是层次结构的基类，而是包含所有可能类型替代的variant：

\begin{code}
// Example 21
using Pet = 
  std::variant<class Cat, class Dog, class Lorikeet>;
\end{code}

这些类型本身不需要任何访问机制。我们仍然可以使用继承来重用通用实现代码，但类型不需要属于单一层次结构：

\begin{code}
// Example 21
class PetBase {
  public:
  PetBase(std::string_view color) : color_(color) {}
  const std::string& color() const { return color_; }
  private:
  const std::string color_;
};
class Cat : private PetBase {
  public:
  using PetBase::PetBase;
  using PetBase::color;
};
class Dog : private PetBase {
  ... similar to Cat ...
};
class Lorikeet {
  public:
  Lorikeet(std::string_view body, std::string_view head) :
    body_(body), head_(head) {}
  std::string color() const {
    return body_ + " and " + head_;
  }
  private:
  const std::string body_;
  const std::string head_;
};
\end{code}

现在我们需要实现一些访问者。访问者只是可以用可能存储在variant中的每种替代类型调用的可调用对象：

\begin{code}
// Example 21
class FeedingVisitor {
  public:
  void operator()(const Cat& c) {
    std::cout << "Feed tuna to the " << c.color()
              << " cat" << std::endl;
  }
  void operator()(const Dog& d) {
    std::cout << "Feed steak to the " << d.color()
              << " dog" << std::endl;
  }
  void operator()(const Lorikeet& l) {
    std::cout << "Feed grain to the " << l.color()
              << " bird" << std::endl;
  }
};
\end{code}

要将访问者应用于variant，我们调用\texttt{std::visit}：

\begin{code}
// Example 21
Pet p = Cat("orange");
FeedingVisitor v;
std::visit(v, p);
\end{code}

variant \texttt{p}可以包含我们定义类型\texttt{Pet}时列出的任何类型（在此示例中，它是\texttt{Cat}）。然后我们调用\texttt{std::visit}，结果操作取决于访问者本身和当前存储在variant中的类型。结果看起来很像虚函数调用，所以我们可以说\texttt{std::visit}允许我们向一组类型添加新的多态函数（称它们为"虚函数"是误导性的，因为类型甚至不必是类）。

每当我们看到带有用户定义\texttt{operator()}的可调用对象时，我们必须考虑lambda。但是，lambda与\texttt{std::visit}的使用并不简单：我们需要对象可以用可以存储在variant中的每种类型调用，而lambda只有一个\texttt{operator()}。第一个选项是使该操作符成为模板（多态lambda）并在内部处理所有可能的类型：

\begin{code}
// Example 22
#define SAME(v, T) \
  std::is_same_v<std::decay_t<decltype(v)>, T>
auto fv = [](const auto& p) {
  if constexpr (SAME(p, Cat)) {
    std::cout << "Feed tuna to the " << p.color()
              << " cat" << std::endl; }
  else if constexpr (SAME(p, Dog)) {
    std::cout << "Feed steak to the " << p.color()
              << " dog" << std::endl; }
  else if constexpr (SAME(p, Lorikeet)) {
    std::cout << "Feed grain to the " << p.color()
              << " bird" << std::endl; }
  else abort();
};
\end{code}

这里lambda可以用任何类型的参数调用，在lambda主体内部，我们使用\texttt{if\ constexpr}来处理可以存储在variant中的所有类型。这种方法的缺点是我们不再有编译时验证，确保访问者处理所有可能的类型。然而，这样做的另一面是，即使没有处理所有类型，代码现在也会编译，只要访问者不被我们没有定义操作的类型调用，程序就会正常工作。这样，这个版本类似于无环访问者，而之前的实现类似于常规访问者。

也可以使用lambda和我们在\emph{第1章，继承和多态性简介}中看到的创建重载集的技术来实现熟悉的重载\texttt{operator()}集：

\begin{code}
// Example 22
template <typename... T> struct overloaded : T... {
  using T::operator()...;
};
template <typename... T>
overloaded( T...)->overloaded<T...>;
auto pv = overloaded {
  [](const Cat& c) {
    std::cout << "Play with feather with the " << c.color()
              << " cat" << std::endl; },
  [](const Dog& d) {
    std::cout << "Play fetch with the " << d.color()
              << " dog" << std::endl; },
  [](const Lorikeet& l) {
    std::cout << "Teach words to the " << l.color()
              << " bird" << std::endl; }
};
\end{code}

这个访问者是一个从所有lambda继承并暴露其\texttt{operator()}的类，从而创建一组重载。它的使用就像我们显式编写每个\texttt{operator()}的访问者一样：

\begin{code}
// Example 22
Pet l = Lorikeet("yellow", "green");
std::visit(pv, l);
\end{code}

到目前为止，我们还没有使用\texttt{std::visit}的全部潜力：它可以用任意数量的variant参数调用。这允许我们执行依赖于两个以上运行时条件的操作：

\begin{code}
// Example 23
using Pet = std::variant<class Cat, class Dog>;
Pet c1 = Cat("orange");
Pet c2 = Cat("black");
Pet d = Dog("brown");
CareVisitor cv;
std::visit(cv, c1, c2);      // Two cats
std::visit(cv, c1, d);     // Cat and dog
\end{code}

访问者必须以处理可以存储在每个variant中的类型的所有可能组合的方式编写：

\begin{code}
class CareVisitor {
  public:
  void operator()(const Cat& c1, const Cat& c2) {
    std::cout << "Let the " << c1.color() << " and the "
              << c2.color() << " cats play" << std::endl; }
  void operator()(const Dog& d, const Cat& c) {
    std::cout << "Keep the " << d.color()
              << " dog safe from the vicious " << c.color()
              << " cat" << std::endl; }
  void operator()(const Cat& c, const Dog& d) {
    (*this)(d, c);
  }
  void operator()(const Dog& d1, const Dog& d2) {
    std::cout << "Take the " << d1.color() << " and the "
              << d2.color() << " dogs for a walk"
              << std::endl; }
};
\end{code}

在实践中，为所有可能的类型组合编写可调用的唯一可行方法是使用模板\texttt{operator()}，这只有在访问者操作可以以通用方式编写时才有效。尽管如此，执行多重分派的能力是\texttt{std::visit}的一个潜在有用特性，它超越了常规访问者模式的双重分派能力。

\section{总结}

在本章中，我们学习了访问者模式以及在C++中实现它的不同方法。经典的面向对象访问者模式允许我们有效地向整个类层次结构添加新的虚函数，而无需更改类的源代码。层次结构必须是可访问的，但在那之后，可以添加任意数量的操作，它们的实现与对象本身分开保存。在经典访问者模式实现中，包含被访问层次结构的源代码不需要更改，但当向层次结构添加新类时确实需要重新编译。无环访问者模式解决了这个问题，但代价是额外的动态转换。另一方面，无环访问者模式还支持部分访问——忽略某些访问者/可访问组合——而经典访问者模式要求至少必须声明所有组合。

对于所有访问者变体，可扩展性的权衡是需要削弱封装，并且经常授予外部访问者类访问应该是私有数据成员的权限。

访问者模式经常与其他设计模式结合使用，特别是组合模式，以创建复杂的可访问对象。复合对象将访问委托给其包含的对象。当对象必须分解为其最小构建块时，这种组合模式特别有用；例如，用于序列化。

经典访问者模式在运行时实现双重分派——在执行期间，程序根据两个因素选择要运行的代码，访问者和可访问对象的类型。该模式可以在编译时类似地使用，它提供有限的反射能力。

在C++17中，\texttt{std::visit}可以用来将访问者模式扩展到不绑定到通用层次结构的类型，甚至可以实现多重分派。

这一章关于访问者模式曾经是这本专门讨论C++习语和设计模式的书的结论。但是，就像新星一样，新模式的诞生永不停歇——新的前沿和新的想法带来了新的挑战需要解决和新的解决方案需要发明，它们不断发展和完善，直到编程社区集体达到我们可以指出并自信地说的东西，\emph{这通常是处理该问题的好方法}。我们将详细阐述每种新方法的优势，考虑其缺点，并给它命名，以便我们可以简洁地引用关于问题、其解决方案和其注意事项的整套知识。有了这个，一个新模式进入我们的设计工具集和我们的编程词汇。为了说明这个过程，在下一章也是最后一章中，我们收集了一些出现的模式来解决并发程序特有的问题。

\section{问题}

\begin{enumerate}
\item
  什么是访问者模式？
\item
  访问者模式解决什么问题？
\item
  什么是双重分派？
\item
  无环访问者模式的优势是什么？
\item
  访问者模式如何帮助实现序列化？
\end{enumerate}